<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GNN</title>
    <link href="/2024/04/16/GNN/"/>
    <url>/2024/04/16/GNN/</url>
    
    <content type="html"><![CDATA[<h4 id="参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub"><a href="#参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub" class="headerlink" title="参考：A Gentle Introduction to Graph Neural Networks (distill.pub)"></a>参考：<a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a></h4><h4 id="零基础多图详解图神经网络（GNN-GCN）-youtube-com"><a href="#零基础多图详解图神经网络（GNN-GCN）-youtube-com" class="headerlink" title="零基础多图详解图神经网络（GNN&#x2F;GCN） (youtube.com)"></a><a href="https://www.youtube.com/watch?v=sejA2PtCITw&t=770s">零基础多图详解图神经网络（GNN&#x2F;GCN） (youtube.com)</a></h4><h4 id="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"><a href="#总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。" class="headerlink" title="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"></a>总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。</h4><h4 id="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"><a href="#对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。" class="headerlink" title="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"></a>对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。</h4><h3 id="图的预测问题"><a href="#图的预测问题" class="headerlink" title="图的预测问题"></a>图的预测问题</h3><h4 id="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"><a href="#图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。" class="headerlink" title="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"></a>图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。</h4><h4 id="图的任务："><a href="#图的任务：" class="headerlink" title="图的任务："></a>图的任务：</h4><h5 id="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"><a href="#举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。" class="headerlink" title="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"></a>举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。</h5><h4 id="节点的任务："><a href="#节点的任务：" class="headerlink" title="节点的任务："></a>节点的任务：</h4><h5 id="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"><a href="#节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。" class="headerlink" title="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"></a>节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。</h5><h4 id="边的任务："><a href="#边的任务：" class="headerlink" title="边的任务："></a>边的任务：</h4><h5 id="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"><a href="#边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。" class="headerlink" title="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"></a>边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。</h5><h3 id="在机器学习中使用图的挑战"><a href="#在机器学习中使用图的挑战" class="headerlink" title="在机器学习中使用图的挑战"></a>在机器学习中使用图的挑战</h3><h4 id="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"><a href="#首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。" class="headerlink" title="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"></a>首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。</h4><h4 id="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"><a href="#比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。" class="headerlink" title="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"></a>比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。</h4><h4 id="我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。"><a href="#我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。" class="headerlink" title="我们可以用邻接表来解决问题，图中每个节点&#x2F;边&#x2F;全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。"></a>我们可以用邻接表来解决问题，图中每个节点&#x2F;边&#x2F;全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。</h4><h3 id="什么是GNN"><a href="#什么是GNN" class="headerlink" title="什么是GNN"></a>什么是GNN</h3><h4 id="GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"><a href="#GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。" class="headerlink" title="GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"></a>GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。</h4><h4 id="最简单的GNN"><a href="#最简单的GNN" class="headerlink" title="最简单的GNN"></a>最简单的GNN</h4><h5 id="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"><a href="#为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。" class="headerlink" title="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"></a>为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。</h5><h5 id="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"><a href="#就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。" class="headerlink" title="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"></a>就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。</h5><h4 id="通过Pooling信息进行-GNN-预测"><a href="#通过Pooling信息进行-GNN-预测" class="headerlink" title="通过Pooling信息进行 GNN 预测"></a>通过Pooling信息进行 GNN 预测</h4><h5 id="我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"><a href="#我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。" class="headerlink" title="我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"></a>我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。</h5><h5 id="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"><a href="#图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总" class="headerlink" title="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"></a>图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总</h5><h5 id="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"><a href="#因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。" class="headerlink" title="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"></a>因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。</h5><h5 id="在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"><a href="#在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。" class="headerlink" title="在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"></a>在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。</h5><h5 id="现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"><a href="#现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。" class="headerlink" title="现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"></a>现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。</h5><h4 id="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"><a href="#这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。" class="headerlink" title="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"></a>这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。</h4><h3 id="在图的不同部分之间传递信息"><a href="#在图的不同部分之间传递信息" class="headerlink" title="在图的不同部分之间传递信息"></a>在图的不同部分之间传递信息</h3><h4 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h4><blockquote><p>首先对于图中的每个节点，收集所有相邻节点的嵌入（或信息）。<br>通过聚合函数（如 sum）汇总所有信息。<br>所有汇集的信息将通过一个更新函数（通常是一个学习的神经网络）进行传递。<br>中间的transgorm information可以看出一个f</p></blockquote><h4 id="这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"><a href="#这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。" class="headerlink" title="这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"></a>这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。</h4><h4 id="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"><a href="#但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。" class="headerlink" title="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"></a>但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。</h4><h3 id="学习边缘表征"><a href="#学习边缘表征" class="headerlink" title="学习边缘表征"></a>学习边缘表征</h3><h4 id="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"><a href="#我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。" class="headerlink" title="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"></a>我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。</h4><h4 id="我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"><a href="#我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。" class="headerlink" title="我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"></a>我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。</h4><h4 id="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"><a href="#就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。" class="headerlink" title="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"></a>就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。</h4><h4 id="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"><a href="#还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。" class="headerlink" title="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"></a>还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。</h4><h4 id="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"><a href="#就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。" class="headerlink" title="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"></a>就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。</h4><h3 id="添加全局表示"><a href="#添加全局表示" class="headerlink" title="添加全局表示"></a>添加全局表示</h3><h4 id="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。"><a href="#迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。" class="headerlink" title="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。"></a>迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。</h4><h4 id="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"><a href="#解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。" class="headerlink" title="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"></a>解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。</h4><h4 id="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"><a href="#在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。" class="headerlink" title="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"></a>在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。</h4><h4 id="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"><a href="#就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。" class="headerlink" title="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"></a>就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。</h4><h4 id="A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"><a href="#A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好" class="headerlink" title="A Gentle Introduction to Graph Neural Networks (distill.pub)在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"></a><a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a>在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好</h4><h4 id="GNN-中的采样图和批处理"><a href="#GNN-中的采样图和批处理" class="headerlink" title="GNN 中的采样图和批处理"></a>GNN 中的采样图和批处理</h4><h5 id="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。"><a href="#训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。" class="headerlink" title="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。"></a>训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。</h5><h5 id="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"><a href="#就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。" class="headerlink" title="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"></a>就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。</h5><h3 id="归纳偏差"><a href="#归纳偏差" class="headerlink" title="归纳偏差"></a>归纳偏差</h3><h4 id="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"><a href="#当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。" class="headerlink" title="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"></a>当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。</h4><h4 id="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"><a href="#例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。" class="headerlink" title="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"></a>例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。</h4><h4 id="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"><a href="#就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。" class="headerlink" title="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"></a>就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。</h4><h4 id="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"><a href="#模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。" class="headerlink" title="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"></a>模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN</title>
    <link href="/2024/03/30/CNN/"/>
    <url>/2024/03/30/CNN/</url>
    
    <content type="html"><![CDATA[<p>一、常用的方向：人脸识别（主要是特征值的提取），检测任务，分类和检索，超分辨率重构（用于图片），医学任务，一些识别，无人驾驶。</p><h3 id="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"><a href="#二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。" class="headerlink" title="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28*28*1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"></a>二、与传统神经网络的区别：<a href="https://zhuanlan.zhihu.com/p/242853150">【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)</a>卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28<code>*</code>28<code>*</code>1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。</h3><h3 id="三、整体架构：分为输入层，卷积层，池化层，全连接层。"><a href="#三、整体架构：分为输入层，卷积层，池化层，全连接层。" class="headerlink" title="三、整体架构：分为输入层，卷积层，池化层，全连接层。"></a>三、整体架构：分为输入层，卷积层，池化层，全连接层。</h3><h4 id="输入层：输入数据；"><a href="#输入层：输入数据；" class="headerlink" title="输入层：输入数据；"></a>输入层：输入数据；</h4><h4 id="卷积层：使用卷积核进行特征提取和特征映射。"><a href="#卷积层：使用卷积核进行特征提取和特征映射。" class="headerlink" title="卷积层：使用卷积核进行特征提取和特征映射。"></a>卷积层：使用卷积核进行特征提取和特征映射。</h4><h4 id="池化层：进行采样降维。"><a href="#池化层：进行采样降维。" class="headerlink" title="池化层：进行采样降维。"></a>池化层：进行采样降维。</h4><h4 id="全连接层：在尾部进行拟合，减少特征信息的损失。"><a href="#全连接层：在尾部进行拟合，减少特征信息的损失。" class="headerlink" title="全连接层：在尾部进行拟合，减少特征信息的损失。"></a>全连接层：在尾部进行拟合，减少特征信息的损失。</h4><h3 id="四，卷积做了什么；"><a href="#四，卷积做了什么；" class="headerlink" title="四，卷积做了什么；"></a>四，卷积做了什么；</h3><p>![[Pasted image 20240325203433.png]]</p><h4 id="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"><a href="#从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。" class="headerlink" title="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"></a>从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。</h4><h4 id="五、卷积特征值的计算方法"><a href="#五、卷积特征值的计算方法" class="headerlink" title="五、卷积特征值的计算方法"></a>五、卷积特征值的计算方法</h4><h4 id="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png"><a href="#首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png" class="headerlink" title="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]"></a>首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]</h4><h4 id="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"><a href="#我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。" class="headerlink" title="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1&#x3D;0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"></a>我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1&#x3D;0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。</h4><h3 id="六，得到特征图表示"><a href="#六，得到特征图表示" class="headerlink" title="六，得到特征图表示"></a>六，得到特征图表示</h3><h4 id="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"><a href="#其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。" class="headerlink" title="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"></a>其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。</h4><h3 id="七，步长与卷积核大小对结果的影响。"><a href="#七，步长与卷积核大小对结果的影响。" class="headerlink" title="七，步长与卷积核大小对结果的影响。"></a>七，步长与卷积核大小对结果的影响。</h3><h4 id="对特征图基础上行多次卷积。"><a href="#对特征图基础上行多次卷积。" class="headerlink" title="对特征图基础上行多次卷积。"></a>对特征图基础上行多次卷积。</h4><p>![[Pasted image 20240325233943.png]]<br>![[Pasted image 20240325234007.png]]</p><h5 id="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"><a href="#我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。" class="headerlink" title="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"></a>我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。</h5><h4 id="滑动窗口步长"><a href="#滑动窗口步长" class="headerlink" title="滑动窗口步长"></a>滑动窗口步长</h4><p>![[Pasted image 20240325235101.png]]</p><h5 id="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"><a href="#对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。" class="headerlink" title="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"></a>对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。</h5><h4 id="卷积核的尺寸"><a href="#卷积核的尺寸" class="headerlink" title="卷积核的尺寸"></a>卷积核的尺寸</h4><h5 id="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"><a href="#取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。" class="headerlink" title="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"></a>取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。</h5><h4 id="边缘填充方法"><a href="#边缘填充方法" class="headerlink" title="边缘填充方法"></a>边缘填充方法</h4><p>![[Pasted image 20240326104300.png]]</p><h5 id="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。"><a href="#我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。" class="headerlink" title="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad &#x3D; 1。"></a>我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad &#x3D; 1。</h5><h4 id="卷积核个数"><a href="#卷积核个数" class="headerlink" title="卷积核个数"></a>卷积核个数</h4><h5 id="就是多少个特征图，就要多少个卷积核。"><a href="#就是多少个特征图，就要多少个卷积核。" class="headerlink" title="就是多少个特征图，就要多少个卷积核。"></a>就是多少个特征图，就要多少个卷积核。</h5><h3 id="八，特征图尺寸计算和参数共享"><a href="#八，特征图尺寸计算和参数共享" class="headerlink" title="八，特征图尺寸计算和参数共享"></a>八，特征图尺寸计算和参数共享</h3><h4 id="卷积结果计算公式"><a href="#卷积结果计算公式" class="headerlink" title="卷积结果计算公式"></a>卷积结果计算公式</h4><p>![[Pasted image 20240326163117.png]]</p><h4 id="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"><a href="#为什么是加2p因为一圈，左右两边都会加，所以是加2p。" class="headerlink" title="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"></a>为什么是加2p因为一圈，左右两边都会加，所以是加2p。</h4><p>![[Pasted image 20240326163842.png]]</p><h4 id="通过这张图可以看出怎么计算。"><a href="#通过这张图可以看出怎么计算。" class="headerlink" title="通过这张图可以看出怎么计算。"></a>通过这张图可以看出怎么计算。</h4><h4 id="卷积参数共享"><a href="#卷积参数共享" class="headerlink" title="卷积参数共享"></a>卷积参数共享</h4><p>![[Pasted image 20240326165236.png]]</p><h5 id="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"><a href="#就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。" class="headerlink" title="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"></a>就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。</h5><h3 id="九，池化层的作用"><a href="#九，池化层的作用" class="headerlink" title="九，池化层的作用"></a>九，池化层的作用</h3><p>![[Pasted image 20240327204655.png]]</p><h4 id="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"><a href="#可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。" class="headerlink" title="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"></a>可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。</h4><p>![[Pasted image 20240327205050.png]]</p><h3 id="十、整体网络结构"><a href="#十、整体网络结构" class="headerlink" title="十、整体网络结构"></a>十、整体网络结构</h3><p>![[Pasted image 20240327233452.png]]</p><h4 id="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"><a href="#我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。" class="headerlink" title="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"></a>我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。</h4><h4 id="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5"><a href="#RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5" class="headerlink" title="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的[10240,5]"></a>RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的<code>[10240,5]</code></h4><p>![[Pasted image 20240327235319.png]]</p><h4 id="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"><a href="#特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。" class="headerlink" title="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"></a>特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。</h4><h3 id="十一，VGN网络架构"><a href="#十一，VGN网络架构" class="headerlink" title="十一，VGN网络架构"></a>十一，VGN网络架构</h3><h4 id="Alexnet这个比较早就没什么好说的。"><a href="#Alexnet这个比较早就没什么好说的。" class="headerlink" title="Alexnet这个比较早就没什么好说的。"></a>Alexnet这个比较早就没什么好说的。</h4><h4 id="Vgg经典网络"><a href="#Vgg经典网络" class="headerlink" title="Vgg经典网络"></a>Vgg经典网络</h4><p>![[Pasted image 20240330143149.png]]</p><h5 id="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"><a href="#从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。" class="headerlink" title="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"></a>从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。</h5><h4 id="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"><a href="#然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。" class="headerlink" title="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"></a>然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。</h4><h3 id="十二、残差网络Resnet"><a href="#十二、残差网络Resnet" class="headerlink" title="十二、残差网络Resnet"></a>十二、残差网络Resnet</h3><h4 id="深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。"><a href="#深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。" class="headerlink" title="深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。"></a>深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。</h4><h4 id="解决方案：加了Resnet"><a href="#解决方案：加了Resnet" class="headerlink" title="解决方案：加了Resnet"></a>解决方案：加了Resnet</h4><p>![[Pasted image 20240330145212.png]]</p><h5 id="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"><a href="#这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。" class="headerlink" title="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"></a>这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。</h5><p>![[Pasted image 20240330145724.png]]</p><h4 id="深层的神经网络就会变成这样。"><a href="#深层的神经网络就会变成这样。" class="headerlink" title="深层的神经网络就会变成这样。"></a>深层的神经网络就会变成这样。</h4><h3 id="十三、感受野"><a href="#十三、感受野" class="headerlink" title="十三、感受野"></a>十三、感受野</h3><h4 id="一开始看感觉要一会，但是理解了。"><a href="#一开始看感觉要一会，但是理解了。" class="headerlink" title="一开始看感觉要一会，但是理解了。"></a>一开始看感觉要一会，但是理解了。</h4><h4 id="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次"><a href="#神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次" class="headerlink" title="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次."></a>神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此<strong>感受野的值可以用来大致判断每一层的抽象层次</strong>.</h4><h4 id="如何算感受野"><a href="#如何算感受野" class="headerlink" title="如何算感受野"></a>如何算感受野</h4><h5 id="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"><a href="#例子：求三个3×3的卷积层，保持步长为一，求它的感受野。" class="headerlink" title="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"></a>例子：求三个3×3的卷积层，保持步长为一，求它的感受野。</h5><h4 id="公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小"><a href="#公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小" class="headerlink" title="公式：前一层卷积核感受野 &#x3D; （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小"></a>公式：<strong>前一层卷积核感受野 &#x3D; （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小</strong></h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">首先是最后一层是一个，(1<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 3<br>接着计算：(3<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 5<br>然后计算:(5<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 7<br>所以感受野即为7<br></code></pre></td></tr></table></figure><h4 id="问题：为什么要堆叠三个小卷积："><a href="#问题：为什么要堆叠三个小卷积：" class="headerlink" title="问题：为什么要堆叠三个小卷积："></a>问题：为什么要堆叠三个小卷积：</h4>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分题单</title>
    <link href="/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/"/>
    <url>/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h4 id="关于二分区间的操作"><a href="#关于二分区间的操作" class="headerlink" title="关于二分区间的操作"></a>关于二分区间的操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//左闭右闭</span><br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;l;<br><br><span class="hljs-comment">//左闭右开</span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//if(nums[mid]&lt;target)</span><br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-comment">//注意check()的判断true应该是小于而不是小于等于</span><br><br><span class="hljs-comment">//左开右闭</span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>mid = (l+<span class="hljs-number">1</span>+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid <span class="hljs-number">-1</span>;<span class="hljs-comment">//if(nums[mid]&gt;target)</span><br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;L;<br><span class="hljs-comment">//注意对于check()的判断true应该是大于而不是大于等于</span><br></code></pre></td></tr></table></figure><h4 id="P1102-A-B数对"><a href="#P1102-A-B数对" class="headerlink" title="P1102 A-B数对"></a>P1102 A-B数对</h4><h4 id="题目要求就是找出符合A-B-C的情况。"><a href="#题目要求就是找出符合A-B-C的情况。" class="headerlink" title="题目要求就是找出符合A - B &#x3D; C的情况。"></a>题目要求就是找出符合A - B &#x3D; C的情况。</h4><h4 id="题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。"><a href="#题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。" class="headerlink" title="题解，我们可以知道C是已知的，所以我们可以写成A &#x3D; B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。"></a>题解，我们可以知道C是已知的，所以我们可以写成A &#x3D; B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。</h4><h4 id="STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。"><a href="#STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。" class="headerlink" title="STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。"></a>STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>ll a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>ll n,c;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">sort</span>(a,a+n);<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>sum += <span class="hljs-built_in">upper_bound</span>(a,a+n,a[i]+c)-<span class="hljs-built_in">lower_bound</span>(a,a+n,a[i]+c);<br><span class="hljs-comment">//a[i]+c就是b，在元素找出符合a的值</span><br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1873-砍树"><a href="#P1873-砍树" class="headerlink" title="P1873 砍树"></a>P1873 砍树</h4><h4 id="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"><a href="#题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。" class="headerlink" title="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"></a>题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,m,l,r,trees[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;trees[i];<br>r = <span class="hljs-built_in">max</span>(r,trees[i]);<br>&#125;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-comment">//查找的右区间</span><br>ll mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>ll s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(trees[i]&gt;mid)&#123;<br>s += trees[i] - mid;<span class="hljs-comment">//将多的部分切下来</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(s&gt;=m)&#123;<span class="hljs-comment">//如果切的过多就是还要更高</span><br>l = mid;<br><br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h4><h4 id="题目的意思"><a href="#题目的意思" class="headerlink" title="题目的意思"></a>题目的意思</h4><blockquote><p>现有 m 所学校，每所学校预计分数线是 ai​。有 n 位学生，估分分别为 bi​。根据 n 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p></blockquote><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行读入两个整数 m,n。m 表示学校数，n 表示学生数。</p><p>第二行共有 m 个数，表示 m 个学校的预计录取分数。第三行有 n 个数，表示 n 个学生的估分成绩</p><h4 id="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"><a href="#题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。" class="headerlink" title="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"></a>题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。</h4><h4 id="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"><a href="#对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。" class="headerlink" title="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是[1,2,4,5]那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"></a>对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是<code>[1,2,4,5]</code>那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。</h4><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> x[N],s[N]; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;x[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;s[i];<br>&#125;<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-built_in">lower_bound</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+m,s[i])-x;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//在开头</span><br>sum+=<span class="hljs-built_in">abs</span>(x[a]-s[i]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==m+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//在末尾</span><br>sum += <span class="hljs-built_in">abs</span>(x[m]-s[i]);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//中间的数</span><br>sum += <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(x[a<span class="hljs-number">-1</span>]-s[i]),<span class="hljs-built_in">abs</span>(x[a]-s[i]));<br>&#125;<br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h4><h4 id="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"><a href="#题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板" class="headerlink" title="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"></a>题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板</h4><h4 id="题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"><a href="#题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。" class="headerlink" title="题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"></a>题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。</h4><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,k,a[N];<br>ll l,r = <span class="hljs-number">1e8</span>+<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ans += a[i]/x;<br>&#125;<br><span class="hljs-keyword">return</span> ans&gt;=k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>ll mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid))&#123;<br>l = mid;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>r = mid <span class="hljs-number">-1</span> ;<br>&#125;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h4><h4 id="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、"><a href="#题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、" class="headerlink" title="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、"></a>题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、</h4><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><h5 id="第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0"><a href="#第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0" class="headerlink" title="第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置"></a>第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置</h5><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以"><a href="#题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以" class="headerlink" title="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;&#x3D;至多移走的岩石数。"></a>题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;&#x3D;至多移走的岩石数。</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;const int N = 5e5+10;typedef long long ll;using namespace std;int a[N];int d,n,m;bool check(int x)&#123;    int cnt = 0;//当前最短跳跃需要移走的个数    int now = 0;    int i = 0;    while(i&lt;n+1)&#123;        i++;        if(a[i]-a[now]&lt;x)&#123;//如果跳跃距离小于当前的就需要移            cnt++;        &#125;        else&#123;            now = i;//如果不需要那就跳到当前的石头        &#125;    &#125;    if(cnt&gt;m) return false;//大于就说明小的更多还不够小    else return true;&#125;void solve()&#123;    cin&gt;&gt;d&gt;&gt;n&gt;&gt;m;    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;a[i];    a[n+1] = d;//相当于总数是n+1    int l = 0,r = d;    while(l&lt;r)&#123;        int mid = (l+r+1)&gt;&gt;1;        if(check(mid))&#123;            l = mid;        &#125;        else&#123;            r = mid-1;        &#125;    &#125;    cout&lt;&lt;l;&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    solve();&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder341 d</title>
    <link href="/2024/02/21/Atcoder341-d/"/>
    <url>/2024/02/21/Atcoder341-d/</url>
    
    <content type="html"><![CDATA[<h4 id="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"><a href="#前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。" class="headerlink" title="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"></a>前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。</h4><h4 id="问题陈述"><a href="#问题陈述" class="headerlink" title="#### 问题陈述"></a>#### 问题陈述</h4><h4 id="给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。"><a href="#给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。" class="headerlink" title="给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。"></a>给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。</h4><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h4 id="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"><a href="#题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。" class="headerlink" title="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"></a>题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">对于这道题，我们可以将k作为一个基准值，可以用二分法找到想要的数字，所以对于这里我们可用二分进行二分答案的操作，因为是一个整除所以说明两个的公因数是不行的，就比如<span class="hljs-number">6</span>，被<span class="hljs-number">2</span>和<span class="hljs-number">3</span>整除。这个就要被去掉，所以我们需要找到两个数的最大公因数，所以就是找到最小公倍数。然后我们举个例子：如果我们想要知道<span class="hljs-number">15</span>以内的合法序列的数，我们可以求<span class="hljs-number">20</span>以内<span class="hljs-number">2</span>的个数<span class="hljs-symbol">:20</span>/<span class="hljs-number">2</span>,对于<span class="hljs-number">3</span>的个数就是<span class="hljs-symbol">:20</span>/<span class="hljs-number">3</span>，然后我们需要去掉两者的最小倍数，但是在<span class="hljs-number">2</span>的时候算了一次，又在<span class="hljs-number">3</span>的时候算了一次，所以我们需要减掉两倍的<span class="hljs-number">20</span>/两者的最大公因数。所以我们可以抽象成数学，二分的就是<span class="hljs-built_in">mid</span>,所以我们判断x是k，我们可以写成[<span class="hljs-built_in">mid</span>/<span class="hljs-built_in">n</span>]+[<span class="hljs-built_in">mid</span>/m]-<span class="hljs-number">2</span>*[<span class="hljs-built_in">mid</span>/<span class="hljs-built_in">lcm</span>(<span class="hljs-built_in">n</span>,m)]然后来判断大小<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x,<span class="hljs-type">long</span> <span class="hljs-type">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x&gt;y)<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">if</span>(y%x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(y%x,x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n,m,x,k;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>x=(n*m)/<span class="hljs-built_in">gcd</span>(n,m);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">0</span>,r=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">2e+18</span>,mid,y;<br><span class="hljs-keyword">while</span>((l+<span class="hljs-number">1</span>)&lt;r)&#123;<br>mid=(l+r)/<span class="hljs-number">2</span>;<br>y=(mid/n)+(mid/m)<span class="hljs-number">-2</span>*(mid/x);<br><span class="hljs-keyword">if</span>(y&lt;k)l=mid;<br><span class="hljs-keyword">else</span> r=mid;<br>&#125;<br>cout&lt;&lt;r&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题练习2</title>
    <link href="/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/"/>
    <url>/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h4 id="【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"><a href="#【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。" class="headerlink" title="【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"></a><a href="https://blog.csdn.net/ronaldo7_zyb/article/details/81069906">【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客</a>背包求方案数的一系列模板可以得到思路。</h4><h4 id="P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5365 英雄联盟P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P5365 英雄联盟<a href="https://www.luogu.com.cn/problem/P5365">P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"><a href="#题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。" class="headerlink" title="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f[j] = max(f[j],f[j-x*c[i]]*x)然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"></a>题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，<code>f[j] = max(f[j],f[j-x*c[i]]*x)</code>然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n,m,k[N],c[N],dp[N],qm;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;c[i];<br>qm+=k[i]*c[i];<span class="hljs-comment">//钱的总数</span><br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = qm;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<span class="hljs-comment">//只能选一次01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x&lt;=k[i];x++)&#123;<span class="hljs-comment">//皮肤个数</span><br><span class="hljs-keyword">if</span>(j&gt;=x*c[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-c[i]*x]*x);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;<br><span class="hljs-keyword">if</span>(dp[i]&gt;=m)&#123;<span class="hljs-comment">//找到大于等于的方案数</span><br>cout&lt;&lt;i;<span class="hljs-comment">//输出下标。</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1077 摆花P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1077 摆花<a href="https://www.luogu.com.cn/problem/P1077">P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。"><a href="#思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。" class="headerlink" title="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp[0] = 1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min(a[i],j)就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))。这个可以看一下顶上的文章求可行方案数。"></a>思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将<code>dp[0] = 1</code>，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是<code>min(a[i],j)</code>就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到<code>fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))</code>。这个可以看一下顶上的文章求可行方案数。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,a[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>dp[<span class="hljs-number">0</span>]= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">min</span>(a[i],j);k++)&#123;<br>dp[j]= dp[j-k]+dp[j];<br>dp[j] %= mod;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m]%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2347P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2347<a href="https://www.luogu.com.cn/problem/P2347">P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"><a href="#很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。" class="headerlink" title="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"></a>很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> num[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>&#125;;<br><span class="hljs-type">int</span> dp[N],a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br>cin&gt;&gt;a[i];<br>sum+=a[i]*num[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=a[i];k++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=num[i<span class="hljs-number">-1</span>]*k)&#123;<br>dp[j]+=dp[j-num[i<span class="hljs-number">-1</span>]*k];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=sum;i++)&#123;<br><span class="hljs-keyword">if</span>(dp[i]) ans++;<br> &#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Total=&quot;</span>&lt;&lt;ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题练习1</title>
    <link href="/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/"/>
    <url>/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h4 id="P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1833 樱花P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1833 樱花<a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"><a href="#题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。" class="headerlink" title="题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"></a>题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> c[N],dp[N],t[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> th1,ts1,th2,ts2,n;<br><span class="hljs-type">char</span> cc;<br>cin&gt;&gt;th1&gt;&gt;cc&gt;&gt;ts1&gt;&gt;th2&gt;&gt;cc&gt;&gt;ts2&gt;&gt;n;<br><span class="hljs-type">int</span> tz = <span class="hljs-number">60</span>*(th2-th1)+ts2-ts1;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> t0,c0,s;<br>cin&gt;&gt;t0&gt;&gt;c0&gt;&gt;s;<br><span class="hljs-keyword">if</span>(s==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//完全背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=tz;j++) <span class="hljs-keyword">if</span>(j&gt;=t0) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t0]+c0);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//多重背包加上01背包写一起</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>cnt++;<br>t[cnt] = k*t0;<br>c[cnt] = k*c0;<br>s-=k;<br>k*=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(s)&#123;<br>cnt++;<br>t[cnt] = s*t0;<br>c[cnt] = s*c0;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">1</span>;m&lt;=cnt;m++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = tz;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=t[m]) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t[m]]+c[m]);<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br>cout&lt;&lt;dp[tz];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"><a href="#当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、" class="headerlink" title="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"></a>当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、</h4><h4 id="P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1049 装箱问题(01背包)P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1049 装箱问题(01背包)<a href="https://www.luogu.com.cn/problem/P1049">P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="代码-简单就不写题解"><a href="#代码-简单就不写题解" class="headerlink" title="代码(简单就不写题解)"></a>代码(简单就不写题解)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20010</span>],v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> v1,n;<br>cin&gt;&gt;v1&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v1;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=v[i])dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+v[i]);<br>&#125;<br>&#125;<br>cout&lt;&lt;v1-dp[v1];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="01背包求方案数"><a href="#01背包求方案数" class="headerlink" title="01背包求方案数"></a>01背包求方案数</h4><h4 id="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。"><a href="#就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。" class="headerlink" title="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max(f[j],f[j-v]+w)，如果maxn==f[j]就是说是前一个更好，所以f[j] = maxn然后就是将方案数变成g[j-a]，如果相等的话，就是相当于有两条路，g[j] = (g[j]+g[j-a])就是说这两条路的方案数都要。"></a>就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到<code>max(f[j],f[j-v]+w)</code>，如果<code>maxn==f[j]</code>就是说是前一个更好，所以<code>f[j] = maxn</code>然后就是将方案数变成<code>g[j-a]</code>，如果相等的话，就是相当于有两条路，<code>g[j] = (g[j]+g[j-a])</code>就是说这两条路的方案数都要。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,v,a,b,f[<span class="hljs-number">1005</span>],g[<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=v;i++)<br>        g[i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//输入废话</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v;j&gt;=a;j--)&#123;<br>            <span class="hljs-type">int</span> z=f[j-a]+b;<span class="hljs-comment">//先用一个数存起来f[j-a]+b</span><br>            <span class="hljs-keyword">if</span>(f[j]&lt;z)&#123;如果f[j]小于它<br>                f[j]=z;<span class="hljs-comment">//更新f[j]</span><br>                g[j]=g[j-a];<span class="hljs-comment">//方案数变为g[j-a]</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[j]==z)<span class="hljs-comment">//否则如果它们相等</span><br>                g[j]=(g[j]+g[j-a])%<span class="hljs-number">1000000007</span>;<span class="hljs-comment">//方案数更新为现在的方案数加上g[j-a]的方案数取模1e9+7</span><br>        &#125;<br>    &#125;<br>    cout&lt;&lt;g[v];<span class="hljs-comment">//最后输出最优选法方案数</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1164 小A点菜P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1164 小A点菜<a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。"><a href="#这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。" class="headerlink" title="这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp[]数组即可。"></a>这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp<code>[]</code>数组即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">105</span>],f[<span class="hljs-number">105</span>][<span class="hljs-number">10005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <br>&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == j)<br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>            &#125;  <br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">if</span>(a[i]&gt;j) <br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j];<br>            &#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j-a[i]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1060 开心的金明(01背包)P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1060 开心的金明(01背包)<a href="https://www.luogu.com.cn/problem/P1060">P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"><a href="#题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可" class="headerlink" title="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"></a>题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">30050</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> p[M],v[M],dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;v[i]&gt;&gt;p[i];<br>p[i] = v[i]*p[i];<span class="hljs-comment">//相当于乘机</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=v[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+p[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2722P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2722<a href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="一个板子题，看到可以重复选择就说明是完全背包。"><a href="#一个板子题，看到可以重复选择就说明是完全背包。" class="headerlink" title="一个板子题，看到可以重复选择就说明是完全背包。"></a>一个板子题，看到可以重复选择就说明是完全背包。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> t[N],p[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;p[i]&gt;&gt;t[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=t[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t[i]]+p[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1853 投资的最大效益P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1853 投资的最大效益<a href="https://www.luogu.com.cn/problem/P1853">P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"><a href="#题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子" class="headerlink" title="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"></a>题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> a[M],b[M];<span class="hljs-comment">//投资额,年利息</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> sum,year,n;<br>cin&gt;&gt;sum&gt;&gt;year&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i]&gt;&gt;b[i];<br>a[i]/=<span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=year;k++)&#123;<br><span class="hljs-type">int</span> t = sum/<span class="hljs-number">1000</span>;<span class="hljs-comment">//总额更新</span><br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//dp数组清0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=t;j++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=a[i]) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+b[i]);<br>&#125;<br>&#125;<br>sum+=dp[t];<span class="hljs-comment">//每年的最大值加到总额里面。</span><br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2023/10/28/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/28/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="优先队列-priority-queue-是堆的排列"><a href="#优先队列-priority-queue-是堆的排列" class="headerlink" title="优先队列(priority_queue)是堆的排列"></a>优先队列(priority_queue)是堆的排列</h3><h3 id="优先队列的一些性质"><a href="#优先队列的一些性质" class="headerlink" title="优先队列的一些性质"></a>优先队列的一些性质</h3><h4 id="首先优先队列是默认是大根堆"><a href="#首先优先队列是默认是大根堆" class="headerlink" title="首先优先队列是默认是大根堆"></a>首先优先队列是默认是大根堆</h4><h3 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">q.size();<span class="hljs-comment">//返回q里元素个数</span><br>q.empty();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.push(k);<span class="hljs-comment">//在q的末尾插入k </span><br>q.pop();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.top();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure><h4 id="而优先队列的强大功能就是可以自动排序"><a href="#而优先队列的强大功能就是可以自动排序" class="headerlink" title="而优先队列的强大功能就是可以自动排序"></a>而优先队列的强大功能就是可以自动排序</h4><h4 id="https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BC-98-E5-85-88-E9-98-9F-E5-88-97-png-比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。"><a href="#https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BC-98-E5-85-88-E9-98-9F-E5-88-97-png-比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。" class="headerlink" title="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png 比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。"></a><a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png</a> 比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。</h4><h3 id="拿一道默认的优先队列"><a href="#拿一道默认的优先队列" class="headerlink" title="拿一道默认的优先队列"></a>拿一道默认的优先队列</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br>你有一个菜篮子。<br><br>接下来Q次操作，每次操作如下：<br><br><span class="hljs-number">1</span>. <span class="hljs-string">&quot;1 x&quot;</span>，将一个重量为<span class="hljs-keyword">x</span>的菜放入到菜篮子中。<br>    <br><span class="hljs-number">2</span>. <span class="hljs-string">&quot;2&quot;</span>，将菜篮子中重量最大的菜丢掉（如果菜篮子为空，则跳过）。<br>    <br><br>问Q次操作后，菜篮子中剩下的菜的总重量。<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> q;<br><br>  cin &gt;&gt; q;<br><br>  ll sum = <span class="hljs-number">0</span>;<br><br>  priority_queue&lt;ll&gt; pq;<span class="hljs-comment">//默认是大根堆</span><br><br>  while (q--) &#123;<br><br>    <span class="hljs-type">int</span> c;<br><br>    cin &gt;&gt; c;<br>  <br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) &#123;<br><br>      ll x;<br><br>      cin &gt;&gt; x;<br><br>      pq.push(x);<br><br>      sum += x;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pq.size()) &#123;<span class="hljs-comment">//判断被删完的情况就没必要加</span><br><br>      sum -= pq.top();<br><br>      pq.pop();<br><br>    &#125;<br><br>  &#125;<br><br>  cout &lt;&lt; sum &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br> ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br> cin.tie(<span class="hljs-number">0</span>);<br><br> cout.tie(<span class="hljs-number">0</span>);<br><br> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><br> while (a--) &#123;<br><br>  solve();<br><br> &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="小根堆的实现"><a href="#小根堆的实现" class="headerlink" title="小根堆的实现"></a>小根堆的实现</h3><h4 id="小根堆就是最上面是最小值"><a href="#小根堆就是最上面是最小值" class="headerlink" title="小根堆就是最上面是最小值"></a>小根堆就是最上面是最小值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">struct</span> cmp&#123;<br>   <span class="hljs-type">bool</span> operator()(<span class="hljs-keyword">const</span> ll&amp;u,<span class="hljs-keyword">const</span> ll &amp;v)<span class="hljs-keyword">const</span>&#123;<br>     <span class="hljs-keyword">return</span> u&lt;v;<br>   &#125;<br> &#125;;<br> priority_queue&lt;T,vector&lt;T&gt;,cmp&gt;pq;<br><br><span class="hljs-comment">//或者是这样</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2023/10/27/%E6%A0%88/"/>
    <url>/2023/10/27/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="首先是先进后出的数据结构"><a href="#首先是先进后出的数据结构" class="headerlink" title="首先是先进后出的数据结构"></a>首先是先进后出的数据结构</h3><p><a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/Pasted%20image%2020231018220744.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/Pasted%20image%2020231018220744.png</a></p><h3 id="STL中栈的一些函数"><a href="#STL中栈的一些函数" class="headerlink" title="STL中栈的一些函数"></a>STL中栈的一些函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//元素访问</span><br>st.top()<span class="hljs-comment">//返回栈顶</span><br><br><span class="hljs-comment">//修改</span><br>st.push()<span class="hljs-comment">//传入参数到栈顶</span><br>st.pop()<span class="hljs-comment">//弹出栈顶</span><br><br><span class="hljs-comment">//容量</span><br>st.empty()<span class="hljs-comment">//返回是否为空</span><br>st.size()<span class="hljs-comment">//返回元素数量</span><br></code></pre></td></tr></table></figure><h3 id="来一道模板题"><a href="#来一道模板题" class="headerlink" title="来一道模板题"></a>来一道模板题</h3><blockquote><p>现在有n部火车，每一部火车都有一个1∼n的编号且各不相同（火车编号构成一个<br>排列）。现在他们按照给定的顺序排列在一条轨道上，且可以向两个方向移动，问他们<br>否通过一个车站，且每部火车<strong>至多进站一次</strong>，使得出站口的编号顺序变为升序？<br>车站是一个栈结构，位于输入队列的轨道中间，构成一个T字形，初始时火车都在车站<br>右侧。<br>如果可以输出”Yes”，如果不行输出”No”。（不带引号）</p></blockquote><h4 id="分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈"><a href="#分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈" class="headerlink" title="分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈"></a>分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//输入案例</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3 1 2</span><br><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//Yes</span><br>#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br>  <br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">9</span>;<br><br>  <br><br><span class="hljs-type">int</span> a[N], pos;<br><br>  <br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> n;<br><br>  cin &gt;&gt; n;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br><br>  <br><br>  stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br>  pos = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// i表示左边轨道所需的列车编号</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><br><span class="hljs-comment">//如果不是所需的（想要的），就一直找</span><br><br>  while (pos &lt;= n &amp;&amp; (stk.empty() || stk.top() != i)) stk.push(a[pos++]);<br><span class="hljs-comment">//就是在pos还是小于n的情况下，并且还没有进栈，并且栈的顶部是没有与i对应的，那么就进栈</span><br>  <br><br>  <span class="hljs-keyword">if</span> (stk.top() == i)<span class="hljs-comment">//如果对应就移除</span><br><br>    stk.pop();<br><br>  <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//就是整个while循环完了还是没有能出栈的，说明就是没有升序的情况</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>     <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>  &#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>  <br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br><br>  while (_--) solve();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2023/09/26/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2023/09/26/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="1，双指针的用途就是"><a href="#1，双指针的用途就是" class="headerlink" title="1，双指针的用途就是"></a>1，双指针的用途就是</h3><h4 id="a，有的是快慢指针操作"><a href="#a，有的是快慢指针操作" class="headerlink" title="a，有的是快慢指针操作"></a>a，有的是快慢指针操作</h4><h4 id="b，可以用来维护一段区间"><a href="#b，可以用来维护一段区间" class="headerlink" title="b，可以用来维护一段区间"></a>b，可以用来维护一段区间</h4><h3 id="2，双指针感觉没有模板，比较灵活"><a href="#2，双指针感觉没有模板，比较灵活" class="headerlink" title="2，双指针感觉没有模板，比较灵活"></a>2，双指针感觉没有模板，比较灵活</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//这个题就是找出最小不重复区间</span><br>#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N], tmp[N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) &#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>memset(tmp, <span class="hljs-number">0</span>, sizeof(<span class="hljs-type">int</span>) * (n + <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cin &gt;&gt; a[i];<br><br>&#125;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//双指针，</span><br><br>while (j &lt; n &amp;&amp; !tmp[a[j + <span class="hljs-number">1</span>]]) &#123; <span class="hljs-comment">//前一个不重复</span><br><br>tmp[a[++j]]++; <span class="hljs-comment">//把前面的加起来</span><br><br>&#125;<br><br>ans = max(ans, j - i + <span class="hljs-number">1</span>ll); <span class="hljs-comment">//说明重复了</span><br><br>tmp[a[i]]--;<br><br>&#125;<br><br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算(最好提前看一下逻辑运算符)</title>
    <link href="/2023/09/24/%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%9C%80%E5%A5%BD%E6%8F%90%E5%89%8D%E7%9C%8B%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/09/24/%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%9C%80%E5%A5%BD%E6%8F%90%E5%89%8D%E7%9C%8B%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><h4 id="a，可以用来考试"><a href="#a，可以用来考试" class="headerlink" title="a，可以用来考试"></a>a，可以用来考试</h4><h4 id="b，线性基（异或）（数论）"><a href="#b，线性基（异或）（数论）" class="headerlink" title="b，线性基（异或）（数论）"></a>b，线性基（异或）（数论）</h4><h4 id="c，0，1串"><a href="#c，0，1串" class="headerlink" title="c，0，1串"></a>c，0，1串</h4><h4 id="d，计数"><a href="#d，计数" class="headerlink" title="d，计数"></a>d，计数</h4><h4 id="e，集，或者状态"><a href="#e，集，或者状态" class="headerlink" title="e，集，或者状态"></a>e，集，或者状态</h4><h3 id="一，与运算（-）"><a href="#一，与运算（-）" class="headerlink" title="一，与运算（&amp;）"></a>一，与运算（&amp;）</h3><h4 id="3-10-011-2"><a href="#3-10-011-2" class="headerlink" title="$$(3)_{10} &#x3D;(011)_2$$"></a>$$(3)_{10} &#x3D;(011)_2$$</h4><h4 id="6-10-110-2"><a href="#6-10-110-2" class="headerlink" title="$$(6)_{10}&#x3D;(110)_2$$"></a>$$(6)_{10}&#x3D;(110)_2$$</h4><h4 id="如果二者取与运算-那么就是-010-2"><a href="#如果二者取与运算-那么就是-010-2" class="headerlink" title="如果二者取与运算(&amp;)那么就是$$(010)_2$$"></a>如果二者取与运算(&amp;)那么就是$$(010)_2$$</h4><h4 id="就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0"><a href="#就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0" class="headerlink" title="就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0"></a>就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0</h4><h4 id="或运算（-）"><a href="#或运算（-）" class="headerlink" title="或运算（|）"></a>或运算（|）</h4><h4 id="3-10-011-2-1"><a href="#3-10-011-2-1" class="headerlink" title="$$(3)_{10} &#x3D;(011)_2$$"></a>$$(3)_{10} &#x3D;(011)_2$$</h4><h4 id="6-10-110-2-1"><a href="#6-10-110-2-1" class="headerlink" title="$$(6)_{10}&#x3D;(110)_2$$"></a>$$(6)_{10}&#x3D;(110)_2$$</h4><h4 id="如果二者取或运算-那么就是-111-2"><a href="#如果二者取或运算-那么就是-111-2" class="headerlink" title="如果二者取或运算(|)那么就是$$(111)_2$$"></a>如果二者取或运算(|)那么就是$$(111)_2$$</h4><h4 id="我们可以看出或运算只要两个不是0，那都是1"><a href="#我们可以看出或运算只要两个不是0，那都是1" class="headerlink" title="我们可以看出或运算只要两个不是0，那都是1"></a>我们可以看出或运算只要两个不是0，那都是1</h4><h3 id="二，异或运算"><a href="#二，异或运算" class="headerlink" title="二，异或运算(^)"></a>二，异或运算(^)</h3><h4 id="3-10-011-2-2"><a href="#3-10-011-2-2" class="headerlink" title="$$(3)_{10} &#x3D;(011)_2$$"></a>$$(3)_{10} &#x3D;(011)_2$$</h4><h4 id="6-10-110-2-2"><a href="#6-10-110-2-2" class="headerlink" title="$$(6)_{10}&#x3D;(110)_2$$"></a>$$(6)_{10}&#x3D;(110)_2$$</h4><h4 id="如果二者取异或运算-那么就是-101-2"><a href="#如果二者取异或运算-那么就是-101-2" class="headerlink" title="如果二者取异或运算(^)那么就是$$(101)_2$$"></a>如果二者取异或运算(^)那么就是$$(101)_2$$</h4><h4 id="我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0"><a href="#我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0" class="headerlink" title="我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0"></a>我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0</h4><h3 id="三，取反运算"><a href="#三，取反运算" class="headerlink" title="三，取反运算(~)"></a>三，取反运算(~)</h3><h4 id="3-10-011-2-3"><a href="#3-10-011-2-3" class="headerlink" title="$$(3)_{10}&#x3D;(011)_2$$"></a>$$(3)_{10}&#x3D;(011)_2$$</h4><h4 id="取反后就是-100-2-4"><a href="#取反后就是-100-2-4" class="headerlink" title="$$取反后就是(100)_2&#x3D;4$$"></a>$$取反后就是(100)_2&#x3D;4$$</h4><h4 id="取反运算还有一个特殊的值，就是a-1"><a href="#取反运算还有一个特殊的值，就是a-1" class="headerlink" title="取反运算还有一个特殊的值，就是a&#x3D;-1;"></a>取反运算还有一个特殊的值，就是a&#x3D;-1;</h4><h4 id="a的二进制数是-11111111…-2"><a href="#a的二进制数是-11111111…-2" class="headerlink" title="$$a的二进制数是(11111111…)_2$$"></a>$$a的二进制数是(11111111…)_2$$</h4><h4 id="如果取反的话就是变成-0000…-2"><a href="#如果取反的话就是变成-0000…-2" class="headerlink" title="$$如果取反的话就是变成(0000…)_2$$"></a>$$如果取反的话就是变成(0000…)_2$$</h4><h3 id="四，移位运算"><a href="#四，移位运算" class="headerlink" title="四，移位运算"></a>四，移位运算</h3><h4 id="1，"><a href="#1，" class="headerlink" title="1，&lt;&lt;(左移运算符)"></a>1，&lt;&lt;(左移运算符)</h4><h4 id="3-0000011-2"><a href="#3-0000011-2" class="headerlink" title="$$3&#x3D;(0000011)_2$$"></a>$$3&#x3D;(0000011)_2$$</h4><h4 id=""><a href="#" class="headerlink" title="&lt;&lt;1左移一位$$(0000110)_2这是高位溢出用人话讲就是去掉高位$$"></a>&lt;&lt;1左移一位$$(0000110)_2这是高位溢出用人话讲就是去掉高位$$</h4><h4 id="2，右移运算符"><a href="#2，右移运算符" class="headerlink" title="2，右移运算符(&gt;&gt;)"></a>2，右移运算符(&gt;&gt;)</h4><h4 id="1的情况就是-0000001-2"><a href="#1的情况就是-0000001-2" class="headerlink" title="$$&gt;&gt;1的情况就是(0000001)_2$$"></a>$$&gt;&gt;1的情况就是(0000001)_2$$</h4><h3 id="五，异或运算的公式"><a href="#五，异或运算的公式" class="headerlink" title="五，异或运算的公式"></a>五，异或运算的公式</h3><h4 id="a-oplus-b-b-oplus-a-交换律"><a href="#a-oplus-b-b-oplus-a-交换律" class="headerlink" title="$$a \oplus b&#x3D;b \oplus a(交换律)$$"></a>$$a \oplus b&#x3D;b \oplus a(交换律)$$</h4><h4 id="a-oplus-b-oplus-c-a-oplus-b-oplus-c-结合律"><a href="#a-oplus-b-oplus-c-a-oplus-b-oplus-c-结合律" class="headerlink" title="$$(a\oplus b)\oplus c &#x3D; a\oplus(b\oplus c)(结合律)$$"></a>$$(a\oplus b)\oplus c &#x3D; a\oplus(b\oplus c)(结合律)$$</h4><h4 id="a-oplus0-a"><a href="#a-oplus0-a" class="headerlink" title="$$a\oplus0 &#x3D; a$$"></a>$$a\oplus0 &#x3D; a$$</h4><h4 id="a-oplus-a-0"><a href="#a-oplus-a-0" class="headerlink" title="$$a\oplus a &#x3D; 0$$"></a>$$a\oplus a &#x3D; 0$$</h4><h4 id="a-b-2-a-b-a-oplus-b-就有a-b-a-oplus-b"><a href="#a-b-2-a-b-a-oplus-b-就有a-b-a-oplus-b" class="headerlink" title="a+b &#x3D; 2(a&amp;b)+a$\oplus$b 就有a+b&gt;&#x3D;a$\oplus$b"></a>a+b &#x3D; 2(a&amp;b)+a$\oplus$b 就有a+b&gt;&#x3D;a$\oplus$b</h4><h3 id="例题求二进制中1的个数"><a href="#例题求二进制中1的个数" class="headerlink" title="例题求二进制中1的个数"></a>例题求二进制中1的个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>  <br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>while (n--) &#123;<br><br>ll cnt = <span class="hljs-number">0</span>;<br><br>ll a = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; a;<br><br>while (a) &#123;<span class="hljs-comment">//判断的主体部分</span><br><br><span class="hljs-keyword">if</span> (a &amp; <span class="hljs-number">1</span>) cnt++;<span class="hljs-comment">//看最后一位的是否是1</span><br><br>a &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//判断完就右移去掉</span><br><br>&#125;<br><br>cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我们需要0"><a href="#我们需要0" class="headerlink" title="我们需要0"></a>我们需要0</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">题干：给定一个大小为n的非负整数数组a。  <br>  <br>你可以选定一个非负整数<span class="hljs-keyword">x</span>，并令bi​<span class="hljs-operator">=</span>ai​⊕<span class="hljs-keyword">x</span>，其中<span class="hljs-number">1</span>≤i≤n，请问是否存在<span class="hljs-keyword">x</span>，使得b<span class="hljs-number">1</span>​⊕b<span class="hljs-number">2</span>​⊕⋅⋅⋅⊕bn​<span class="hljs-operator">=</span><span class="hljs-number">0</span>？<br></code></pre></td></tr></table></figure><h4 id="思路分析：要用到两个公式-a-bigoplus-a-0-a-bigoplus-0-a-我们可以将bi写成ai和x的表达式-a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-bigoplus-x-bigoplus-x-0"><a href="#思路分析：要用到两个公式-a-bigoplus-a-0-a-bigoplus-0-a-我们可以将bi写成ai和x的表达式-a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-bigoplus-x-bigoplus-x-0" class="headerlink" title="思路分析：要用到两个公式$a\bigoplus a&#x3D;0$      $a\bigoplus 0 &#x3D;a$我们可以将bi写成ai和x的表达式$$a_1\bigoplus a_2\bigoplus a_3 \bigoplus x\bigoplus x\bigoplus x &#x3D; 0$$"></a>思路分析：要用到两个公式$a\bigoplus a&#x3D;0$      $a\bigoplus 0 &#x3D;a$我们可以将bi写成ai和x的表达式$$a_1\bigoplus a_2\bigoplus a_3 \bigoplus x\bigoplus x\bigoplus x &#x3D; 0$$</h4><h4 id="x可以删去-a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-0"><a href="#x可以删去-a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-0" class="headerlink" title="x可以删去$$a_1\bigoplus a_2\bigoplus a_3\bigoplus x &#x3D; 0$$"></a>x可以删去$$a_1\bigoplus a_2\bigoplus a_3\bigoplus x &#x3D; 0$$</h4><h4 id="然后两边都是处理-bigoplus-x-就会有以下的式子-a-1-bigoplus-a-2-bigoplus-a-3-x"><a href="#然后两边都是处理-bigoplus-x-就会有以下的式子-a-1-bigoplus-a-2-bigoplus-a-3-x" class="headerlink" title="然后两边都是处理$\bigoplus x$就会有以下的式子$$a_1\bigoplus a_2\bigoplus a_3 &#x3D; x$$"></a>然后两边都是处理$\bigoplus x$就会有以下的式子$$a_1\bigoplus a_2\bigoplus a_3 &#x3D; x$$</h4><h4 id="以下就是代码"><a href="#以下就是代码" class="headerlink" title="以下就是代码"></a>以下就是代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) &#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; a;<br><br>ans ^= a;<br><br>&#125;<br><br><span class="hljs-keyword">if</span> (ans)<br><br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-keyword">else</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和和差分</title>
    <link href="/2023/09/18/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/"/>
    <url>/2023/09/18/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-对于格式化输入输出"><a href="#1-对于格式化输入输出" class="headerlink" title="1,对于格式化输入输出"></a>1,对于格式化输入输出</h3><p>1，取消同步流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>2，不要写</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cout&lt;&lt;endl<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>写</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">cout</span>&lt;&lt;<span class="hljs-string">&#x27;<span class="hljs-char escape_">\n</span>&#x27;</span>;<br></code></pre></td></tr></table></figure><p>3，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例</span><br><span class="hljs-type">define</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-comment">//尽量不要用define</span><br><span class="hljs-comment">//替换</span><br><span class="hljs-type">using</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure><h3 id="2-一维前缀和"><a href="#2-一维前缀和" class="headerlink" title="2,一维前缀和"></a>2,一维前缀和</h3><h4 id="a，前缀和的好处是将优化了暴力的时间复杂度"><a href="#a，前缀和的好处是将优化了暴力的时间复杂度" class="headerlink" title="a，前缀和的好处是将优化了暴力的时间复杂度"></a>a，前缀和的好处是将优化了暴力的时间复杂度</h4><h4 id="b-这是prefix的公式-p-i-sum-j-1-ia-j-p-i-1-a-i"><a href="#b-这是prefix的公式-p-i-sum-j-1-ia-j-p-i-1-a-i" class="headerlink" title="b,这是prefix的公式$$p_i&#x3D;\sum_{j&#x3D;1}^ia_j&#x3D;p_{i-1}+a_i$$"></a>b,这是prefix的公式<p>$$p_i&#x3D;\sum_{j&#x3D;1}^ia_j&#x3D;p_{i-1}+a_i$$</p></h4><h4 id="c，然后一般是需要求区间和，所以有以下公式-ans-p-r-p-l-1"><a href="#c，然后一般是需要求区间和，所以有以下公式-ans-p-r-p-l-1" class="headerlink" title="c，然后一般是需要求区间和，所以有以下公式$$ans&#x3D;p_r-p_{l-1}$$"></a>c，然后一般是需要求区间和，所以有以下公式$$ans&#x3D;p_r-p_{l-1}$$</h4><h4 id="这是比较容易理解的"><a href="#这是比较容易理解的" class="headerlink" title="这是比较容易理解的"></a>这是比较容易理解的</h4><h4 id="d，代码"><a href="#d，代码" class="headerlink" title="d，代码"></a>d，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>using ll = long long;<br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br>ll a[N], prefix[N];<br><span class="hljs-type">int</span> main() &#123;<br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] + a[i];<br>&#125;<br><span class="hljs-type">int</span> q;<br><br>cin &gt;&gt; q;<br><br>while (q--) &#123;<br><span class="hljs-type">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>cout &lt;&lt;prefix[r] - prefix[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-一维差分"><a href="#3-一维差分" class="headerlink" title="3,一维差分"></a>3,一维差分</h3><h4 id="a-用途-一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。"><a href="#a-用途-一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。" class="headerlink" title="a,用途:一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。"></a>a,用途:一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。</h4><h4 id="b-差分：可以简单的看成序列中每个元素与其前一个元素的差。"><a href="#b-差分：可以简单的看成序列中每个元素与其前一个元素的差。" class="headerlink" title="b,差分：可以简单的看成序列中每个元素与其前一个元素的差。"></a>b,差分：可以简单的看成序列中每个元素与其前一个元素的差。</h4><h4 id="c-差分的公式-d-i-a-i-a-i-1"><a href="#c-差分的公式-d-i-a-i-a-i-1" class="headerlink" title="c:差分的公式:$$d_i&#x3D;a_i-a_{i-1}$$"></a>c:差分的公式:$$d_i&#x3D;a_i-a_{i-1}$$</h4><h4 id="解释为什么是这样-sum-j-1-id-j-d-1-d-2-d-3-…-a-1-a-0-a-2-a-1-…-a-i"><a href="#解释为什么是这样-sum-j-1-id-j-d-1-d-2-d-3-…-a-1-a-0-a-2-a-1-…-a-i" class="headerlink" title="解释为什么是这样$$\sum_{j&#x3D;1}^id_j&#x3D; d_1+d_2+d_3+…&#x3D;(a_1-a_0)+(a_2-a_1)+…&#x3D;a_i$$"></a>解释为什么是这样$$\sum_{j&#x3D;1}^id_j&#x3D; d_1+d_2+d_3+…&#x3D;(a_1-a_0)+(a_2-a_1)+…&#x3D;a_i$$</h4><h4 id="d-解释为什么用差分来修改数字-a-1-d-1-a-2-d-1-d-2-a-3-d-1-d-2-d-3"><a href="#d-解释为什么用差分来修改数字-a-1-d-1-a-2-d-1-d-2-a-3-d-1-d-2-d-3" class="headerlink" title="d,解释为什么用差分来修改数字$$a_1&#x3D;d_1  a_2&#x3D;d_1+d_2  a_3&#x3D;d_1+d_2+d_3$$"></a>d,解释为什么用差分来修改数字$$a_1&#x3D;d_1  a_2&#x3D;d_1+d_2  a_3&#x3D;d_1+d_2+d_3$$</h4><h4 id="如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。"><a href="#如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。" class="headerlink" title="如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。"></a>如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。</h4><h4 id="e-如何对a的一个区间进行修改-在-l-r-的区间增加x-所以在l处d-l-d-l-x-在r-1处d-r-1-d-r-1-x"><a href="#e-如何对a的一个区间进行修改-在-l-r-的区间增加x-所以在l处d-l-d-l-x-在r-1处d-r-1-d-r-1-x" class="headerlink" title="e,如何对a的一个区间进行修改$$在[l,r]的区间增加x\所以在l处d_l&#x3D;d_l+x,\在r+1处d_{r+1}&#x3D;d_{r+1}-x$$"></a>e,如何对a的一个区间进行修改$$在[l,r]的区间增加x\所以在l处d_l&#x3D;d_l+x,\在r+1处d_{r+1}&#x3D;d_{r+1}-x$$</h4><h4 id="f-重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改"><a href="#f-重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改" class="headerlink" title="f,重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改"></a>f,重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改</h4><h4 id="f，代码"><a href="#f，代码" class="headerlink" title="f，代码"></a>f，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll diff[N], a[N], prefix[N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cin &gt;&gt; a[i];<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>diff[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br><br>&#125;<br><br><span class="hljs-type">int</span> q;<br><br>cin &gt;&gt; q;<br><br>while (q--) &#123;<br><br><span class="hljs-type">int</span> l, r, v;<br><br>cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;<br><br>diff[l] += v;<br><br>diff[r + <span class="hljs-number">1</span>] -= v;<br><br>&#125;<br><br><span class="hljs-type">int</span> m;<br><br>cin &gt;&gt; m;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = a[i - <span class="hljs-number">1</span>] + diff[i];<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) prefix[i] = prefix[i - <span class="hljs-number">1</span>] + a[i];<br><br>while (m--) &#123;<br><br><span class="hljs-type">int</span> l, r;<br><br>cin &gt;&gt; l &gt;&gt; r;<br><br>cout &lt;&lt; prefix[r] - prefix[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-二维前缀和"><a href="#4-二维前缀和" class="headerlink" title="4,二维前缀和"></a>4,二维前缀和</h3><h4 id="a-https-download-tooc-xlj0-com-uploads-179-Pasted-20image-2020230918095226-png-在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式-prefix-ij-p-i-j-1-p-i-1-j-p-i-1-j-1-a-i-j"><a href="#a-https-download-tooc-xlj0-com-uploads-179-Pasted-20image-2020230918095226-png-在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式-prefix-ij-p-i-j-1-p-i-1-j-p-i-1-j-1-a-i-j" class="headerlink" title="a, https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png 在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式$$prefix_{ij}&#x3D;p[i][j-1]+p[i-1][j]-p[i-1][j-1]+a[i][j]$$"></a>a, <a href="https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png">https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png</a> 在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式$$prefix_{ij}&#x3D;p[i][j-1]+p[i-1][j]-p[i-1][j-1]+a[i][j]$$</h4><h4 id="b，求区间和：如果求的是区间和那么就是如图片所示-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BA-8C-E7-BB-B4-E5-89-8D-E7-BC-80-E5-92-8C-png"><a href="#b，求区间和：如果求的是区间和那么就是如图片所示-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BA-8C-E7-BB-B4-E5-89-8D-E7-BC-80-E5-92-8C-png" class="headerlink" title="b，求区间和：如果求的是区间和那么就是如图片所示 https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png"></a>b，求区间和：如果求的是区间和那么就是如图片所示 <a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png</a></h4><h4 id="可以看到有三部分，红色的点是被删了两次，所以需要加回去-所以公式如下-求x1-y1-x2-y2这个区域的和-ans-prefix-x2-y2-prefix-x2-y1-1-prefix-x1-1-y2-prefix-x1-1-x1-1"><a href="#可以看到有三部分，红色的点是被删了两次，所以需要加回去-所以公式如下-求x1-y1-x2-y2这个区域的和-ans-prefix-x2-y2-prefix-x2-y1-1-prefix-x1-1-y2-prefix-x1-1-x1-1" class="headerlink" title="可以看到有三部分，红色的点是被删了两次，所以需要加回去,所以公式如下$$求x1,y1,x2,y2这个区域的和\ans&#x3D;prefix[x2][y2]-prefix[x2][y1-1]-prefix[x1-1][y2]+prefix[x1-1][x1-1]$$"></a>可以看到有三部分，红色的点是被删了两次，所以需要加回去,所以公式如下$$求x1,y1,x2,y2这个区域的和\ans&#x3D;prefix[x2][y2]-prefix[x2][y1-1]-prefix[x1-1][y2]+prefix[x1-1][x1-1]$$</h4><h3 id="d-代码实现"><a href="#d-代码实现" class="headerlink" title="d,代码实现"></a>d,代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll prefix[N][N], a[N][N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n, m, q;<br><br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><br>cin &gt;&gt; a[i][j];<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><br>prefix[i][j] =<br><br>prefix[i - <span class="hljs-number">1</span>][j] + prefix[i][j - <span class="hljs-number">1</span>] - prefix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br><br>&#125;<br><br>&#125;<br><br>while (q--) &#123;<br><br><span class="hljs-type">int</span> x1, y1, x2, y2;<br><br>cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br><br>cout &lt;&lt; prefix[x2][y2] - prefix[x1 - <span class="hljs-number">1</span>][y2] - prefix[x2][y1 - <span class="hljs-number">1</span>] +<br><br>prefix[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]<br><br>&lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5，二维差分"><a href="#5，二维差分" class="headerlink" title="5，二维差分"></a>5，二维差分</h3><h4 id="a-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-09-18-20110945-png-可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以-x1-y1-、-x2-y2-分别表示一个子矩阵的左上角和右下角的坐标，-每个操作将对应的子矩阵的每个元素加上c。-diff-x1-y1-c-diff-x2-1-x1-c-diff-x1-y2-1-c-diff-x2-1-y2-1-c"><a href="#a-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-09-18-20110945-png-可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以-x1-y1-、-x2-y2-分别表示一个子矩阵的左上角和右下角的坐标，-每个操作将对应的子矩阵的每个元素加上c。-diff-x1-y1-c-diff-x2-1-x1-c-diff-x1-y2-1-c-diff-x2-1-y2-1-c" class="headerlink" title="a, https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png 可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以$$(x1,y1)、(x2,y2)分别表示一个子矩阵的左上角和右下角的坐标，\每个操作将对应的子矩阵的每个元素加上c。$$diff[x1][y1]+&#x3D;c\diff[x2+1][x1]-&#x3D;c\diff[x1][y2+1]-&#x3D;c\diff[x2+1][y2+1]+&#x3D;c$$"></a>a, <a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png</a> 可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以$$(x1,y1)、(x2,y2)分别表示一个子矩阵的左上角和右下角的坐标，\每个操作将对应的子矩阵的每个元素加上c。$$diff[x1][y1]+&#x3D;c\diff[x2+1][x1]-&#x3D;c\diff[x1][y2+1]-&#x3D;c\diff[x2+1][y2+1]+&#x3D;c$$</h4><h4 id="b-先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1-x2-y1-y2换成i和j。"><a href="#b-先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1-x2-y1-y2换成i和j。" class="headerlink" title="b,先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1,x2,y1,y2换成i和j。"></a>b,先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1,x2,y1,y2换成i和j。</h4><h4 id="c，然后处理后在返回去就行，接着就是前缀和的处理"><a href="#c，然后处理后在返回去就行，接着就是前缀和的处理" class="headerlink" title="c，然后处理后在返回去就行，接着就是前缀和的处理"></a>c，然后处理后在返回去就行，接着就是前缀和的处理</h4><h4 id="d，代码-1"><a href="#d，代码-1" class="headerlink" title="d，代码"></a>d，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll a[N][N], d[N][N], p[N][N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n, m, q;<br><br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><br>cin &gt;&gt; a[i][j];<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><br>d[i][j] += a[i][j];<br><br>d[i + <span class="hljs-number">1</span>][j] -= a[i][j];<br><br>d[i][j + <span class="hljs-number">1</span>] -= a[i][j];<br><br>d[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += a[i][j];<br><br>&#125;<br><br>&#125;<br><br>while (q--) &#123;<br><br><span class="hljs-type">int</span> x1, y1, x2, y2, v;<br><br>cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; v;<br><br>d[x1][y1] += v;<br><br>d[x2 + <span class="hljs-number">1</span>][y1] -= v;<br><br>d[x1][y2 + <span class="hljs-number">1</span>] -= v;<br><br>d[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += v;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br><br>a[i][j] = a[i - <span class="hljs-number">1</span>][j] + a[i][j - <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + d[i][j];<br><br>cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6，前缀和例题鼠鼠我鸭"><a href="#6，前缀和例题鼠鼠我鸭" class="headerlink" title="6，前缀和例题鼠鼠我鸭"></a>6，前缀和例题鼠鼠我鸭</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">在一个叫做酱西功爷枝叶鸡树学院的地方有<span class="hljs-built_in">n</span>只小动物，要么是鼠鼠，要么是鸭鸭，从<span class="hljs-number">1</span>到<span class="hljs-built_in">n</span>编号，每只小动物有个体重ai​。<br><br>在这个学校里，存在一种神奇的魔法，可以将编号位于某个区间[l,r]内的所有鼠鼠都变为鸭鸭，鸭鸭都变为鼠鼠（魔法并不会改变体重）。<br><br>现在你可以施放这个魔法至多<span class="hljs-number">1</span>次。（也可以不施放）<br><br>问最终鸭鸭的总重量最多是多少？<br><br>//输入格式<br><br>第一行一个整数<span class="hljs-built_in">T</span>表示样例个数。(<span class="hljs-number">1</span>≤<span class="hljs-built_in">T</span>≤<span class="hljs-number">10</span>)<br><br>对于每个样例：<br><br>第一行一个整数<span class="hljs-built_in">n</span>表示小动物的个数。(<span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">1</span>e5)<br><br>第二行<span class="hljs-built_in">n</span>个整数，表示第i个小动物的类型。<span class="hljs-number">0</span>表示鼠鼠，<span class="hljs-number">1</span>表示鸭鸭。<br><br>第三行<span class="hljs-built_in">n</span>个整数，表示第i个小动物的体重ai​。(<span class="hljs-number">1</span>≤ai​≤<span class="hljs-number">1</span>e9)<br>### 样例输入<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br>### 样例输出<span class="hljs-number">1</span><br><span class="hljs-number">6</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h4 id="a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，-prefix-r-prefix-l-1-所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下"><a href="#a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，-prefix-r-prefix-l-1-所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下" class="headerlink" title="a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，$prefix[r]-prefix[l-1]$所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下"></a>a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，$prefix[r]-prefix[l-1]$所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll a[N], prefix[N], v[N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) &#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//存贮小鸭和鼠</span><br><br>cin &gt;&gt; a[i];<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cin &gt;&gt; v[i];<br><br>&#125;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans += v[i] * a[i];<span class="hljs-comment">//把鸭全部加上</span><br><br>ll mi = <span class="hljs-number">0</span>, fix = <span class="hljs-number">0</span>;<span class="hljs-comment">//fix代标校准</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>)<span class="hljs-comment">//说明是鼠可以用魔法变成鸭</span><br><br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] + v[i];<br><br><span class="hljs-keyword">else</span><br><br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] - v[i];<br><br>fix = max(fix, prefix[i] - mi);<span class="hljs-comment">//prefix[r]-prefix[l-1]</span><br><br>mi = min(mi, prefix[i]);<span class="hljs-comment">//找到最小的prefix[l-1];</span><br><br>&#125;<br><br>cout &lt;&lt; ans + fix &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//将偏差值加起来就行</span><br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
