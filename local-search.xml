<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GNN</title>
    <link href="/2024/04/16/GNN/"/>
    <url>/2024/04/16/GNN/</url>
    
    <content type="html"><![CDATA[<h4 id="参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub"><a href="#参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub" class="headerlink" title="参考：A Gentle Introduction to Graph Neural Networks (distill.pub)"></a>参考：<a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a></h4><h4 id="零基础多图详解图神经网络（GNN-GCN）-youtube-com"><a href="#零基础多图详解图神经网络（GNN-GCN）-youtube-com" class="headerlink" title="零基础多图详解图神经网络（GNN/GCN） (youtube.com)"></a><a href="https://www.youtube.com/watch?v=sejA2PtCITw&amp;t=770s">零基础多图详解图神经网络（GNN/GCN） (youtube.com)</a></h4><h4 id="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"><a href="#总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。" class="headerlink" title="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"></a>总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。</h4><h4 id="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"><a href="#对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。" class="headerlink" title="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"></a>对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。</h4><h3 id="图的预测问题"><a href="#图的预测问题" class="headerlink" title="图的预测问题"></a>图的预测问题</h3><h4 id="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"><a href="#图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。" class="headerlink" title="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"></a>图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。</h4><h4 id="图的任务："><a href="#图的任务：" class="headerlink" title="图的任务："></a>图的任务：</h4><h5 id="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"><a href="#举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。" class="headerlink" title="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"></a>举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。</h5><h4 id="节点的任务："><a href="#节点的任务：" class="headerlink" title="节点的任务："></a>节点的任务：</h4><h5 id="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"><a href="#节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。" class="headerlink" title="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"></a>节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。</h5><h4 id="边的任务："><a href="#边的任务：" class="headerlink" title="边的任务："></a>边的任务：</h4><h5 id="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"><a href="#边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。" class="headerlink" title="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"></a>边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。</h5><h3 id="在机器学习中使用图的挑战"><a href="#在机器学习中使用图的挑战" class="headerlink" title="在机器学习中使用图的挑战"></a>在机器学习中使用图的挑战</h3><h4 id="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"><a href="#首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。" class="headerlink" title="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"></a>首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。</h4><h4 id="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"><a href="#比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。" class="headerlink" title="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"></a>比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。</h4><h4 id="我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。"><a href="#我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。" class="headerlink" title="我们可以用邻接表来解决问题，图中每个节点/边/全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。"></a>我们可以用邻接表来解决问题，图中每个节点/边/全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。</h4><h3 id="什么是GNN"><a href="#什么是GNN" class="headerlink" title="什么是GNN"></a>什么是GNN</h3><h4 id="GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"><a href="#GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。" class="headerlink" title="GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"></a>GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。</h4><h4 id="最简单的GNN"><a href="#最简单的GNN" class="headerlink" title="最简单的GNN"></a>最简单的GNN</h4><h5 id="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"><a href="#为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。" class="headerlink" title="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"></a>为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。</h5><h5 id="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"><a href="#就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。" class="headerlink" title="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"></a>就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。</h5><h4 id="通过Pooling信息进行-GNN-预测"><a href="#通过Pooling信息进行-GNN-预测" class="headerlink" title="通过Pooling信息进行 GNN 预测"></a>通过Pooling信息进行 GNN 预测</h4><h5 id="我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了—对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"><a href="#我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了—对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。" class="headerlink" title="我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了—对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"></a>我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了—对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。</h5><h5 id="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"><a href="#图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总" class="headerlink" title="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"></a>图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总</h5><h5 id="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"><a href="#因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。" class="headerlink" title="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"></a>因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。</h5><h5 id="在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"><a href="#在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。" class="headerlink" title="在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"></a>在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。</h5><h5 id="现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"><a href="#现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。" class="headerlink" title="现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"></a>现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。</h5><h4 id="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"><a href="#这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。" class="headerlink" title="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"></a>这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。</h4><h3 id="在图的不同部分之间传递信息"><a href="#在图的不同部分之间传递信息" class="headerlink" title="在图的不同部分之间传递信息"></a>在图的不同部分之间传递信息</h3><h4 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h4><blockquote><p>首先对于图中的每个节点，收集所有相邻节点的嵌入（或信息）。<br>通过聚合函数（如 sum）汇总所有信息。<br>所有汇集的信息将通过一个更新函数（通常是一个学习的神经网络）进行传递。<br>中间的transgorm information可以看出一个f</p></blockquote><h4 id="这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"><a href="#这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。" class="headerlink" title="这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"></a>这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。</h4><h4 id="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"><a href="#但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。" class="headerlink" title="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"></a>但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。</h4><h3 id="学习边缘表征"><a href="#学习边缘表征" class="headerlink" title="学习边缘表征"></a>学习边缘表征</h3><h4 id="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"><a href="#我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。" class="headerlink" title="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"></a>我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。</h4><h4 id="我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"><a href="#我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。" class="headerlink" title="我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"></a>我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。</h4><h4 id="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"><a href="#就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。" class="headerlink" title="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"></a>就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。</h4><h4 id="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"><a href="#还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。" class="headerlink" title="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"></a>还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。</h4><h4 id="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"><a href="#就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。" class="headerlink" title="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"></a>就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。</h4><h3 id="添加全局表示"><a href="#添加全局表示" class="headerlink" title="添加全局表示"></a>添加全局表示</h3><h4 id="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。"><a href="#迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。" class="headerlink" title="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。"></a>迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。</h4><h4 id="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"><a href="#解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。" class="headerlink" title="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"></a>解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。</h4><h4 id="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"><a href="#在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。" class="headerlink" title="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"></a>在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。</h4><h4 id="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"><a href="#就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。" class="headerlink" title="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"></a>就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。</h4><h4 id="A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"><a href="#A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好" class="headerlink" title="A Gentle Introduction to Graph Neural Networks (distill.pub)在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"></a><a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a>在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好</h4><h4 id="GNN-中的采样图和批处理"><a href="#GNN-中的采样图和批处理" class="headerlink" title="GNN 中的采样图和批处理"></a>GNN 中的采样图和批处理</h4><h5 id="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。"><a href="#训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。" class="headerlink" title="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。"></a>训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。</h5><h5 id="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"><a href="#就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。" class="headerlink" title="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"></a>就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。</h5><h3 id="归纳偏差"><a href="#归纳偏差" class="headerlink" title="归纳偏差"></a>归纳偏差</h3><h4 id="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"><a href="#当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。" class="headerlink" title="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"></a>当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。</h4><h4 id="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"><a href="#例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。" class="headerlink" title="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"></a>例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。</h4><h4 id="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"><a href="#就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。" class="headerlink" title="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"></a>就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。</h4><h4 id="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"><a href="#模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。" class="headerlink" title="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"></a>模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN</title>
    <link href="/2024/03/30/CNN/"/>
    <url>/2024/03/30/CNN/</url>
    
    <content type="html"><![CDATA[<p>一、常用的方向：人脸识别（主要是特征值的提取），检测任务，分类和检索，超分辨率重构（用于图片），医学任务，一些识别，无人驾驶。</p><h3 id="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"><a href="#二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。" class="headerlink" title="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28*28*1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"></a>二、与传统神经网络的区别：<a href="https://zhuanlan.zhihu.com/p/242853150">【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)</a>卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28<code>*</code>28<code>*</code>1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。</h3><h3 id="三、整体架构：分为输入层，卷积层，池化层，全连接层。"><a href="#三、整体架构：分为输入层，卷积层，池化层，全连接层。" class="headerlink" title="三、整体架构：分为输入层，卷积层，池化层，全连接层。"></a>三、整体架构：分为输入层，卷积层，池化层，全连接层。</h3><h4 id="输入层：输入数据；"><a href="#输入层：输入数据；" class="headerlink" title="输入层：输入数据；"></a>输入层：输入数据；</h4><h4 id="卷积层：使用卷积核进行特征提取和特征映射。"><a href="#卷积层：使用卷积核进行特征提取和特征映射。" class="headerlink" title="卷积层：使用卷积核进行特征提取和特征映射。"></a>卷积层：使用卷积核进行特征提取和特征映射。</h4><h4 id="池化层：进行采样降维。"><a href="#池化层：进行采样降维。" class="headerlink" title="池化层：进行采样降维。"></a>池化层：进行采样降维。</h4><h4 id="全连接层：在尾部进行拟合，减少特征信息的损失。"><a href="#全连接层：在尾部进行拟合，减少特征信息的损失。" class="headerlink" title="全连接层：在尾部进行拟合，减少特征信息的损失。"></a>全连接层：在尾部进行拟合，减少特征信息的损失。</h4><h3 id="四，卷积做了什么；"><a href="#四，卷积做了什么；" class="headerlink" title="四，卷积做了什么；"></a>四，卷积做了什么；</h3><p>![[Pasted image 20240325203433.png]]</p><h4 id="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"><a href="#从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。" class="headerlink" title="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"></a>从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。</h4><h4 id="五、卷积特征值的计算方法"><a href="#五、卷积特征值的计算方法" class="headerlink" title="五、卷积特征值的计算方法"></a>五、卷积特征值的计算方法</h4><h4 id="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png"><a href="#首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png" class="headerlink" title="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]"></a>首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]</h4><h4 id="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"><a href="#我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。" class="headerlink" title="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1=0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"></a>我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1=0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。</h4><h3 id="六，得到特征图表示"><a href="#六，得到特征图表示" class="headerlink" title="六，得到特征图表示"></a>六，得到特征图表示</h3><h4 id="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"><a href="#其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。" class="headerlink" title="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"></a>其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。</h4><h3 id="七，步长与卷积核大小对结果的影响。"><a href="#七，步长与卷积核大小对结果的影响。" class="headerlink" title="七，步长与卷积核大小对结果的影响。"></a>七，步长与卷积核大小对结果的影响。</h3><h4 id="对特征图基础上行多次卷积。"><a href="#对特征图基础上行多次卷积。" class="headerlink" title="对特征图基础上行多次卷积。"></a>对特征图基础上行多次卷积。</h4><p>![[Pasted image 20240325233943.png]]<br>![[Pasted image 20240325234007.png]]</p><h5 id="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"><a href="#我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。" class="headerlink" title="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"></a>我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。</h5><h4 id="滑动窗口步长"><a href="#滑动窗口步长" class="headerlink" title="滑动窗口步长"></a>滑动窗口步长</h4><p>![[Pasted image 20240325235101.png]]</p><h5 id="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"><a href="#对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。" class="headerlink" title="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"></a>对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。</h5><h4 id="卷积核的尺寸"><a href="#卷积核的尺寸" class="headerlink" title="卷积核的尺寸"></a>卷积核的尺寸</h4><h5 id="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"><a href="#取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。" class="headerlink" title="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"></a>取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。</h5><h4 id="边缘填充方法"><a href="#边缘填充方法" class="headerlink" title="边缘填充方法"></a>边缘填充方法</h4><p>![[Pasted image 20240326104300.png]]</p><h5 id="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。"><a href="#我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。" class="headerlink" title="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad = 1。"></a>我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad = 1。</h5><h4 id="卷积核个数"><a href="#卷积核个数" class="headerlink" title="卷积核个数"></a>卷积核个数</h4><h5 id="就是多少个特征图，就要多少个卷积核。"><a href="#就是多少个特征图，就要多少个卷积核。" class="headerlink" title="就是多少个特征图，就要多少个卷积核。"></a>就是多少个特征图，就要多少个卷积核。</h5><h3 id="八，特征图尺寸计算和参数共享"><a href="#八，特征图尺寸计算和参数共享" class="headerlink" title="八，特征图尺寸计算和参数共享"></a>八，特征图尺寸计算和参数共享</h3><h4 id="卷积结果计算公式"><a href="#卷积结果计算公式" class="headerlink" title="卷积结果计算公式"></a>卷积结果计算公式</h4><p>![[Pasted image 20240326163117.png]]</p><h4 id="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"><a href="#为什么是加2p因为一圈，左右两边都会加，所以是加2p。" class="headerlink" title="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"></a>为什么是加2p因为一圈，左右两边都会加，所以是加2p。</h4><p>![[Pasted image 20240326163842.png]]</p><h4 id="通过这张图可以看出怎么计算。"><a href="#通过这张图可以看出怎么计算。" class="headerlink" title="通过这张图可以看出怎么计算。"></a>通过这张图可以看出怎么计算。</h4><h4 id="卷积参数共享"><a href="#卷积参数共享" class="headerlink" title="卷积参数共享"></a>卷积参数共享</h4><p>![[Pasted image 20240326165236.png]]</p><h5 id="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"><a href="#就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。" class="headerlink" title="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"></a>就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。</h5><h3 id="九，池化层的作用"><a href="#九，池化层的作用" class="headerlink" title="九，池化层的作用"></a>九，池化层的作用</h3><p>![[Pasted image 20240327204655.png]]</p><h4 id="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"><a href="#可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。" class="headerlink" title="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"></a>可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。</h4><p>![[Pasted image 20240327205050.png]]</p><h3 id="十、整体网络结构"><a href="#十、整体网络结构" class="headerlink" title="十、整体网络结构"></a>十、整体网络结构</h3><p>![[Pasted image 20240327233452.png]]</p><h4 id="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"><a href="#我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。" class="headerlink" title="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"></a>我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。</h4><h4 id="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5"><a href="#RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5" class="headerlink" title="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的[10240,5]"></a>RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的<code>[10240,5]</code></h4><p>![[Pasted image 20240327235319.png]]</p><h4 id="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"><a href="#特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。" class="headerlink" title="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"></a>特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。</h4><h3 id="十一，VGN网络架构"><a href="#十一，VGN网络架构" class="headerlink" title="十一，VGN网络架构"></a>十一，VGN网络架构</h3><h4 id="Alexnet这个比较早就没什么好说的。"><a href="#Alexnet这个比较早就没什么好说的。" class="headerlink" title="Alexnet这个比较早就没什么好说的。"></a>Alexnet这个比较早就没什么好说的。</h4><h4 id="Vgg经典网络"><a href="#Vgg经典网络" class="headerlink" title="Vgg经典网络"></a>Vgg经典网络</h4><p>![[Pasted image 20240330143149.png]]</p><h5 id="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"><a href="#从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。" class="headerlink" title="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"></a>从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。</h5><h4 id="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"><a href="#然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。" class="headerlink" title="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"></a>然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。</h4><h3 id="十二、残差网络Resnet"><a href="#十二、残差网络Resnet" class="headerlink" title="十二、残差网络Resnet"></a>十二、残差网络Resnet</h3><h4 id="深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。"><a href="#深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。" class="headerlink" title="深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。"></a>深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。</h4><h4 id="解决方案：加了Resnet"><a href="#解决方案：加了Resnet" class="headerlink" title="解决方案：加了Resnet"></a>解决方案：加了Resnet</h4><p>![[Pasted image 20240330145212.png]]</p><h5 id="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"><a href="#这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。" class="headerlink" title="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"></a>这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。</h5><p>![[Pasted image 20240330145724.png]]</p><h4 id="深层的神经网络就会变成这样。"><a href="#深层的神经网络就会变成这样。" class="headerlink" title="深层的神经网络就会变成这样。"></a>深层的神经网络就会变成这样。</h4><h3 id="十三、感受野"><a href="#十三、感受野" class="headerlink" title="十三、感受野"></a>十三、感受野</h3><h4 id="一开始看感觉要一会，但是理解了。"><a href="#一开始看感觉要一会，但是理解了。" class="headerlink" title="一开始看感觉要一会，但是理解了。"></a>一开始看感觉要一会，但是理解了。</h4><h4 id="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次"><a href="#神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次" class="headerlink" title="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次."></a>神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此<strong>感受野的值可以用来大致判断每一层的抽象层次</strong>.</h4><h4 id="如何算感受野"><a href="#如何算感受野" class="headerlink" title="如何算感受野"></a>如何算感受野</h4><h5 id="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"><a href="#例子：求三个3×3的卷积层，保持步长为一，求它的感受野。" class="headerlink" title="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"></a>例子：求三个3×3的卷积层，保持步长为一，求它的感受野。</h5><h4 id="公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小"><a href="#公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小" class="headerlink" title="公式：前一层卷积核感受野 = （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小"></a>公式：<strong>前一层卷积核感受野 = （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小</strong></h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">首先是最后一层是一个，(1<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 3<br>接着计算：(3<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 5<br>然后计算:(5<span class="hljs-string">-1</span>)*1<span class="hljs-string">+3</span> = 7<br>所以感受野即为7<br></code></pre></td></tr></table></figure><h4 id="问题：为什么要堆叠三个小卷积："><a href="#问题：为什么要堆叠三个小卷积：" class="headerlink" title="问题：为什么要堆叠三个小卷积："></a>问题：为什么要堆叠三个小卷积：</h4>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分题单</title>
    <link href="/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/"/>
    <url>/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h4 id="关于二分区间的操作"><a href="#关于二分区间的操作" class="headerlink" title="关于二分区间的操作"></a>关于二分区间的操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//左闭右闭</span><br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;l;<br><br><span class="hljs-comment">//左闭右开</span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//if(nums[mid]&lt;target)</span><br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-comment">//注意check()的判断true应该是小于而不是小于等于</span><br><br><span class="hljs-comment">//左开右闭</span><br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>mid = (l+<span class="hljs-number">1</span>+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid <span class="hljs-number">-1</span>;<span class="hljs-comment">//if(nums[mid]&gt;target)</span><br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;L;<br><span class="hljs-comment">//注意对于check()的判断true应该是大于而不是大于等于</span><br></code></pre></td></tr></table></figure><h4 id="P1102-A-B数对"><a href="#P1102-A-B数对" class="headerlink" title="P1102 A-B数对"></a>P1102 A-B数对</h4><h4 id="题目要求就是找出符合A-B-C的情况。"><a href="#题目要求就是找出符合A-B-C的情况。" class="headerlink" title="题目要求就是找出符合A - B = C的情况。"></a>题目要求就是找出符合A - B = C的情况。</h4><h4 id="题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。"><a href="#题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。" class="headerlink" title="题解，我们可以知道C是已知的，所以我们可以写成A = B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。"></a>题解，我们可以知道C是已知的，所以我们可以写成A = B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。</h4><h4 id="STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。"><a href="#STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。" class="headerlink" title="STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。"></a>STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br>ll a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>ll n,c;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">sort</span>(a,a+n);<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>sum += <span class="hljs-built_in">upper_bound</span>(a,a+n,a[i]+c)-<span class="hljs-built_in">lower_bound</span>(a,a+n,a[i]+c);<br><span class="hljs-comment">//a[i]+c就是b，在元素找出符合a的值</span><br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1873-砍树"><a href="#P1873-砍树" class="headerlink" title="P1873 砍树"></a>P1873 砍树</h4><h4 id="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"><a href="#题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。" class="headerlink" title="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"></a>题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,m,l,r,trees[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;trees[i];<br>r = <span class="hljs-built_in">max</span>(r,trees[i]);<br>&#125;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-comment">//查找的右区间</span><br>ll mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>ll s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(trees[i]&gt;mid)&#123;<br>s += trees[i] - mid;<span class="hljs-comment">//将多的部分切下来</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(s&gt;=m)&#123;<span class="hljs-comment">//如果切的过多就是还要更高</span><br>l = mid;<br><br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h4><h4 id="题目的意思"><a href="#题目的意思" class="headerlink" title="题目的意思"></a>题目的意思</h4><blockquote><p>现有 m 所学校，每所学校预计分数线是 ai​。有 n 位学生，估分分别为 bi​。根据 n 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p></blockquote><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行读入两个整数 m,n。m 表示学校数，n 表示学生数。</p><p>第二行共有 m 个数，表示 m 个学校的预计录取分数。第三行有 n 个数，表示 n 个学生的估分成绩</p><h4 id="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"><a href="#题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。" class="headerlink" title="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"></a>题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。</h4><h4 id="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"><a href="#对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。" class="headerlink" title="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是[1,2,4,5]那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"></a>对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是<code>[1,2,4,5]</code>那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。</h4><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> x[N],s[N]; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;x[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;s[i];<br>&#125;<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-built_in">lower_bound</span>(x+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>+m,s[i])-x;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//在开头</span><br>sum+=<span class="hljs-built_in">abs</span>(x[a]-s[i]);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==m+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//在末尾</span><br>sum += <span class="hljs-built_in">abs</span>(x[m]-s[i]);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//中间的数</span><br>sum += <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(x[a<span class="hljs-number">-1</span>]-s[i]),<span class="hljs-built_in">abs</span>(x[a]-s[i]));<br>&#125;<br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h4><h4 id="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"><a href="#题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板" class="headerlink" title="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"></a>题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板</h4><h4 id="题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"><a href="#题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。" class="headerlink" title="题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"></a>题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。</h4><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll n,k,a[N];<br>ll l,r = <span class="hljs-number">1e8</span>+<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ans += a[i]/x;<br>&#125;<br><span class="hljs-keyword">return</span> ans&gt;=k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>ll mid = (l+r+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid))&#123;<br>l = mid;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>r = mid <span class="hljs-number">-1</span> ;<br>&#125;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h4><h4 id="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、"><a href="#题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、" class="headerlink" title="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、"></a>题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、</h4><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><h5 id="第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0-lt-Di​-lt-L-，-表示第-i-块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置"><a href="#第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0-lt-Di​-lt-L-，-表示第-i-块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置" class="headerlink" title="第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置"></a>第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置</h5><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以-lt-至多移走的岩石数。"><a href="#题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以-lt-至多移走的岩石数。" class="headerlink" title="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;=至多移走的岩石数。"></a>题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;=至多移走的岩石数。</h4><p>```cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<bits/stdc++.h></h1><p>const int N = 5e5+10;<br>typedef long long ll;<br>using namespace std;<br>int a[N];<br>int d,n,m;<br>bool check(int x){<br>    int cnt = 0;//当前最短跳跃需要移走的个数<br>    int now = 0;<br>    int i = 0;<br>    while(i<n+1){        i++;        if(a[i]-a[now]<x){//如果跳跃距离小于当前的就需要移            cnt++;        }        else{            now = i;//如果不需要那就跳到当前的石头        }    }    if(cnt>m) return false;//大于就说明小的更多还不够小</p><pre><code class="hljs">else return true;</code></pre><p>}<br>void solve(){<br>    cin&gt;&gt;d&gt;&gt;n&gt;&gt;m;<br>    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    a[n+1] = d;//相当于总数是n+1<br>    int l = 0,r = d;<br>    while(l<r){        int mid = (l+r+1)>&gt;1;<br>        if(check(mid)){<br>            l = mid;<br>        }<br>        else{<br>            r = mid-1;<br>        }<br>    }<br>    cout&lt;&lt;l;<br>}<br>int main(){<br>    std::ios::sync_with_stdio(false);<br>    std::cin.tie(0);<br>    solve();<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder341 d</title>
    <link href="/2024/02/21/Atcoder341-d/"/>
    <url>/2024/02/21/Atcoder341-d/</url>
    
    <content type="html"><![CDATA[<h4 id="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"><a href="#前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。" class="headerlink" title="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"></a>前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。</h4><h4 id="问题陈述"><a href="#问题陈述" class="headerlink" title="#### 问题陈述"></a>#### 问题陈述</h4><h4 id="给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。"><a href="#给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。" class="headerlink" title="给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。"></a>给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。</h4><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h4 id="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"><a href="#题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。" class="headerlink" title="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"></a>题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">对于这道题，我们可以将k作为一个基准值，可以用二分法找到想要的数字，所以对于这里我们可用二分进行二分答案的操作，因为是一个整除所以说明两个的公因数是不行的，就比如<span class="hljs-number">6</span>，被<span class="hljs-number">2</span>和<span class="hljs-number">3</span>整除。这个就要被去掉，所以我们需要找到两个数的最大公因数，所以就是找到最小公倍数。然后我们举个例子：如果我们想要知道<span class="hljs-number">15</span>以内的合法序列的数，我们可以求<span class="hljs-number">20</span>以内<span class="hljs-number">2</span>的个数<span class="hljs-symbol">:20</span>/<span class="hljs-number">2</span>,对于<span class="hljs-number">3</span>的个数就是<span class="hljs-symbol">:20</span>/<span class="hljs-number">3</span>，然后我们需要去掉两者的最小倍数，但是在<span class="hljs-number">2</span>的时候算了一次，又在<span class="hljs-number">3</span>的时候算了一次，所以我们需要减掉两倍的<span class="hljs-number">20</span>/两者的最大公因数。所以我们可以抽象成数学，二分的就是<span class="hljs-built_in">mid</span>,所以我们判断x是k，我们可以写成[<span class="hljs-built_in">mid</span>/<span class="hljs-built_in">n</span>]+[<span class="hljs-built_in">mid</span>/m]-<span class="hljs-number">2</span>*[<span class="hljs-built_in">mid</span>/<span class="hljs-built_in">lcm</span>(<span class="hljs-built_in">n</span>,m)]然后来判断大小<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x,<span class="hljs-type">long</span> <span class="hljs-type">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x&gt;y)<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">if</span>(y%x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(y%x,x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n,m,x,k;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>x=(n*m)/<span class="hljs-built_in">gcd</span>(n,m);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l=<span class="hljs-number">0</span>,r=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-number">2e+18</span>,mid,y;<br><span class="hljs-keyword">while</span>((l+<span class="hljs-number">1</span>)&lt;r)&#123;<br>mid=(l+r)/<span class="hljs-number">2</span>;<br>y=(mid/n)+(mid/m)<span class="hljs-number">-2</span>*(mid/x);<br><span class="hljs-keyword">if</span>(y&lt;k)l=mid;<br><span class="hljs-keyword">else</span> r=mid;<br>&#125;<br>cout&lt;&lt;r&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题练习2</title>
    <link href="/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/"/>
    <url>/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h4 id="【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"><a href="#【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。" class="headerlink" title="【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"></a><a href="https://blog.csdn.net/ronaldo7_zyb/article/details/81069906">【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客</a>背包求方案数的一系列模板可以得到思路。</h4><h4 id="P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5365 英雄联盟P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P5365 英雄联盟<a href="https://www.luogu.com.cn/problem/P5365">P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"><a href="#题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。" class="headerlink" title="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f[j] = max(f[j],f[j-x*c[i]]*x)然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"></a>题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，<code>f[j] = max(f[j],f[j-x*c[i]]*x)</code>然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n,m,k[N],c[N],dp[N],qm;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;c[i];<br>qm+=k[i]*c[i];<span class="hljs-comment">//钱的总数</span><br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = qm;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<span class="hljs-comment">//只能选一次01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x&lt;=k[i];x++)&#123;<span class="hljs-comment">//皮肤个数</span><br><span class="hljs-keyword">if</span>(j&gt;=x*c[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-c[i]*x]*x);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;<br><span class="hljs-keyword">if</span>(dp[i]&gt;=m)&#123;<span class="hljs-comment">//找到大于等于的方案数</span><br>cout&lt;&lt;i;<span class="hljs-comment">//输出下标。</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1077 摆花P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1077 摆花<a href="https://www.luogu.com.cn/problem/P1077">P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。"><a href="#思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。" class="headerlink" title="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp[0] = 1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min(a[i],j)就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))。这个可以看一下顶上的文章求可行方案数。"></a>思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将<code>dp[0] = 1</code>，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是<code>min(a[i],j)</code>就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到<code>fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))</code>。这个可以看一下顶上的文章求可行方案数。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e6</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m,a[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>dp[<span class="hljs-number">0</span>]= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">min</span>(a[i],j);k++)&#123;<br>dp[j]= dp[j-k]+dp[j];<br>dp[j] %= mod;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m]%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2347P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2347<a href="https://www.luogu.com.cn/problem/P2347">P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"><a href="#很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。" class="headerlink" title="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"></a>很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> num[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>&#125;;<br><span class="hljs-type">int</span> dp[N],a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br>cin&gt;&gt;a[i];<br>sum+=a[i]*num[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=a[i];k++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=num[i<span class="hljs-number">-1</span>]*k)&#123;<br>dp[j]+=dp[j-num[i<span class="hljs-number">-1</span>]*k];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=sum;i++)&#123;<br><span class="hljs-keyword">if</span>(dp[i]) ans++;<br> &#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Total=&quot;</span>&lt;&lt;ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题练习1</title>
    <link href="/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/"/>
    <url>/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h4 id="P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1833 樱花P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1833 樱花<a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"><a href="#题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。" class="headerlink" title="题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"></a>题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10100</span>;<br><span class="hljs-type">int</span> c[N],dp[N],t[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> th1,ts1,th2,ts2,n;<br><span class="hljs-type">char</span> cc;<br>cin&gt;&gt;th1&gt;&gt;cc&gt;&gt;ts1&gt;&gt;th2&gt;&gt;cc&gt;&gt;ts2&gt;&gt;n;<br><span class="hljs-type">int</span> tz = <span class="hljs-number">60</span>*(th2-th1)+ts2-ts1;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> t0,c0,s;<br>cin&gt;&gt;t0&gt;&gt;c0&gt;&gt;s;<br><span class="hljs-keyword">if</span>(s==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//完全背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=tz;j++) <span class="hljs-keyword">if</span>(j&gt;=t0) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t0]+c0);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//多重背包加上01背包写一起</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>cnt++;<br>t[cnt] = k*t0;<br>c[cnt] = k*c0;<br>s-=k;<br>k*=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(s)&#123;<br>cnt++;<br>t[cnt] = s*t0;<br>c[cnt] = s*c0;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">1</span>;m&lt;=cnt;m++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = tz;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=t[m]) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t[m]]+c[m]);<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br>cout&lt;&lt;dp[tz];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"><a href="#当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、" class="headerlink" title="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"></a>当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、</h4><h4 id="P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1049 装箱问题(01背包)P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1049 装箱问题(01背包)<a href="https://www.luogu.com.cn/problem/P1049">P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="代码-简单就不写题解"><a href="#代码-简单就不写题解" class="headerlink" title="代码(简单就不写题解)"></a>代码(简单就不写题解)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20010</span>],v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> v1,n;<br>cin&gt;&gt;v1&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v1;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=v[i])dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+v[i]);<br>&#125;<br>&#125;<br>cout&lt;&lt;v1-dp[v1];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="01背包求方案数"><a href="#01背包求方案数" class="headerlink" title="01背包求方案数"></a>01背包求方案数</h4><h4 id="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。"><a href="#就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。" class="headerlink" title="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max(f[j],f[j-v]+w)，如果maxn==f[j]就是说是前一个更好，所以f[j] = maxn然后就是将方案数变成g[j-a]，如果相等的话，就是相当于有两条路，g[j] = (g[j]+g[j-a])就是说这两条路的方案数都要。"></a>就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到<code>max(f[j],f[j-v]+w)</code>，如果<code>maxn==f[j]</code>就是说是前一个更好，所以<code>f[j] = maxn</code>然后就是将方案数变成<code>g[j-a]</code>，如果相等的话，就是相当于有两条路，<code>g[j] = (g[j]+g[j-a])</code>就是说这两条路的方案数都要。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,v,a,b,f[<span class="hljs-number">1005</span>],g[<span class="hljs-number">1005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=v;i++)<br>        g[i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//输入废话</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v;j&gt;=a;j--)&#123;<br>            <span class="hljs-type">int</span> z=f[j-a]+b;<span class="hljs-comment">//先用一个数存起来f[j-a]+b</span><br>            <span class="hljs-keyword">if</span>(f[j]&lt;z)&#123;如果f[j]小于它<br>                f[j]=z;<span class="hljs-comment">//更新f[j]</span><br>                g[j]=g[j-a];<span class="hljs-comment">//方案数变为g[j-a]</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f[j]==z)<span class="hljs-comment">//否则如果它们相等</span><br>                g[j]=(g[j]+g[j-a])%<span class="hljs-number">1000000007</span>;<span class="hljs-comment">//方案数更新为现在的方案数加上g[j-a]的方案数取模1e9+7</span><br>        &#125;<br>    &#125;<br>    cout&lt;&lt;g[v];<span class="hljs-comment">//最后输出最优选法方案数</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1164 小A点菜P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1164 小A点菜<a href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。"><a href="#这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。" class="headerlink" title="这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp[]数组即可。"></a>这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp<code>[]</code>数组即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[<span class="hljs-number">105</span>],f[<span class="hljs-number">105</span>][<span class="hljs-number">10005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <br>&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == j)<br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>            &#125;  <br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">if</span>(a[i]&gt;j) <br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j];<br>            &#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>                f[i][j]=f[i<span class="hljs-number">-1</span>][j]+f[i<span class="hljs-number">-1</span>][j-a[i]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1060 开心的金明(01背包)P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1060 开心的金明(01背包)<a href="https://www.luogu.com.cn/problem/P1060">P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"><a href="#题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可" class="headerlink" title="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"></a>题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">30050</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> p[M],v[M],dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;v[i]&gt;&gt;p[i];<br>p[i] = v[i]*p[i];<span class="hljs-comment">//相当于乘机</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=v[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+p[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2722P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2722<a href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="一个板子题，看到可以重复选择就说明是完全背包。"><a href="#一个板子题，看到可以重复选择就说明是完全背包。" class="headerlink" title="一个板子题，看到可以重复选择就说明是完全背包。"></a>一个板子题，看到可以重复选择就说明是完全背包。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> t[N],p[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> m,n;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;p[i]&gt;&gt;t[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=t[i])&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-t[i]]+p[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1853 投资的最大效益P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1853 投资的最大效益<a href="https://www.luogu.com.cn/problem/P1853">P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"><a href="#题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子" class="headerlink" title="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"></a>题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> M = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> a[M],b[M];<span class="hljs-comment">//投资额,年利息</span><br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> sum,year,n;<br>cin&gt;&gt;sum&gt;&gt;year&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i]&gt;&gt;b[i];<br>a[i]/=<span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k&lt;=year;k++)&#123;<br><span class="hljs-type">int</span> t = sum/<span class="hljs-number">1000</span>;<span class="hljs-comment">//总额更新</span><br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//dp数组清0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=t;j++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=a[i]) dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+b[i]);<br>&#125;<br>&#125;<br>sum+=dp[t];<span class="hljs-comment">//每年的最大值加到总额里面。</span><br>&#125;<br>cout&lt;&lt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP(分组背包问题)</title>
    <link href="/2024/02/17/DP-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/17/DP-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。"><a href="#分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。" class="headerlink" title="分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。"></a>分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。</h4><h4 id="f-N-N-就是前i组物品中选，当前体积小于等于j的最大值，v-体积，w-价值，s-代表第i组的物品个数。"><a href="#f-N-N-就是前i组物品中选，当前体积小于等于j的最大值，v-体积，w-价值，s-代表第i组的物品个数。" class="headerlink" title="f[N][N]就是前i组物品中选，当前体积小于等于j的最大值，v[][]体积，w[][]价值，s[]代表第i组的物品个数。"></a><code>f[N][N]</code>就是前i组物品中选，当前体积小于等于j的最大值，<code>v[][]</code>体积，<code>w[][]</code>价值，<code>s[]</code>代表第i组的物品个数。</h4><h4 id="如果不选就是f-i-j-f-i-1-j-，如果选的话就是f-i-j-max-f-i-j-f-i-1-j-v-i-k-w-i-k-；这就是状态转移方程。"><a href="#如果不选就是f-i-j-f-i-1-j-，如果选的话就是f-i-j-max-f-i-j-f-i-1-j-v-i-k-w-i-k-；这就是状态转移方程。" class="headerlink" title="如果不选就是f[i][j] = f[i-1][j]，如果选的话就是f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k])；这就是状态转移方程。"></a>如果不选就是<code>f[i][j] = f[i-1][j]</code>，如果选的话就是<code>f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k])</code>；这就是状态转移方程。</h4><h4 id="如果是一维的就是根据0-1背包一样逆序操作，f-j-max-f-j-f-j-v-i-k-w-i-k"><a href="#如果是一维的就是根据0-1背包一样逆序操作，f-j-max-f-j-f-j-v-i-k-w-i-k" class="headerlink" title="如果是一维的就是根据0-1背包一样逆序操作，f[j] = max(f[j],f[j-v[i][k]]+w[i][k])"></a>如果是一维的就是根据0-1背包一样逆序操作，<code>f[j] = max(f[j],f[j-v[i][k]]+w[i][k])</code></h4><h4 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a>P1757 通天之分组背包</h4><p><a href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二维</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1050</span>;<br><span class="hljs-type">int</span> w[N][N],p[N][N],s[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> weight,n;<br>cin&gt;&gt;weight&gt;&gt;n;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> tmpw,tmpp,k;<br>cin&gt;&gt;tmpw&gt;&gt;tmpp&gt;&gt;k;<br>s[k]++;<br>w[k][s[k]] = tmpw;<br>p[k][s[k]] = tmpp;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=weight;j++)&#123;<br>f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;m&lt;=s[i];m++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=w[i][m])&#123;<br>f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-w[i][m]]+p[i][m]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;f[n][weight];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一维</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1050</span>;<br><span class="hljs-type">int</span> w[N][N],p[N][N],s[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> weight,n;<br>cin&gt;&gt;weight&gt;&gt;n;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-type">int</span> tmpw,tmpp,k;<br>cin&gt;&gt;tmpw&gt;&gt;tmpp&gt;&gt;k;<br>s[k]++;<br>w[k][s[k]] = tmpw;<br>p[k][s[k]] = tmpp;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>f[j] = f[j];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;m&lt;=s[i];m++)&#123;<br><span class="hljs-keyword">if</span>(j&gt;=w[i][m])&#123;<br>f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i][m]]+p[i][m]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;f[weight];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寒假前端学习Day4(Vue)</title>
    <link href="/2024/02/17/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day4-Vue/"/>
    <url>/2024/02/17/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day4-Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件的引入就是需要在-lt-setup-gt-中引入子组件的模块，然后在模板中使用组件。"><a href="#组件的引入就是需要在-lt-setup-gt-中引入子组件的模块，然后在模板中使用组件。" class="headerlink" title="组件的引入就是需要在&lt;setup&gt;中引入子组件的模块，然后在模板中使用组件。"></a>组件的引入就是需要在<code>&lt;setup&gt;</code>中引入子组件的模块，然后在模板中使用组件。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!------App.vue-------&gt;<br>&lt;script setup&gt;<br>import ChildComp from &#x27;./ChildComp.vue&#x27;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ChildComp /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--ChildComp.vue----&gt;<br>template&gt;<br>  &lt;h2&gt;A Child Component!&lt;/h2&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><h4 id="这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。"><a href="#这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。" class="headerlink" title="这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。"></a>这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。</h4><h4 id="在子组件中定义props"><a href="#在子组件中定义props" class="headerlink" title="在子组件中定义props"></a>在子组件中定义props</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!------ChildComp.vue-----&gt;<br>&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  msg: String<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h2&gt;&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="可以看到在子组件中定义了prop然后再子组件的模板中挂上msg"><a href="#可以看到在子组件中定义了prop然后再子组件的模板中挂上msg" class="headerlink" title="可以看到在子组件中定义了prop然后再子组件的模板中挂上msg"></a>可以看到在子组件中定义了prop然后再子组件的模板中挂上msg</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--App.vue---&gt;<br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>import ChildComp from &#x27;./ChildComp.vue&#x27;<br><br>const greeting = ref(&#x27;&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ChildComp :msg=&quot;greeting&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。"><a href="#所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。" class="headerlink" title="所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。"></a>所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp(01背包和完全背包)</title>
    <link href="/2024/02/16/dp-01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    <url>/2024/02/16/dp-01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="对于01背包，来说就是每个物品只能使用一次。"><a href="#对于01背包，来说就是每个物品只能使用一次。" class="headerlink" title="对于01背包，来说就是每个物品只能使用一次。"></a>对于01背包，来说就是每个物品只能使用一次。</h4><h4 id="对于01背包的思考，就是要找到能背包能够容纳的最大。"><a href="#对于01背包的思考，就是要找到能背包能够容纳的最大。" class="headerlink" title="对于01背包的思考，就是要找到能背包能够容纳的最大。"></a>对于01背包的思考，就是要找到能背包能够容纳的最大。</h4><h4 id="首先是二维的01背包，这是最原始的背包也是最好理解的，f-i-j-定义就是前i个物品，背包容量为j的最优解，加入背包容量不够-j-lt-v-i-，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是-f-i-j-f-i-1-j-，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是f-i-j-f-i-1-j-。如果选的就是f-i-j-f-i-1-j-v-i-w-i-所以取到最大价值取max-即可。但是二维的01背包可以进行一维的优化。"><a href="#首先是二维的01背包，这是最原始的背包也是最好理解的，f-i-j-定义就是前i个物品，背包容量为j的最优解，加入背包容量不够-j-lt-v-i-，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是-f-i-j-f-i-1-j-，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是f-i-j-f-i-1-j-。如果选的就是f-i-j-f-i-1-j-v-i-w-i-所以取到最大价值取max-即可。但是二维的01背包可以进行一维的优化。" class="headerlink" title="首先是二维的01背包，这是最原始的背包也是最好理解的，f[i][j]定义就是前i个物品，背包容量为j的最优解，加入背包容量不够(j&lt;v[i])，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是:f[i][j] = f[i-1][j]，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是f[i][j = f[i-1][j]。如果选的就是f[i][j] = f[i-1][j-v[i]]+w[i]所以取到最大价值取max()即可。但是二维的01背包可以进行一维的优化。"></a>首先是二维的01背包，这是最原始的背包也是最好理解的，<code>f[i][j]</code>定义就是前i个物品，背包容量为j的最优解，加入背包容量不够(<code>j&lt;v[i]</code>)，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是:<code>f[i][j] = f[i-1][j]</code>，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是<code>f[i][j = f[i-1][j]</code>。如果选的就是<code>f[i][j] = f[i-1][j-v[i]]+w[i]</code>所以取到最大价值取max()即可。但是二维的01背包可以进行一维的优化。</h4><h4 id="所以状态转移方程可以写成f-i-j-max-f-i-1-j-f-i-1-j-w-i"><a href="#所以状态转移方程可以写成f-i-j-max-f-i-1-j-f-i-1-j-w-i" class="headerlink" title="所以状态转移方程可以写成f[i][j] = max(f[i-1][j],f[i-1][j]+w[i])"></a>所以状态转移方程可以写成<code>f[i][j] = max(f[i-1][j],f[i-1][j]+w[i])</code></h4><h4 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h4><p> <a href="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP2005 普及组] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h4 id="这就是典型的01背包问题，药只能用一次。"><a href="#这就是典型的01背包问题，药只能用一次。" class="headerlink" title="这就是典型的01背包问题，药只能用一次。"></a>这就是典型的01背包问题，药只能用一次。</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><span class="hljs-type">int</span> v[MAXN];    <span class="hljs-comment">// 体积</span><br><span class="hljs-type">int</span> w[MAXN];    <span class="hljs-comment">// 价值 </span><br><span class="hljs-type">int</span> f[MAXN][MAXN];  <span class="hljs-comment">// f[i][j], j体积下前i个物品的最大价值 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;   <br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span><br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) <br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 能装，需进行决策是否选择第i个物品</span><br>            <span class="hljs-keyword">else</span>    <br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125;          <br><br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f-j-max-f-j-f-j-v-i-w-i-并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！-知乎-zhihu-com"><a href="#对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f-j-max-f-j-f-j-v-i-w-i-并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！-知乎-zhihu-com" class="headerlink" title="对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f[j] = max(f[j],f[j-v[i]]+w[i]) 并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！ - 知乎 (zhihu.com)"></a>对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程<code>f[j] = max(f[j],f[j-v[i]]+w[i])</code> 并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章<a href="https://zhuanlan.zhihu.com/p/345364527">咱就把0-1背包问题讲个通透！ - 知乎 (zhihu.com)</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一维的01背包</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ;<br><span class="hljs-type">int</span> ti[<span class="hljs-number">1005</span>] , pri[<span class="hljs-number">1005</span>] ;<br><span class="hljs-type">int</span> f[<span class="hljs-number">1005</span>] ;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t , m ;<br>    cin &gt;&gt; t &gt;&gt; m ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++i)<br>        cin &gt;&gt; ti[i] &gt;&gt; pri[i] ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t ; j &gt;= <span class="hljs-number">1</span> ; --j)<span class="hljs-comment">//逆序</span><br>            <span class="hljs-keyword">if</span>(j &gt;= ti[i])<br>                f[j] = <span class="hljs-built_in">max</span>(f[j] , f[j - ti[i]] + pri[i]) ;<br>    cout &lt;&lt; f[t] ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f-i-j-max-f-i-j-f-i-1-j-k-v-i-k-w-i-所以说还需要一层对k的循环，判断是k-v-i-lt-j-这就会需要三层循环。但是我们会发现f-i-j-max-f-i-1-j-f-i-1-j-v-w-f-i-1-j-2-v-2w"><a href="#就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f-i-j-max-f-i-j-f-i-1-j-k-v-i-k-w-i-所以说还需要一层对k的循环，判断是k-v-i-lt-j-这就会需要三层循环。但是我们会发现f-i-j-max-f-i-1-j-f-i-1-j-v-w-f-i-1-j-2-v-2w" class="headerlink" title="就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])所以说还需要一层对k的循环，判断是k*v[i]&lt;j 这就会需要三层循环。但是我们会发现f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2w...)"></a>就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以<code>f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])</code>所以说还需要一层对k的循环，判断是<code>k*v[i]&lt;j</code> 这就会需要三层循环。但是我们会发现<code>f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2w...)</code></h4><h4 id="f-i-j-v-max-f-i-1-j-v-f-i-1-j-2-v-w-f-i-1-j-3-v-2w"><a href="#f-i-j-v-max-f-i-1-j-v-f-i-1-j-2-v-w-f-i-1-j-3-v-2w" class="headerlink" title="f[i,j-v] = max(      f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-3*v]+2w...)"></a><code>f[i,j-v] = max(      f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-3*v]+2w...)</code></h4><h4 id="所以可以写成f-i-j-max-f-i-j-v-w-f-i-1-j"><a href="#所以可以写成f-i-j-max-f-i-j-v-w-f-i-1-j" class="headerlink" title="所以可以写成f[i][j] = max(f[i,j-v]+w,f[i-1][j])"></a>所以可以写成<code>f[i][j] = max(f[i,j-v]+w,f[i-1][j])</code></h4><h4 id="可以先将f-i-j-f-i-1-j-所以状态转移方程就可以写成f-i-j-max-f-i-j-f-i-j-v-i-w-i"><a href="#可以先将f-i-j-f-i-1-j-所以状态转移方程就可以写成f-i-j-max-f-i-j-f-i-j-v-i-w-i" class="headerlink" title="可以先将f[i][j] = f[i-1][j]所以状态转移方程就可以写成f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i])"></a>可以先将<code>f[i][j] = f[i-1][j]</code>所以状态转移方程就可以写成<code>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i])</code></h4><h4 id="对于完全背包的一维优化，我们可以看到就是都是关于f-i-的东西，所以跟01背包的f-i-1-是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。"><a href="#对于完全背包的一维优化，我们可以看到就是都是关于f-i-的东西，所以跟01背包的f-i-1-是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。" class="headerlink" title="对于完全背包的一维优化，我们可以看到就是都是关于f[i][]的东西，所以跟01背包的f[i-1][]是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。"></a>对于完全背包的一维优化，我们可以看到就是都是关于<code>f[i][]</code>的东西，所以跟01背包的<code>f[i-1][]</code>是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。</h4><h4 id="题目P1616-疯狂的采药"><a href="#题目P1616-疯狂的采药" class="headerlink" title="题目P1616 疯狂的采药"></a>题目P1616 疯狂的采药</h4><h4 id="P1616-疯狂的采药-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1616-疯狂的采药-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = <span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> times[N],prices[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> t,m;<br>cin&gt;&gt;t&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;times[i]&gt;&gt;prices[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = <span class="hljs-number">1</span>;j&lt;=t;j++)&#123;<br>f[j] = f[j];<br><span class="hljs-keyword">if</span>(j&gt;=times[i])&#123;<br>f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-times[i]]+prices[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;f[t];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2024/02/14/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2024/02/14/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="STL中的二分法"><a href="#STL中的二分法" class="headerlink" title="STL中的二分法"></a>STL中的二分法</h4><h5 id="数组是-1-2-4-4-5-6"><a href="#数组是-1-2-4-4-5-6" class="headerlink" title="数组是{1,2,4,4,5,6}"></a>数组是{1,2,4,4,5,6}</h5><h5 id="在STL中lower-bound-是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower-bound-v-begin-v-end-target-这样就会指的是第三个元素"><a href="#在STL中lower-bound-是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower-bound-v-begin-v-end-target-这样就会指的是第三个元素" class="headerlink" title="在STL中lower_bound()是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower_bound(v.begin(),v.end(),target);这样就会指的是第三个元素"></a>在STL中lower_bound()是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower_bound(v.begin(),v.end(),target);这样就会指的是第三个元素</h5><h5 id="在STL中upper-bound-是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。"><a href="#在STL中upper-bound-是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。" class="headerlink" title="在STL中upper_bound()是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。"></a>在STL中upper_bound()是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。</h5><h4 id="用STL写二分查找"><a href="#用STL写二分查找" class="headerlink" title="用STL写二分查找"></a>用STL写二分查找</h4><h5 id="输入-n-个不超过-10-9-的单调不减的（就是后面的数字不小于前面的数字）非负整数-1-2-…-a1​-a2​-…-an​，然后进行-m-次询问。对于每次询问，给出一个整数-q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出-−1-。"><a href="#输入-n-个不超过-10-9-的单调不减的（就是后面的数字不小于前面的数字）非负整数-1-2-…-a1​-a2​-…-an​，然后进行-m-次询问。对于每次询问，给出一个整数-q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出-−1-。" class="headerlink" title="输入 n 个不超过 10^9 的单调不减的（就是后面的数字不小于前面的数字）非负整数 1,2,…,a1​,a2​,…,an​，然后进行 m 次询问。对于每次询问，给出一个整数 q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 −1 。"></a>输入 n 个不超过 10^9 的单调不减的（就是后面的数字不小于前面的数字）非负整数 1,2,…,a1​,a2​,…,an​，然后进行 m 次询问。对于每次询问，给出一个整数 q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 −1 。</h5><h5 id="题解：这里就是用函数lower-bound-来返回第一个大于等于，然后想返回序列号就用distance-，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。"><a href="#题解：这里就是用函数lower-bound-来返回第一个大于等于，然后想返回序列号就用distance-，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。" class="headerlink" title="题解：这里就是用函数lower_bound()来返回第一个大于等于，然后想返回序列号就用distance()，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。"></a>题解：这里就是用函数lower_bound()来返回第一个大于等于，然后想返回序列号就用distance()，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。</h5><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> m;<br>cin&gt;&gt;n&gt;&gt;m;<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> x;<br>cin&gt;&gt;x;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> target;<br>cin&gt;&gt;target;<br><span class="hljs-keyword">auto</span> it =<span class="hljs-built_in">lower_bound</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),target);<br><span class="hljs-keyword">if</span>(it!=a.<span class="hljs-built_in">end</span>()&amp;&amp;*it==target)&#123;<br>cout&lt;&lt;<span class="hljs-built_in">distance</span>(a.<span class="hljs-built_in">begin</span>(),it)+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;-1 &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实数范围的二分（带小数）"><a href="#实数范围的二分（带小数）" class="headerlink" title="实数范围的二分（带小数）"></a>实数范围的二分（带小数）</h4><h5 id="对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。"><a href="#对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。" class="headerlink" title="对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。"></a>对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。</h5><h5 id="用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。"><a href="#用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。" class="headerlink" title="用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。"></a>用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。</h5><h5 id="举个例子，对于f-x-x-2-2，精度为1e-6，要通过二分法求零点的话。"><a href="#举个例子，对于f-x-x-2-2，精度为1e-6，要通过二分法求零点的话。" class="headerlink" title="举个例子，对于f(x) = x^2-2，精度为1e-6，要通过二分法求零点的话。"></a>举个例子，对于f(x) = x^2-2，精度为1e-6，要通过二分法求零点的话。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x*x<span class="hljs-number">-2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">double</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">2</span>,eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">while</span>(right-left&gt;eps)&#123;<br><span class="hljs-type">double</span> mid = left+(right-left)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid)&gt;<span class="hljs-number">0</span>)&#123;<br>right = mid;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>left = mid;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;零点是:&quot;</span>&lt;&lt;left&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h4><h5 id="题目有形如：ax-3-bx-2-cx-d-0-这样的一个一元三次方程。给出该方程中各项的系数（a-b-c-d-均为实数），并约定该方程存在三个不同实根（根的范围在-−100至-100-之间），且根与根之差的绝对值-≥1。要求由小到大依次在同一行输出这三个实根-根与根之间留有空格-，并精确到小数点后-2-位。"><a href="#题目有形如：ax-3-bx-2-cx-d-0-这样的一个一元三次方程。给出该方程中各项的系数（a-b-c-d-均为实数），并约定该方程存在三个不同实根（根的范围在-−100至-100-之间），且根与根之差的绝对值-≥1。要求由小到大依次在同一行输出这三个实根-根与根之间留有空格-，并精确到小数点后-2-位。" class="headerlink" title="题目有形如：ax^3+bx^2+cx+d=0 这样的一个一元三次方程。给出该方程中各项的系数（a,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 −100至 100 之间），且根与根之差的绝对值 ≥1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 2 位。"></a>题目有形如：ax^3+bx^2+cx+d=0 这样的一个一元三次方程。给出该方程中各项的系数（a,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 −100至 100 之间），且根与根之差的绝对值 ≥1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 2 位。</h5><h5 id="提示：记方程-f-x-0，若存在-2-个数-x1​-和-x2​，且-x1​-lt-x2​，f-x1​-×f-x2​-lt-0，则在-x1​-x2​-之间一定有一个根。"><a href="#提示：记方程-f-x-0，若存在-2-个数-x1​-和-x2​，且-x1​-lt-x2​，f-x1​-×f-x2​-lt-0，则在-x1​-x2​-之间一定有一个根。" class="headerlink" title="提示：记方程 f(x)=0，若存在 2 个数 x1​ 和 x2​，且 x1​&lt;x2​，f(x1​)×f(x2​)&lt;0，则在 (x1​,x2​) 之间一定有一个根。"></a>提示：记方程 f(x)=0，若存在 2 个数 x1​ 和 x2​，且 x1​&lt;x2​，f(x1​)×f(x2​)&lt;0，则在 (x1​,x2​) 之间一定有一个根。</h5><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h5 id="输入和输出案例"><a href="#输入和输出案例" class="headerlink" title="输入和输出案例"></a>输入和输出案例</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>-<span class="hljs-number">5</span> -<span class="hljs-number">4</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-2.00 2.00 5.00</span><br></code></pre></td></tr></table></figure><h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><h5 id="这就是典型的函数零点求解。"><a href="#这就是典型的函数零点求解。" class="headerlink" title="这就是典型的函数零点求解。"></a>这就是典型的函数零点求解。</h5><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">double</span> a,b,c,d;<span class="hljs-comment">//定义全局变量，在函数和主程序里面都有用 </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a*x*x*x+b*x*x+c*x+d);<span class="hljs-comment">//万能函数，求出在未知数为x时的方程解 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x1,x2,xx;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<span class="hljs-comment">//输入 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">-100</span>;x&lt;=<span class="hljs-number">100</span>;x+=<span class="hljs-number">1</span>)<span class="hljs-comment">//枚举每一个可能的根 </span><br>    &#123;<br>        x1=x;x2=x+<span class="hljs-number">1</span>;<span class="hljs-comment">//确定根可能所在的区间 </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(x1)==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f &quot;</span>,x1);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(x1)*<span class="hljs-built_in">f</span>(x2)&lt;<span class="hljs-number">0</span>)<br>             &#123;<br>                 <span class="hljs-keyword">while</span>(x2-x1&gt;=<span class="hljs-number">0.001</span>)<span class="hljs-comment">//二分法确定根的值 </span><br>                 &#123;<br>                      xx=(x1+x2)/<span class="hljs-number">2</span>;<br>                      <span class="hljs-keyword">if</span>((<span class="hljs-built_in">f</span>(x1)*<span class="hljs-built_in">f</span>(xx))&lt;=<span class="hljs-number">0</span>)x2=xx;<br>                      <span class="hljs-keyword">else</span> x1=xx;<br>                 &#125;<br>                 <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f &quot;</span>,x1);<span class="hljs-comment">//输出根 </span><br>             &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对于二分法区间的操作"><a href="#对于二分法区间的操作" class="headerlink" title="对于二分法区间的操作"></a>对于二分法区间的操作</h4><p><a href="https://zhuanlan.zhihu.com/p/533408649">二分法总结 | 万字长文带你看透二分查找 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体和cmp的简单操作</title>
    <link href="/2024/02/05/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Ccmp%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/02/05/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Ccmp%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="在做排序算法的基础题的时候。如果一个对象里面多个元素需要进行排序，那么用结构体加cmp，对sort的排序进行改写-就能达到一个很好的效果。"><a href="#在做排序算法的基础题的时候。如果一个对象里面多个元素需要进行排序，那么用结构体加cmp，对sort的排序进行改写-就能达到一个很好的效果。" class="headerlink" title="在做排序算法的基础题的时候。如果一个对象里面多个元素需要进行排序，那么用结构体加cmp，对sort的排序进行改写,就能达到一个很好的效果。"></a>在做排序算法的基础题的时候。如果一个对象里面多个元素需要进行排序，那么用结构体加cmp，对sort的排序进行改写,就能达到一个很好的效果。</h4><h4 id="P1781-宇宙总统"><a href="#P1781-宇宙总统" class="headerlink" title="P1781 宇宙总统"></a>P1781 宇宙总统</h4><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 n 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。</p><h4 id="输入输出样式"><a href="#输入输出样式" class="headerlink" title="输入输出样式"></a>输入输出样式</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">5</span><br><span class="hljs-number">98765</span><br><span class="hljs-number">12365</span><br><span class="hljs-number">87954</span><br><span class="hljs-number">1022356</span><br><span class="hljs-number">985678</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">4</span><br><span class="hljs-number">1022356</span><br></code></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="其实这个题目就需要考虑到字符串长度的比较和在相同长度下数字的大小，然后这就是用字符串的比较通过字典数来进行。然后每个候选人的序号都需要存储，所有这个就有多个元素需要存储和排序，因此用结构体是一个比较好的选择。"><a href="#其实这个题目就需要考虑到字符串长度的比较和在相同长度下数字的大小，然后这就是用字符串的比较通过字典数来进行。然后每个候选人的序号都需要存储，所有这个就有多个元素需要存储和排序，因此用结构体是一个比较好的选择。" class="headerlink" title="其实这个题目就需要考虑到字符串长度的比较和在相同长度下数字的大小，然后这就是用字符串的比较通过字典数来进行。然后每个候选人的序号都需要存储，所有这个就有多个元素需要存储和排序，因此用结构体是一个比较好的选择。"></a>其实这个题目就需要考虑到字符串长度的比较和在相同长度下数字的大小，然后这就是用字符串的比较通过字典数来进行。然后每个候选人的序号都需要存储，所有这个就有多个元素需要存储和排序，因此用结构体是一个比较好的选择。</h5><h5 id="对于cmp的写法"><a href="#对于cmp的写法" class="headerlink" title="对于cmp的写法"></a>对于cmp的写法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(houxuan a,houxuan b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.len!=b.len) <span class="hljs-keyword">return</span> a.len&gt;b.len;<span class="hljs-comment">//排序大的</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> a.votes&gt;b.votes;<span class="hljs-comment">//如果相同就排序字典数</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">houxuan</span>&#123;<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">int</span> len;<br>string votes;<br>&#125;houxuans[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(houxuan a,houxuan b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.len!=b.len) <span class="hljs-keyword">return</span> a.len&gt;b.len;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> a.votes&gt;b.votes;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>houxuans[i].num = i+<span class="hljs-number">1</span>;<br>string s;<br>cin&gt;&gt;s;<br>houxuans[i].votes = s;<br>houxuans[i].len = houxuans[i].votes.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-built_in">sort</span>(houxuans,houxuans+n,cmp);<br>cout&lt;&lt;houxuans[<span class="hljs-number">0</span>].num&lt;&lt;endl;<br>cout&lt;&lt;houxuans[<span class="hljs-number">0</span>].votes;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="还有类似的简单题目就是在-P1093-洛谷上-也是用结构体排序的简单题目。"><a href="#还有类似的简单题目就是在-P1093-洛谷上-也是用结构体排序的简单题目。" class="headerlink" title="还有类似的简单题目就是在 P1093(洛谷上),也是用结构体排序的简单题目。"></a>还有类似的简单题目就是在 P1093(洛谷上),也是用结构体排序的简单题目。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2024/02/03/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/02/03/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="洛谷-B3619-10进制转x进制"><a href="#洛谷-B3619-10进制转x进制" class="headerlink" title="洛谷 B3619 10进制转x进制"></a>洛谷 B3619 10进制转x进制</h4><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个十进制整数 n 和一个小整数 x。将整数 n 转为 x 进制。对于超过十进制的数码，用 <code>A</code>，<code>B</code> … 表示。</p><h4 id="输入输出案例"><a href="#输入输出案例" class="headerlink" title="输入输出案例"></a>输入输出案例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1111101000</span><br></code></pre></td></tr></table></figure><h5 id="进制转换的操作"><a href="#进制转换的操作" class="headerlink" title="进制转换的操作"></a>进制转换的操作</h5><h5 id="进位制-OI-Wiki-oi-wiki-org"><a href="#进位制-OI-Wiki-oi-wiki-org" class="headerlink" title="进位制 - OI Wiki (oi-wiki.org)"></a><a href="https://oi-wiki.org/math/base/">进位制 - OI Wiki (oi-wiki.org)</a></h5><h5 id="就是取每个进制的余数，比如取得是二进制那么就是一直除2，然后得到余数，然后余数从下往上读。直到不能再除。"><a href="#就是取每个进制的余数，比如取得是二进制那么就是一直除2，然后得到余数，然后余数从下往上读。直到不能再除。" class="headerlink" title="就是取每个进制的余数，比如取得是二进制那么就是一直除2，然后得到余数，然后余数从下往上读。直到不能再除。"></a>就是取每个进制的余数，比如取得是二进制那么就是一直除2，然后得到余数，然后余数从下往上读。直到不能再除。</h5><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//这里就是用递归的方法</span><br><span class="hljs-keyword">if</span>(k&gt;=x)&#123;<br><span class="hljs-built_in">solve</span>(k/x);<br>k%=x;<span class="hljs-comment">//得到取余值</span><br><span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">10</span>)&#123;<span class="hljs-comment">//大于10就要考虑A这些字母的东西</span><br>cout&lt;&lt;<span class="hljs-built_in">char</span>(k<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;k;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不需要递归操作。</span><br><span class="hljs-keyword">if</span>(k&gt;=<span class="hljs-number">10</span>)&#123;<br>cout&lt;&lt;<span class="hljs-built_in">char</span>(k<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;x;<br><span class="hljs-built_in">solve</span>(n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B3620-x进制转换成十进制"><a href="#B3620-x进制转换成十进制" class="headerlink" title="B3620 x进制转换成十进制"></a>B3620 x进制转换成十进制</h4><h5 id="这里有个数学叫秦九韶算式多用于多项式操作和将各种进制转换成十进制"><a href="#这里有个数学叫秦九韶算式多用于多项式操作和将各种进制转换成十进制" class="headerlink" title="这里有个数学叫秦九韶算式多用于多项式操作和将各种进制转换成十进制"></a>这里有个数学叫秦九韶算式多用于多项式操作和将各种进制转换成十进制</h5><h5 id="对于秦九韶公式秦九韶算法-秦九韶算法公式详解-CSDN博客看完就知道原里。"><a href="#对于秦九韶公式秦九韶算法-秦九韶算法公式详解-CSDN博客看完就知道原里。" class="headerlink" title="对于秦九韶公式秦九韶算法_秦九韶算法公式详解-CSDN博客看完就知道原里。"></a>对于秦九韶公式<a href="https://blog.csdn.net/qq_52588437/article/details/123100562">秦九韶算法_秦九韶算法公式详解-CSDN博客</a>看完就知道原里。</h5><h5 id="然后再解题的时候给出的是一个字符串，然后字符串的第一位实际上是最高位，所有对于这个就是通过一个乘法和加法的循环不断操作。"><a href="#然后再解题的时候给出的是一个字符串，然后字符串的第一位实际上是最高位，所有对于这个就是通过一个乘法和加法的循环不断操作。" class="headerlink" title="然后再解题的时候给出的是一个字符串，然后字符串的第一位实际上是最高位，所有对于这个就是通过一个乘法和加法的循环不断操作。"></a>然后再解题的时候给出的是一个字符串，然后字符串的第一位实际上是最高位，所有对于这个就是通过一个乘法和加法的循环不断操作。</h5><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++">```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br>string s1;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s1,<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s1)&#123;<br><span class="hljs-keyword">if</span>(c&lt;<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<span class="hljs-comment">//就是没超过是</span><br>res = res*x+c-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//就是不断的×和+</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>res = res*x+c-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n;<br>cin&gt;&gt;s1;<br><span class="hljs-built_in">solve</span>(s1,n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>```</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寒假前端学习Day2(Vue)</title>
    <link href="/2024/01/30/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day2-Vue/"/>
    <url>/2024/01/30/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day2-Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="列表渲染（v-for）"><a href="#列表渲染（v-for）" class="headerlink" title="列表渲染（v-for）"></a>列表渲染（v-for）</h3><h5 id="基础操作就是先创建一个源数据的数组叫items，而item是迭代项的别名是在v-for中。"><a href="#基础操作就是先创建一个源数据的数组叫items，而item是迭代项的别名是在v-for中。" class="headerlink" title="基础操作就是先创建一个源数据的数组叫items，而item是迭代项的别名是在v-for中。"></a>基础操作就是先创建一个源数据的数组叫items，而item是迭代项的别名是在v-for中。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><h5 id="如果要使用v-for的index就要在v-for中说明"><a href="#如果要使用v-for的index就要在v-for中说明" class="headerlink" title="如果要使用v-for的index就要在v-for中说明"></a>如果要使用v-for的index就要在v-for中说明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125;<br>&lt;/li&gt;<br><br>&lt;!-- 有 index 索引时 --&gt;<br>&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;<br>  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><h4 id="v-for和对象"><a href="#v-for和对象" class="headerlink" title="v-for和对象"></a>v-for和对象</h4><h5 id="用v-for来遍历一个对象所有的属性值。"><a href="#用v-for来遍历一个对象所有的属性值。" class="headerlink" title="用v-for来遍历一个对象所有的属性值。"></a>用v-for来遍历一个对象所有的属性值。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br><br>import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>  <br><br>const myObject = reactive(&#123;<br><br>  title: &#x27;How to do lists in Vue&#x27;,<br><br>  author: &#x27;Jane Doe&#x27;,<br><br>  publishedAt: &#x27;2016-04-10&#x27;<br><br>&#125;)<br><br>&lt;/script&gt;<br><br>  <br><br>&lt;template&gt;<br><br>  &lt;ul&gt;<br><br>    &lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;<br><br>      &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br><br>    &lt;/li&gt;<br><br>  &lt;/ul&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h5><ul><li><ol><li>title: How to do lists in Vue</li></ol></li><li><ol><li>author: Jane Doe</li></ol></li><li><ol><li>publishedAt: 2016-04-10</li></ol></li></ul><h4 id="如果在v-for中使用范围值，-初值是从1开始而且不是0"><a href="#如果在v-for中使用范围值，-初值是从1开始而且不是0" class="headerlink" title="如果在v-for中使用范围值， 初值是从1开始而且不是0"></a>如果在v-for中使用范围值， 初值是从1开始而且不是0</h4><h5 id="一个比较完全的例子"><a href="#一个比较完全的例子" class="headerlink" title="一个比较完全的例子"></a>一个比较完全的例子</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs App.vue">&lt;script setup&gt;<br><br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>import TodoItem from &#x27;./TodoItem.vue&#x27;<br><br>const newTodoText = ref(&#x27;&#x27;)<br><br>const todos = ref([<br><br>  &#123;<br><br>    id: 1,<br><br>    title: &#x27;Do the dishes&#x27;<br><br>  &#125;,<br><br>  &#123;<br><br>    id: 2,<br><br>    title: &#x27;Take out the trash&#x27;<br><br>  &#125;,<br><br>  &#123;<br><br>    id: 3,<br><br>    title: &#x27;Mow the lawn&#x27;<br><br>  &#125;<br><br>])<br><br>  <br><br>let nextTodoId = 4<br><br>  <br><br>function addNewTodo() &#123;<br><br>  todos.value.push(&#123;<br><br>    id: nextTodoId++,<br><br>    title: newTodoText.value<br><br>  &#125;)<br><br>  newTodoText.value = &#x27;&#x27;<br><br>&#125;<br><br>&lt;/script&gt;<br><br>  <br><br>&lt;template&gt;<br><br>  &lt;form v-on:submit.prevent=&quot;addNewTodo&quot;&gt;<br><br>    &lt;label for=&quot;new-todo&quot;&gt;Add a todo&lt;/label&gt;<br><br>    &lt;input<br><br>      v-model=&quot;newTodoText&quot;<br><br>      id=&quot;new-todo&quot;<br><br>      placeholder=&quot;E.g. Feed the cat&quot;<br><br>    /&gt;<br><br>    &lt;button&gt;Add&lt;/button&gt;<br><br>  &lt;/form&gt;<br><br>  &lt;ul&gt;<br><br>    &lt;todo-item<br><br>      v-for=&quot;(todo, index) in todos&quot;<br><br>      :key=&quot;todo.id&quot;<br><br>      :title=&quot;todo.title&quot;<br><br>      @remove=&quot;todos.splice(index, 1)&quot;<br><br>    &gt;&lt;/todo-item&gt;<br><br>  &lt;/ul&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="注意add按钮并没有与form表单中submit进行绑定，因为prevent方法阻止了默认的表单提交行为，就会执行submitForm方法。而且button的默认方法在form里面就是submit"><a href="#注意add按钮并没有与form表单中submit进行绑定，因为prevent方法阻止了默认的表单提交行为，就会执行submitForm方法。而且button的默认方法在form里面就是submit" class="headerlink" title="注意add按钮并没有与form表单中submit进行绑定，因为prevent方法阻止了默认的表单提交行为，就会执行submitForm方法。而且button的默认方法在form里面就是submit"></a>注意add按钮并没有与form表单中submit进行绑定，因为prevent方法阻止了默认的表单提交行为，就会执行submitForm方法。而且button的默认方法在form里面就是submit</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs TodoItem.vue">&lt;script setup&gt;<br><br>defineProps([&#x27;title&#x27;])<br><br>defineEmits([&#x27;remove&#x27;])<br><br>&lt;/script&gt;<br><br>  <br><br>&lt;template&gt;<br><br>  &lt;li&gt;<br><br>    &#123;&#123; title &#125;&#125;<br><br>    &lt;button @click=&quot;$emit(&#x27;remove&#x27;)&quot;&gt;Remove&lt;/button&gt;<br><br>  &lt;/li&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="在代码中可以看出添加函数和删除函数的简单框架"><a href="#在代码中可以看出添加函数和删除函数的简单框架" class="headerlink" title="在代码中可以看出添加函数和删除函数的简单框架"></a>在代码中可以看出添加函数和删除函数的简单框架</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>// 给每个 todo 对象一个唯一的 id<br>let id = 0<br><br>const newTodo = ref(&#x27;&#x27;)<br>const todos = ref([<br>  &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,<br>  &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,<br>  &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;<br>])<br><br>function addTodo() &#123;<br>  todos.value.push(&#123; id: id++, text: newTodo.value &#125;)<br>  newTodo.value = &#x27;&#x27;<br>&#125;<br><br>function removeTodo(todo) &#123;<br>  todos.value = todos.value.filter((t) =&gt; t !== todo)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;<br>    &lt;input v-model=&quot;newTodo&quot;&gt;<br>    &lt;button&gt;Add Todo&lt;/button&gt;    <br>  &lt;/form&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;<br>      &#123;&#123; todo.text &#125;&#125;<br>      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, computed &#125; from &#x27;vue&#x27;<br><br>let id = 0<br><br>const newTodo = ref(&#x27;&#x27;)<br>const hideCompleted = ref(false)<br>const todos = ref([<br>  &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;,<br>  &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;,<br>  &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;<br>])<br><br>const filteredTodos = computed(() =&gt; &#123;<br>  return hideCompleted.value<br>    ? todos.value.filter((t) =&gt; !t.done)<br>    : todos.value<br>&#125;)<br><br>function addTodo() &#123;<br>  todos.value.push(&#123; id: id++, text: newTodo.value, done: false &#125;)<br>  newTodo.value = &#x27;&#x27;<br>&#125;<br><br>function removeTodo(todo) &#123;<br>  todos.value = todos.value.filter((t) =&gt; t !== todo)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;<br>    &lt;input v-model=&quot;newTodo&quot;&gt;<br>    &lt;button&gt;Add Todo&lt;/button&gt;<br>  &lt;/form&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;<br>      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;<br>      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;<br>      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;<br>    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;<br>  &lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br>.done &#123;<br>  text-decoration: line-through;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h5 id="filter-这个函数的作用是创建里面符合里面函数的数组。而且用与计算属性就是computed-这是一个新的API。"><a href="#filter-这个函数的作用是创建里面符合里面函数的数组。而且用与计算属性就是computed-这是一个新的API。" class="headerlink" title="filter()这个函数的作用是创建里面符合里面函数的数组。而且用与计算属性就是computed()这是一个新的API。"></a>filter()这个函数的作用是创建里面符合里面函数的数组。而且用与计算属性就是computed()这是一个新的API。</h5><h5 id="一些小东西的用处"><a href="#一些小东西的用处" class="headerlink" title="一些小东西的用处"></a>一些小东西的用处</h5><h5 id="todos-value-filter-t-gt-t-todo"><a href="#todos-value-filter-t-gt-t-todo" class="headerlink" title="todos.value.filter((t) =&gt; t !== todo)"></a>todos.value.filter((t) =&gt; t !== todo)</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">(<span class="hljs-built_in">t</span>) =&gt; <span class="hljs-built_in">t</span> !== todo实际上就是 <br>function(<span class="hljs-built_in">t</span>)&#123; return <span class="hljs-built_in">t</span> !==todo &#125;<br></code></pre></td></tr></table></figure><h5 id="而-号在比较到两者不同的值时候，如果遇到类型不同的时候，会尝试进行转换和-号就是如果不相同就不会比较。"><a href="#而-号在比较到两者不同的值时候，如果遇到类型不同的时候，会尝试进行转换和-号就是如果不相同就不会比较。" class="headerlink" title="而!=号在比较到两者不同的值时候，如果遇到类型不同的时候，会尝试进行转换和!== 号就是如果不相同就不会比较。"></a>而!=号在比较到两者不同的值时候，如果遇到类型不同的时候，会尝试进行转换和!== 号就是如果不相同就不会比较。</h5><h5 id="对于filter-来说"><a href="#对于filter-来说" class="headerlink" title="对于filter()来说"></a>对于filter()来说</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例说明</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> arr_new <br><span class="hljs-keyword">let</span> remove = <span class="hljs-number">3</span>;<br>arr_new = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item !== remove);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 输出 [1, 2, 3, 4, 5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr_new); <span class="hljs-comment">// 输出 [1, 2, 4, 5]</span><br><br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> remove2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr2 = arr2.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !remove2.<span class="hljs-title function_">includes</span>(item));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// 输出：[4,5]</span><br></code></pre></td></tr></table></figure><h5 id="对于computed-就是用于需要重新定义计算属性。所有如果是true就是第一个，就是所有未完成的项目，如果是第二个就是包含所有的代办选项。"><a href="#对于computed-就是用于需要重新定义计算属性。所有如果是true就是第一个，就是所有未完成的项目，如果是第二个就是包含所有的代办选项。" class="headerlink" title="对于computed()就是用于需要重新定义计算属性。所有如果是true就是第一个，就是所有未完成的项目，如果是第二个就是包含所有的代办选项。"></a>对于computed()就是用于需要重新定义计算属性。所有如果是true就是第一个，就是所有未完成的项目，如果是第二个就是包含所有的代办选项。</h5>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰式和快速幂</title>
    <link href="/2024/01/30/%E5%8D%A1%E7%89%B9%E5%85%B0%E5%BC%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2024/01/30/%E5%8D%A1%E7%89%B9%E5%85%B0%E5%BC%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h4 id="常用的应用场景："><a href="#常用的应用场景：" class="headerlink" title="常用的应用场景："></a>常用的应用场景：</h4><h5 id="1-括号匹配：有效的匹配方式，左括号数量不少于右括号数量。"><a href="#1-括号匹配：有效的匹配方式，左括号数量不少于右括号数量。" class="headerlink" title="1.括号匹配：有效的匹配方式，左括号数量不少于右括号数量。"></a>1.括号匹配：有效的匹配方式，左括号数量不少于右括号数量。</h5><hr><h5 id="2-计算具有几个节点的二叉搜索树。"><a href="#2-计算具有几个节点的二叉搜索树。" class="headerlink" title="2.计算具有几个节点的二叉搜索树。"></a>2.计算具有几个节点的二叉搜索树。</h5><hr><h5 id="3-路径问题：在一个n-n的网格中，计算从左上角到右下角的路径数量，条件只能向右或者向下，不能穿对角线。"><a href="#3-路径问题：在一个n-n的网格中，计算从左上角到右下角的路径数量，条件只能向右或者向下，不能穿对角线。" class="headerlink" title="3.路径问题：在一个n*n的网格中，计算从左上角到右下角的路径数量，条件只能向右或者向下，不能穿对角线。"></a>3.路径问题：在一个<code>n*n</code>的网格中，计算从左上角到右下角的路径数量，条件只能向右或者向下，不能穿对角线。</h5><hr><h5 id="4-堆栈序列：计算n个元素有效的堆栈进出序列，有效序列指，进栈元素大于出栈元素。"><a href="#4-堆栈序列：计算n个元素有效的堆栈进出序列，有效序列指，进栈元素大于出栈元素。" class="headerlink" title="4.堆栈序列：计算n个元素有效的堆栈进出序列，有效序列指，进栈元素大于出栈元素。"></a>4.堆栈序列：计算n个元素有效的堆栈进出序列，有效序列指，进栈元素大于出栈元素。</h5><hr><h5 id="5-凸多边形划分三角形：计算一个凸多边形可被划分成三角形数量。"><a href="#5-凸多边形划分三角形：计算一个凸多边形可被划分成三角形数量。" class="headerlink" title="5.凸多边形划分三角形：计算一个凸多边形可被划分成三角形数量。"></a>5.凸多边形划分三角形：计算一个凸多边形可被划分成三角形数量。</h5><h4 id="举例：比如三对括号的有效匹配方式式5个。凸五边形划分成五种三角形。"><a href="#举例：比如三对括号的有效匹配方式式5个。凸五边形划分成五种三角形。" class="headerlink" title="举例：比如三对括号的有效匹配方式式5个。凸五边形划分成五种三角形。"></a>举例：比如三对括号的有效匹配方式式5个。凸五边形划分成五种三角形。</h4><h5 id="卡兰特式-：H0-1-Hn-Hn-1-4n-2-n-1"><a href="#卡兰特式-：H0-1-Hn-Hn-1-4n-2-n-1" class="headerlink" title="卡兰特式 ：H0:1 Hn = Hn-1*(4n-2)/n+1"></a><em>卡兰特式</em> ：H0:1 Hn = Hn-1*(4n-2)/n+1</h5><h5 id="洛谷P1044"><a href="#洛谷P1044" class="headerlink" title="洛谷P1044"></a>洛谷P1044</h5><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><blockquote><p>栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。你的程序将对给定的 n，计算并输出由操作数列 1,2,…,n 经过操作可能得到的输出序列的总数。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>可以看出这个是要给出有效情况。所以是卡特兰式操作</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>f[i] = f[i<span class="hljs-number">-1</span>]*(<span class="hljs-number">4</span>*i<span class="hljs-number">-2</span>)/(i+<span class="hljs-number">1</span>);<br>&#125;<br>cout&lt;&lt;f[n]&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h4 id="题目：给你三个整数a-b-p，求-a-bmodp。"><a href="#题目：给你三个整数a-b-p，求-a-bmodp。" class="headerlink" title="题目：给你三个整数a,b,p，求 a^bmodp。"></a>题目：给你三个整数a,b,p，求 a^bmodp。</h4><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>^<span class="hljs-number">10</span> mod <span class="hljs-number">9</span>=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>这个就是快速幂取模,快速幂的操作就是将幂指数变成二进制，然后一直对于超过的数一直取模就行了。</p></blockquote><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quick_exp</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span></span>&#123;<span class="hljs-comment">//快速幂的操作。</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (res%p*a%p)%p;<br>a = (a%p*a%p)%p;<br>b&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res%p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a,b,p;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-built_in">quick_exp</span>(a,b,p);<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;^&#x27;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;<span class="hljs-string">&quot;mod &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&#x27;=&#x27;</span>&lt;&lt;ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS和BFS</title>
    <link href="/2024/01/29/DFS%E5%92%8CBFS/"/>
    <url>/2024/01/29/DFS%E5%92%8CBFS/</url>
    
    <content type="html"><![CDATA[<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h5 id="通过题目来对DFS回溯法进行了解"><a href="#通过题目来对DFS回溯法进行了解" class="headerlink" title="通过题目来对DFS回溯法进行了解"></a>通过题目来对DFS回溯法进行了解</h5><h5 id="给定一个整数-n，将数字-1∼n-排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。"><a href="#给定一个整数-n，将数字-1∼n-排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。" class="headerlink" title="给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。"></a>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。</h5><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N =<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> path[N];<span class="hljs-comment">//记录路径的数组</span><br><span class="hljs-type">int</span> state[N];<span class="hljs-comment">//判断是不是用了</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u&gt;n)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!state[i])&#123;<span class="hljs-comment">//如果这个数字没有被用</span><br>path[u] = i;<br>state[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//深搜</span><br>path[u] = <span class="hljs-number">0</span>;<span class="hljs-comment">//恢复现场</span><br>state[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="对于DFS我们可以看出这是一条路走到黑的，然后当我们碰壁后，就需要原路返回，也就是需要做到恢复现场的操作。也就是回到一开始的状态。"><a href="#对于DFS我们可以看出这是一条路走到黑的，然后当我们碰壁后，就需要原路返回，也就是需要做到恢复现场的操作。也就是回到一开始的状态。" class="headerlink" title="对于DFS我们可以看出这是一条路走到黑的，然后当我们碰壁后，就需要原路返回，也就是需要做到恢复现场的操作。也就是回到一开始的状态。"></a>对于DFS我们可以看出这是一条路走到黑的，然后当我们碰壁后，就需要原路返回，也就是需要做到恢复现场的操作。也就是回到一开始的状态。</h5><h4 id="bfs的基本操作，bfs是可以找到最短路径的，但是dfs是不一定能找到最短路径的。"><a href="#bfs的基本操作，bfs是可以找到最短路径的，但是dfs是不一定能找到最短路径的。" class="headerlink" title="bfs的基本操作，bfs是可以找到最短路径的，但是dfs是不一定能找到最短路径的。"></a>bfs的基本操作，bfs是可以找到最短路径的，但是dfs是不一定能找到最短路径的。</h4><h4 id="题目-走迷宫"><a href="#题目-走迷宫" class="headerlink" title="题目 走迷宫"></a>题目 走迷宫</h4><h4 id="给定一个-n×m的二维整数数组，用来表示一个迷宫，数组中只包含-0-或-1，其中-0-表示可以走的路，1-表示不可通过的墙壁。最初，有一个人位于左上角-1-1-1-1-处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角-n-m-处，至少需要移动多少次。数据保证-1-1-处和-n-m-处的数字为-0，且一定至少存在一条通路"><a href="#给定一个-n×m的二维整数数组，用来表示一个迷宫，数组中只包含-0-或-1，其中-0-表示可以走的路，1-表示不可通过的墙壁。最初，有一个人位于左上角-1-1-1-1-处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角-n-m-处，至少需要移动多少次。数据保证-1-1-处和-n-m-处的数字为-0，且一定至少存在一条通路" class="headerlink" title="给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。最初，有一个人位于左上角 (1,1)(1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。数据保证(1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路"></a>给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。最初，有一个人位于左上角 (1,1)(1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。数据保证(1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路</h4><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><hr><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//存储地图</span><br><span class="hljs-type">int</span> f[N][N];<span class="hljs-comment">//存储距离</span><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>queue&lt;PII&gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;a,b&#125;);<span class="hljs-comment">//横坐标和纵坐标</span><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>PII start = q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//读取队列顶端的</span><br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//四个方向下，右，上，左</span><br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br><span class="hljs-type">int</span> x = start.first+dx[i];<br><span class="hljs-type">int</span> y = start.second+dy[i];<br><span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果没有找到就走过去</span><br>g[x][y] = <span class="hljs-number">1</span>;<br>f[x][y] = f[start.first][start.second]+<span class="hljs-number">1</span>;<span class="hljs-comment">//距离加1</span><br>q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;f[n][m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(g));<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;g[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="所以BFS是操作是用队列来存储，首先存储要开始的地方，然后读取队列顶端，然后往下走，走到下一个不是1的位置然后就可以读入队列中，并且将走过0的位置标记成1。"><a href="#所以BFS是操作是用队列来存储，首先存储要开始的地方，然后读取队列顶端，然后往下走，走到下一个不是1的位置然后就可以读入队列中，并且将走过0的位置标记成1。" class="headerlink" title="所以BFS是操作是用队列来存储，首先存储要开始的地方，然后读取队列顶端，然后往下走，走到下一个不是1的位置然后就可以读入队列中，并且将走过0的位置标记成1。"></a>所以BFS是操作是用队列来存储，首先存储要开始的地方，然后读取队列顶端，然后往下走，走到下一个不是1的位置然后就可以读入队列中，并且将走过0的位置标记成1。</h5>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寒假学习day1(Vue)</title>
    <link href="/2024/01/28/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0day1-Vue/"/>
    <url>/2024/01/28/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0day1-Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="一，声明式渲染"><a href="#一，声明式渲染" class="headerlink" title="一，声明式渲染"></a>一，声明式渲染</h3><h5 id="1-关于组合式api，通常会和script-setup-搭配使用"><a href="#1-关于组合式api，通常会和script-setup-搭配使用" class="headerlink" title="1. 关于组合式api，通常会和script setup 搭配使用"></a>1. 关于组合式api，通常会和script setup 搭配使用</h5><h5 id="2-在script中，使用ref或者reactive来声明响应式状态"><a href="#2-在script中，使用ref或者reactive来声明响应式状态" class="headerlink" title="2.在script中，使用ref或者reactive来声明响应式状态"></a>2.在script中，使用ref或者reactive来声明响应式状态</h5><hr><h5 id="3-在script中，将组件声明，并且有组件逻辑和其他一些响应式状态。"><a href="#3-在script中，将组件声明，并且有组件逻辑和其他一些响应式状态。" class="headerlink" title="3.在script中，将组件声明，并且有组件逻辑和其他一些响应式状态。"></a>3.在script中，将组件声明，并且有组件逻辑和其他一些响应式状态。</h5><hr><h5 id="4-然后在template中对调取对应的响应式状态的值来进行文本渲染"><a href="#4-然后在template中对调取对应的响应式状态的值来进行文本渲染" class="headerlink" title="4.然后在template中对调取对应的响应式状态的值来进行文本渲染"></a>4.然后在template中对调取对应的响应式状态的值来进行文本渲染</h5><hr><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive, ref &#125; from &#x27;vue&#x27;<br><br>const counter = reactive(&#123; count: 0 &#125;)<br>const message = ref(&#x27;Hello World!&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;<br>  &lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="二，Attribute绑定"><a href="#二，Attribute绑定" class="headerlink" title="二，Attribute绑定"></a>二，Attribute绑定</h3><h5 id="1-在template中为了给attribute绑定一个动态值，一般都是需要v-bind指令-而且可以进行缩写"><a href="#1-在template中为了给attribute绑定一个动态值，一般都是需要v-bind指令-而且可以进行缩写" class="headerlink" title="1.在template中为了给attribute绑定一个动态值，一般都是需要v-bind指令,而且可以进行缩写"></a>1.在template中为了给attribute绑定一个动态值，一般都是需要v-bind指令,而且可以进行缩写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;//未缩写<br>&lt;div :id=&quot;dynamicId&quot;&lt;/div&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="2-还有bool型，当-isButtonDisabled-为真值或一个空字符串-即-lt-button-disabled-quot-quot-gt-时，元素会包含这个-disabled-attribute。而当其为其他假值时-attribute-将被忽略。"><a href="#2-还有bool型，当-isButtonDisabled-为真值或一个空字符串-即-lt-button-disabled-quot-quot-gt-时，元素会包含这个-disabled-attribute。而当其为其他假值时-attribute-将被忽略。" class="headerlink" title="2.还有bool型，当 isButtonDisabled 为真值或一个空字符串 (即 &lt;button disabled=&quot;&quot;&gt;) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。"></a>2.还有bool型，当 <code>isButtonDisabled</code> 为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">真值</a>或一个空字符串 (即 <code>&lt;button disabled=&quot;&quot;&gt;</code>) 时，元素会包含这个 <code>disabled</code> attribute。而当其为其他<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">假值</a>时 attribute 将被忽略。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="3-动态绑定多个值"><a href="#3-动态绑定多个值" class="headerlink" title="3.动态绑定多个值"></a>3.动态绑定多个值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> objectOfAttrs = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;container&#x27;</span>,<br>  <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;wrapper&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通过不带参数的-v-bind，你可以将它们绑定到单个元素上："><a href="#通过不带参数的-v-bind，你可以将它们绑定到单个元素上：" class="headerlink" title="通过不带参数的 v-bind，你可以将它们绑定到单个元素上："></a>通过不带参数的 <code>v-bind</code>，你可以将它们绑定到单个元素上：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="4-v-if-指令会基于表达式-seen-的值的真假来移除-插入该-lt-p-gt-元素。"><a href="#4-v-if-指令会基于表达式-seen-的值的真假来移除-插入该-lt-p-gt-元素。" class="headerlink" title="4.v-if 指令会基于表达式 seen 的值的真假来移除/插入该 &lt;p&gt; 元素。"></a>4.<code>v-if</code> 指令会基于表达式 <code>seen</code> 的值的真假来移除/插入该 <code>&lt;p&gt;</code> 元素。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="5-href-就是一个参数，它告诉-v-bind-指令将表达式-url-的值绑定到元素的-href-attribute-上。在简写中，参数前的一切-例如-v-bind-都会被缩略为一个-字符"><a href="#5-href-就是一个参数，它告诉-v-bind-指令将表达式-url-的值绑定到元素的-href-attribute-上。在简写中，参数前的一切-例如-v-bind-都会被缩略为一个-字符" class="headerlink" title="5.href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符"></a>5.<code>href</code> 就是一个参数，它告诉 <code>v-bind</code> 指令将表达式 <code>url</code> 的值绑定到元素的 <code>href</code> attribute 上。在简写中，参数前的一切 (例如 <code>v-bind:</code>) 都会被缩略为一个 <code>:</code> 字符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure><hr><h5 id="6-监听DOM时间-v-on指令"><a href="#6-监听DOM时间-v-on指令" class="headerlink" title="6.监听DOM时间 v-on指令"></a>6.监听DOM时间 <code>v-on</code>指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;//v-on缩写就是@<br></code></pre></td></tr></table></figure><hr><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const titleClass = ref(&#x27;title&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;h1 v-bind:class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt; &lt;!-- 此处添加一个动态 class 绑定 --&gt;<br>&lt;/template&gt;<br><br>&lt;style&gt;<br>.title &#123;<br>  color: red;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="三，事件监听"><a href="#三，事件监听" class="headerlink" title="三，事件监听"></a>三，事件监听</h3><h5 id="1-用v-on进行监听，简写语法和用法上面提到过。"><a href="#1-用v-on进行监听，简写语法和用法上面提到过。" class="headerlink" title="1.用v-on进行监听，简写语法和用法上面提到过。"></a>1.用<code>v-on</code>进行监听，简写语法和用法上面提到过。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const count = ref(0)<br><br>function increment() &#123;<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="实现-increment-函数并通过使用-v-on-将其绑定到按钮上。这种就是内联事件处理器，一般用于简单场景。"><a href="#实现-increment-函数并通过使用-v-on-将其绑定到按钮上。这种就是内联事件处理器，一般用于简单场景。" class="headerlink" title="实现 increment 函数并通过使用 v-on 将其绑定到按钮上。这种就是内联事件处理器，一般用于简单场景。"></a>实现 <code>increment</code> 函数并通过使用 <code>v-on</code> 将其绑定到按钮上。这种就是内联事件处理器，一般用于简单场景。</h5><hr><h5 id="2-方法事件处理器"><a href="#2-方法事件处理器" class="headerlink" title="2.方法事件处理器"></a>2.方法事件处理器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br><br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>  <br><br>const name = ref(&#x27;Vue.js&#x27;)<br><br>  <br><br>function greet(event) &#123;<br><br>  alert(`Hello $&#123;name.value&#125;!`)<br><br>  // `event` is the native DOM event<br><br>  if (event) &#123;<br><br>    alert(event.target.tagName)<br><br>  &#125;<br><br>&#125;<br><br>&lt;/script&gt;<br><br>  <br><br>&lt;template&gt;<br><br>  &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="方法事件处理器会自动接收原生-DOM-事件并触发执行。在上面的例子中，我们能够通过被触发事件的-event-target-tagName-访问到该-DOM-元素。"><a href="#方法事件处理器会自动接收原生-DOM-事件并触发执行。在上面的例子中，我们能够通过被触发事件的-event-target-tagName-访问到该-DOM-元素。" class="headerlink" title="方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target.tagName 访问到该 DOM 元素。"></a>方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 <code>event.target.tagName</code> 访问到该 DOM 元素。</h5><hr><h5 id="3-在内联事件处理器中访问事件参数"><a href="#3-在内联事件处理器中访问事件参数" class="headerlink" title="3.在内联事件处理器中访问事件参数"></a>3.在内联事件处理器中访问事件参数</h5><h5 id="有时我们需要在内联事件处理器中访问原生-DOM-事件。你可以向该处理器方法传入一个特殊的-event-变量，或者使用内联箭头函数："><a href="#有时我们需要在内联事件处理器中访问原生-DOM-事件。你可以向该处理器方法传入一个特殊的-event-变量，或者使用内联箭头函数：" class="headerlink" title="有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数："></a>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 使用特殊的 $event 变量 --&gt;<br>&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;<br>  Submit<br>&lt;/button&gt;<br><br>&lt;!-- 使用内联箭头函数 --&gt;<br>&lt;button @click=&quot;(event) =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, event)&quot;&gt;<br>  Submit<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123; <span class="hljs-comment">// 这里可以访问原生事件 </span><br><span class="hljs-keyword">if</span> (event) &#123; event.<span class="hljs-title function_">preventDefault</span>() &#125; <span class="hljs-title function_">alert</span>(message) &#125;<br></code></pre></td></tr></table></figure><h4 id="所以看出想要进行事件访问，funtion中有一个参数是event"><a href="#所以看出想要进行事件访问，funtion中有一个参数是event" class="headerlink" title="所以看出想要进行事件访问，funtion中有一个参数是event"></a>所以看出想要进行事件访问，funtion中有一个参数是event</h4><h5 id="还有一系列按键操作，就不赘述。"><a href="#还有一系列按键操作，就不赘述。" class="headerlink" title="还有一系列按键操作，就不赘述。"></a>还有一系列按键操作，就不赘述。</h5><h3 id="四，表单绑定"><a href="#四，表单绑定" class="headerlink" title="四，表单绑定"></a>四，表单绑定</h3><h4 id="就是v-model操作"><a href="#就是v-model操作" class="headerlink" title="就是v-model操作"></a>就是v-model操作</h4><h5 id="v-mode操作可以支持文本输入框或者多选框，下拉框等等。"><a href="#v-mode操作可以支持文本输入框或者多选框，下拉框等等。" class="headerlink" title="v-mode操作可以支持文本输入框或者多选框，下拉框等等。"></a>v-mode操作可以支持文本输入框或者多选框，下拉框等等。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const text = ref(&#x27;&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;<br>  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;!--这样文本内容就可以同步显示---&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="还有更多例子在官网上看即可"><a href="#还有更多例子在官网上看即可" class="headerlink" title="还有更多例子在官网上看即可"></a>还有更多例子在官网上看即可</h4><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><h5 id="v-if就是当指令的表达式为真的时候才会返回里面的值"><a href="#v-if就是当指令的表达式为真的时候才会返回里面的值" class="headerlink" title="v-if就是当指令的表达式为真的时候才会返回里面的值"></a>v-if就是当指令的表达式为真的时候才会返回里面的值</h5><h5 id="v-else就是当指令为假返回值"><a href="#v-else就是当指令为假返回值" class="headerlink" title="v-else就是当指令为假返回值"></a>v-else就是当指令为假返回值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br><br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>  <br><br>const awesome = ref(true)<br><br>&lt;/script&gt;<br><br>  <br><br>&lt;template&gt;<br><br>  &lt;button @click=&quot;awesome = !awesome&quot;&gt;toggle&lt;/button&gt;<br>  &lt;!--点击一次按钮awesome变成相反的值&gt;<br>  <br><br>  &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br> <br><br>  &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="这可以实现点击按钮进行切换"><a href="#这可以实现点击按钮进行切换" class="headerlink" title="这可以实现点击按钮进行切换"></a>这可以实现点击按钮进行切换</h5><h5 id="v-show简单，如果需要频繁切换那么v-show好一点"><a href="#v-show简单，如果需要频繁切换那么v-show好一点" class="headerlink" title="v-show简单，如果需要频繁切换那么v-show好一点"></a>v-show简单，如果需要频繁切换那么v-show好一点</h5><h5 id="如果运行时绑定条件很少改变v-if好"><a href="#如果运行时绑定条件很少改变v-if好" class="headerlink" title="如果运行时绑定条件很少改变v-if好"></a>如果运行时绑定条件很少改变v-if好</h5>]]></content>
    
    
    
    <tags>
      
      <tag>前端学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟2</title>
    <link href="/2024/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F2/"/>
    <url>/2024/01/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F2/</url>
    
    <content type="html"><![CDATA[<h4 id="小蓝每天都锻炼身体。正常情况下-小蓝每天跑1千米。如果某天是周一或者月初-1日-为了激励自己-小蓝要跑2千米。如果同时是周一或月初-小蓝也是跑2千米。小蓝跑步已经坚持了很长时间-从2000年1月1日周六-含-到2020年10月1日周四-含-。请问这段时间小蓝总共跑步多少千米"><a href="#小蓝每天都锻炼身体。正常情况下-小蓝每天跑1千米。如果某天是周一或者月初-1日-为了激励自己-小蓝要跑2千米。如果同时是周一或月初-小蓝也是跑2千米。小蓝跑步已经坚持了很长时间-从2000年1月1日周六-含-到2020年10月1日周四-含-。请问这段时间小蓝总共跑步多少千米" class="headerlink" title="小蓝每天都锻炼身体。正常情况下,小蓝每天跑1千米。如果某天是周一或者月初(1日),为了激励自己,小蓝要跑2千米。如果同时是周一或月初,小蓝也是跑2千米。小蓝跑步已经坚持了很长时间,从2000年1月1日周六(含)到2020年10月1日周四(含)。请问这段时间小蓝总共跑步多少千米?"></a>小蓝每天都锻炼身体。正常情况下,小蓝每天跑1千米。如果某天是周一或者月初(1日),为了激励自己,小蓝要跑2千米。如果同时是周一或月初,小蓝也是跑2千米。小蓝跑步已经坚持了很长时间,从2000年1月1日周六(含)到2020年10月1日周四(含)。请问这段时间小蓝总共跑步多少千米?</h4><h5 id="题目解析：从一月一日开始，如果是闰年就要让二月变成29天，然后计数的时候对周一和每月一号进行特判，然后到截止日期就停止，并且返回输出的数字。"><a href="#题目解析：从一月一日开始，如果是闰年就要让二月变成29天，然后计数的时候对周一和每月一号进行特判，然后到截止日期就停止，并且返回输出的数字。" class="headerlink" title="题目解析：从一月一日开始，如果是闰年就要让二月变成29天，然后计数的时候对周一和每月一号进行特判，然后到截止日期就停止，并且返回输出的数字。"></a>题目解析：从一月一日开始，如果是闰年就要让二月变成29天，然后计数的时候对周一和每月一号进行特判，然后到截止日期就停止，并且返回输出的数字。</h5><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br>void solve()&#123;<br><br><span class="hljs-type">int</span> months[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;;<br><br><span class="hljs-type">int</span> year,month,day;<br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">for</span>(year=<span class="hljs-number">2000</span>;year&lt;=<span class="hljs-number">2020</span>;year++)&#123;<br><br><span class="hljs-keyword">if</span>(year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>||(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>))&#123;<br><br>months[<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>;<br><br>&#125;<br><br><span class="hljs-keyword">else</span> months[<span class="hljs-number">2</span>] = <span class="hljs-number">28</span>;<br><br><span class="hljs-keyword">for</span>(month=<span class="hljs-number">1</span>;month&lt;=<span class="hljs-number">12</span>;month++)&#123;<br><br><span class="hljs-keyword">for</span>(day=<span class="hljs-number">1</span>;day&lt;=months[month];day++)&#123;<br><br>cnt++;<br><br><span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">7</span>) ans=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span>(ans==<span class="hljs-number">1</span>||day==<span class="hljs-number">1</span>)&#123;<br><br>cnt++;<br><br>&#125;<br><br>ans++;<br><br><span class="hljs-keyword">if</span>(year==<span class="hljs-number">2020</span>&amp;&amp;month==<span class="hljs-number">10</span>&amp;&amp;day==<span class="hljs-number">1</span>)&#123;<br><br>cout&lt;&lt;cnt;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="货物摆放"><a href="#货物摆放" class="headerlink" title="货物摆放"></a>货物摆放</h4><h4 id="题目：题目描述"><a href="#题目：题目描述" class="headerlink" title="题目：题目描述"></a>题目：题目描述</h4><p>小蓝有一个超大的仓库,可以摆放很多货物。</p><p>现在,小蓝有n箱货物要摆放在仓库,每箱货物都是规则的正方体。小蓝规定了长、宽、高<br>三个互相垂直的方向,每箱货物的边都必须严格平行于长、宽、高。</p><p>小蓝希望所有的货物最终摆成一个大的长方体。即在长、宽、高的方向上分别堆L、W、<br>H的货物,满足n=LxWxH。</p><p>给定n,请问有多少种堆放货物的方案满足要求。</p><p>例如,当n=4时,有以下6种方案:1×1×4、1×2×2、1×4×1、2×1x<br>2、2×2×1、4×1×1.</p><p>请问,当n=2021041820210418 (注意有16位数字)时,总共有多少种方案?</p><p>提示:建议使用计算机编程解决问题。</p><h4 id="问题解析："><a href="#问题解析：" class="headerlink" title="问题解析："></a>问题解析：</h4><blockquote><p>如果纯暴力会t，就是一个先找到约数，找到约数然后对约数进行三重循环然后找到能够能够对应的就情况数加1，约数的找就是从小开始，只要找到小的约数，然后在找相乘的另外一个大的约数即可。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e7</span>+<span class="hljs-number">10</span>;<br><br>long long n = <span class="hljs-number">2021041820210418</span>;<br><br>long long arr[N];<br><br>void solve()&#123;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br>ll i = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//找约数</span><br><br>ll cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>;i*i&lt;=n;i++)&#123;<br><br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br><br>arr[cnt] = i;<br><br>cnt++;<br><br><span class="hljs-keyword">if</span>(n/i!=i)&#123;<br><br>arr[cnt] = n/i;<br><br>cnt++;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span>(ll a = <span class="hljs-number">0</span>;a&lt;cnt;a++)&#123;<br><br><span class="hljs-keyword">for</span>(ll b = <span class="hljs-number">0</span>;b&lt;cnt;b++)&#123;<br><br><span class="hljs-keyword">for</span>(ll c = <span class="hljs-number">0</span>;c&lt;cnt;c++)&#123;<br><br><span class="hljs-keyword">if</span>(arr[a]*arr[b]*arr[c]==n)&#123;<br><br>ans++;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>cout&lt;&lt;ans;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br>  <br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特别数的和"><a href="#特别数的和" class="headerlink" title="特别数的和"></a>特别数的和</h4><h4 id="题目：题目描述-1"><a href="#题目：题目描述-1" class="headerlink" title="题目：题目描述"></a>题目：题目描述</h4><p>小明对数位中含有2、0、1、9的数字很感兴趣(不包括前导0),在1到40中这样的<br>数包括1、2、9、10至32、39和40,共28个,他们的和是574。</p><p>请问,在1到n中,所有这样的数的和是多少?</p><p>输入描述</p><p>输入格式:</p><p>输入一行包含两个整数n(1≤n≤104)。</p><p>输出描述</p><p>输出一行,包含一个整数,表示满足条件的数的和。</p><h4 id="题目解析：只需要找到对每个数的每一位数进行取模运算，然后看每一位数是不是符合上面题目的条件。有就计数器加1"><a href="#题目解析：只需要找到对每个数的每一位数进行取模运算，然后看每一位数是不是符合上面题目的条件。有就计数器加1" class="headerlink" title="题目解析：只需要找到对每个数的每一位数进行取模运算，然后看每一位数是不是符合上面题目的条件。有就计数器加1"></a>题目解析：只需要找到对每个数的每一位数进行取模运算，然后看每一位数是不是符合上面题目的条件。有就计数器加1</h4><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">bool</span> check(<span class="hljs-type">int</span> n)&#123;<br><br>  while(n)&#123;<br><br>    <span class="hljs-type">int</span> s = n%<span class="hljs-number">10</span>;<br><br>    n/=<span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">1</span>||s==<span class="hljs-number">2</span>||s==<span class="hljs-number">9</span>||s==<span class="hljs-number">0</span>)&#123;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br>void solve()&#123;<br><br>  <span class="hljs-type">int</span> num;<br><br>  cin&gt;&gt;num;<br><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=num;i++)&#123;<br><br>    <span class="hljs-keyword">if</span>(check(i)) ans+=i;<br><br>  &#125;<br><br>  cout&lt;&lt;ans;<br><br>  <span class="hljs-keyword">return</span>;<br><br>&#125;<br><br>  <br><br><span class="hljs-type">int</span> main()&#123;<br><br>    ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>    solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="天干地支"><a href="#天干地支" class="headerlink" title="天干地支"></a>天干地支</h4><h4 id="题目描述：古代中国使用天干地支来记录当前的年份。"><a href="#题目描述：古代中国使用天干地支来记录当前的年份。" class="headerlink" title="题目描述：古代中国使用天干地支来记录当前的年份。"></a>题目描述：古代中国使用天干地支来记录当前的年份。</h4><p>天干一共有十个,分别为:甲(jia)、乙(yi)、丙(bing)、丁(ding)、戊(wù)、<br>己(ji)、庚(gēng)、辛(xin)、壬(rén)、癸(gui)。</p><p>地支一共有十二个,分别为:子(zi)、丑(chou)、寅(yin)、卯(mao)、辰<br>(chén)、巳(si)、午(wu)、未(wèi)、申(shen)、酉(yǒu)、戌(xū)、亥<br>(hài) .</p><p>将天干和地支连起来,就组成了一个天干地支的年份,例如:甲子。</p><p>2020年是庚子年。</p><p>每过一年,天干和地支都会移动到下一个。例如2021年是辛丑年。</p><p>每过60年,天干会循环6轮,地支会循环5轮,所以天干地支纪年每60年轮回一次。<br>例如1900年,1960年,2020年都是庚子年。</p><p>给定一个公元纪年的年份,请输出这一年的天干地支年份。</p><h4 id="解析：2020年模10，就可以知道天干的顺序是从庚开始的，然后模12就可以知道4是子，然后往下就是从0-11的顺序了，所以我们可以手动打表将这些东西排序好。"><a href="#解析：2020年模10，就可以知道天干的顺序是从庚开始的，然后模12就可以知道4是子，然后往下就是从0-11的顺序了，所以我们可以手动打表将这些东西排序好。" class="headerlink" title="解析：2020年模10，就可以知道天干的顺序是从庚开始的，然后模12就可以知道4是子，然后往下就是从0-11的顺序了，所以我们可以手动打表将这些东西排序好。"></a>解析：2020年模10，就可以知道天干的顺序是从庚开始的，然后模12就可以知道4是子，然后往下就是从0-11的顺序了，所以我们可以手动打表将这些东西排序好。</h4><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br>void solve()&#123;<br><br>  <br><br>    <span class="hljs-type">int</span> year;<br><br>    std::cin &gt;&gt; year;<br><br>    std::<span class="hljs-type">string</span> heavenly[<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;geng&quot;</span>, <span class="hljs-string">&quot;xin&quot;</span>, <span class="hljs-string">&quot;ren&quot;</span>, <span class="hljs-string">&quot;gui&quot;</span>, <span class="hljs-string">&quot;jia&quot;</span>, <span class="hljs-string">&quot;yi&quot;</span> , <span class="hljs-string">&quot;bing&quot;</span>, <span class="hljs-string">&quot;ding&quot;</span>, <span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;ji&quot;</span>&#125;;<br><br>    std::<span class="hljs-type">string</span> earthlyBranch[<span class="hljs-number">12</span>] = &#123;<span class="hljs-string">&quot;shen&quot;</span>, <span class="hljs-string">&quot;you&quot;</span>, <span class="hljs-string">&quot;xu&quot;</span>, <span class="hljs-string">&quot;hai&quot;</span>, <span class="hljs-string">&quot;zi&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>, <span class="hljs-string">&quot;yin&quot;</span>, <span class="hljs-string">&quot;mou&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>, <span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;wei&quot;</span>&#125;;<br><br>  <br><br>    std::cout &lt;&lt; heavenly[year % <span class="hljs-number">10</span>] &lt;&lt; earthlyBranch[year % <span class="hljs-number">12</span>] &lt;&lt; std::endl;<br><br>  <br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>    ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>  solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>模拟章节就结束，难度不大</p>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟</title>
    <link href="/2024/01/25/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F/"/>
    <url>/2024/01/25/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h3><h5 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h5><p>小蓝有很多数字卡片，每张卡片上都是一个数字（0 到 9）。<br>小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，就保存起<br>来，卡片就不能用来拼其他数了。<br>小蓝想知道自己能从 1 拼到多少。<br>例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼<br>11 时卡片 1 已经只有一张了，不够拼出 11。<br>现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到<br>多少?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>可以看出第一个花完的数字是1，所以所以我们只需要暴力模拟，将每个的数的每一位数对十取模得到每位数，然后是1就减，见到1的牌数为0。但是需要注意的是最终的结果需要减1，因为在我的代码中加多了一次因为最后判定的一次。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">2021</span>;<br><br>  <br><br>void solve()&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;;i++)&#123;<br><br><span class="hljs-type">int</span> b = i;<br><br>while(b)&#123;<br><br><span class="hljs-type">int</span> t = b%<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)&#123;<br><br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><br>cout&lt;&lt;i<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br><span class="hljs-keyword">else</span> cnt--;<br><br>&#125;<br><br>b/=<span class="hljs-number">10</span>;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="赢球票"><a href="#赢球票" class="headerlink" title="赢球票"></a>赢球票</h3><h4 id="【问题描述】-1"><a href="#【问题描述】-1" class="headerlink" title="【问题描述】"></a>【问题描述】</h4><p>某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。<br>主持人拿出 N 张卡片（上面写着 1, . . . , N 的数字），打乱顺序，排成一个圆圈。<br>你可以从任意一张卡片开始顺时针数数: 1, 2, 3 . . .<br>如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一张卡片重<br>新数数。<br>直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。<br>比如卡片排列是 1 2 3，我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，<br>但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。因此这次我们<br>只赢得了 1 张球票。<br>还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不<br>到了。<br>如果运气好，卡片排列是 2 1 3，那我们可以顺利拿到所有的卡片！<br>本题目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就<br>是收入囊中的卡片数字之和）。</p><h4 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h4><p>第一行一个整数 N (N ⩽ 100)，表示卡片数目。<br>第二行 N 个整数，表示顺时针排列的卡片。</p><h4 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h4><p>输出一行，一个整数，表示最好情况下能赢得多少张球票。</p><h4 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h4><p>3<br>1 2 3</p><h4 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h4><p>1</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><blockquote><p>就是会成一个环，如果没有找到对应的数字，就往下走，并且数到的数字加1，如果还没有就继续重复操作，直到数到的数字大于卡片里的最大值，但是如果找到对应的卡片后，数到的数字就归1，重新开始循环。所以结束的要求是：成功的是全部都找到，失败就是数到的数字大过卡牌的数字，这两种情况都会导致程序结束。<br>题目还有要求是找到最优情况，所以暴力模拟的话就是通过对卡片每一个位置开始数，找到能拿到最多牌的情况。</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> a[N];<br><br>void solve()&#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin&gt;&gt;n;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//模拟全部情况</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> pos = i;<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> flag[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>while(<span class="hljs-number">1</span>)&#123;<br><br><span class="hljs-comment">//全部取走或者函数</span><br><br><span class="hljs-keyword">if</span>(count==n||num&gt;n) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">//卡片被取走</span><br><br><span class="hljs-keyword">if</span>(flag[pos])&#123;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos=<span class="hljs-number">1</span>;<span class="hljs-comment">//也就是循环到开头</span><br><br>&#125;<br><br><span class="hljs-comment">//取走卡片</span><br><br><span class="hljs-keyword">else</span>&#123;<br><br><span class="hljs-keyword">if</span>(a[pos]==num)&#123;<br><br>res+=a[pos];<br><br>flag[pos]=<span class="hljs-number">1</span>;<br><br>count++;<br><br>num=<span class="hljs-number">1</span>;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos = <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-keyword">else</span>&#123;<br><br>num++;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos = <span class="hljs-number">1</span>;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(res&gt;ans) ans = res;<span class="hljs-comment">//找到最优解</span><br><br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯枚举模拟-1</title>
    <link href="/2024/01/25/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%9E%9A%E4%B8%BE%E6%A8%A1%E6%8B%9F-1/"/>
    <url>/2024/01/25/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%9E%9A%E4%B8%BE%E6%A8%A1%E6%8B%9F-1/</url>
    
    <content type="html"><![CDATA[<h3 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h3><h5 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h5><p>小蓝有很多数字卡片，每张卡片上都是一个数字（0 到 9）。<br>小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，就保存起<br>来，卡片就不能用来拼其他数了。<br>小蓝想知道自己能从 1 拼到多少。<br>例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，但是拼<br>11 时卡片 1 已经只有一张了，不够拼出 11。<br>现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到<br>多少?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>可以看出第一个花完的数字是1，所以所以我们只需要暴力模拟，将每个的数的每一位数对十取模得到每位数，然后是1就减，见到1的牌数为0。但是需要注意的是最终的结果需要减1，因为在我的代码中加多了一次因为最后判定的一次。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">2021</span>;<br><br>  <br><br>void solve()&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;;i++)&#123;<br><br><span class="hljs-type">int</span> b = i;<br><br>while(b)&#123;<br><br><span class="hljs-type">int</span> t = b%<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)&#123;<br><br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><br>cout&lt;&lt;i<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br><span class="hljs-keyword">else</span> cnt--;<br><br>&#125;<br><br>b/=<span class="hljs-number">10</span>;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="赢球票"><a href="#赢球票" class="headerlink" title="赢球票"></a>赢球票</h3><h4 id="【问题描述】-1"><a href="#【问题描述】-1" class="headerlink" title="【问题描述】"></a>【问题描述】</h4><p>某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。<br>主持人拿出 N 张卡片（上面写着 1, . . . , N 的数字），打乱顺序，排成一个圆圈。<br>你可以从任意一张卡片开始顺时针数数: 1, 2, 3 . . .<br>如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一张卡片重<br>新数数。<br>直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。<br>比如卡片排列是 1 2 3，我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，<br>但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。因此这次我们<br>只赢得了 1 张球票。<br>还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不<br>到了。<br>如果运气好，卡片排列是 2 1 3，那我们可以顺利拿到所有的卡片！<br>本题目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就<br>是收入囊中的卡片数字之和）。</p><h4 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h4><p>第一行一个整数 N (N ⩽ 100)，表示卡片数目。<br>第二行 N 个整数，表示顺时针排列的卡片。</p><h4 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h4><p>输出一行，一个整数，表示最好情况下能赢得多少张球票。</p><h4 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h4><p>3<br>1 2 3</p><h4 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h4><p>1</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><blockquote><p>就是会成一个环，如果没有找到对应的数字，就往下走，并且数到的数字加1，如果还没有就继续重复操作，直到数到的数字大于卡片里的最大值，但是如果找到对应的卡片后，数到的数字就归1，重新开始循环。所以结束的要求是：成功的是全部都找到，失败就是数到的数字大过卡牌的数字，这两种情况都会导致程序结束。<br>题目还有要求是找到最优情况，所以暴力模拟的话就是通过对卡片每一个位置开始数，找到能拿到最多牌的情况。</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go">#include&lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> a[N];<br><br>void solve()&#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin&gt;&gt;n;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//模拟全部情况</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> pos = i;<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> flag[N] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>while(<span class="hljs-number">1</span>)&#123;<br><br><span class="hljs-comment">//全部取走或者函数</span><br><br><span class="hljs-keyword">if</span>(count==n||num&gt;n) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">//卡片被取走</span><br><br><span class="hljs-keyword">if</span>(flag[pos])&#123;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos=<span class="hljs-number">1</span>;<span class="hljs-comment">//也就是循环到开头</span><br><br>&#125;<br><br><span class="hljs-comment">//取走卡片</span><br><br><span class="hljs-keyword">else</span>&#123;<br><br><span class="hljs-keyword">if</span>(a[pos]==num)&#123;<br><br>res+=a[pos];<br><br>flag[pos]=<span class="hljs-number">1</span>;<br><br>count++;<br><br>num=<span class="hljs-number">1</span>;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos = <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-keyword">else</span>&#123;<br><br>num++;<br><br>pos++;<br><br><span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>) pos = <span class="hljs-number">1</span>;<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">if</span>(res&gt;ans) ans = res;<span class="hljs-comment">//找到最优解</span><br><br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main()&#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);cin.tie(<span class="hljs-number">0</span>);cout.tie(<span class="hljs-number">0</span>);<br><br>solve();<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调队列</title>
    <link href="/2023/11/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2023/11/02/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h5 id="“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理"><a href="#“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理" class="headerlink" title="“如果一个选手比你小还比你强，你就可以退役了。”——单调队列的原理"></a><em><strong>“如果一个选手比你小还比你强，你就可以退役了。”</strong>——单调队列的原理</em></h5><h3 id="单调队列主要的解决问题：单调队列是一种主要用于解决滑动窗口类问题的数据结构，即，在长度为-n-的序列中，求每个长度为-m-的区间的区间最值。它的时间复杂度是-O-n"><a href="#单调队列主要的解决问题：单调队列是一种主要用于解决滑动窗口类问题的数据结构，即，在长度为-n-的序列中，求每个长度为-m-的区间的区间最值。它的时间复杂度是-O-n" class="headerlink" title="单调队列主要的解决问题：单调队列是一种主要用于解决滑动窗口类问题的数据结构，即，在长度为 n 的序列中，求每个长度为 m 的区间的区间最值。它的时间复杂度是 O(n);"></a>单调队列主要的解决问题：<strong>单调队列</strong>是一种主要用于解决<strong>滑动窗口</strong>类问题的数据结构，即，在长度为 n 的序列中，求每个长度为 m 的区间的区间最值。它的时间复杂度是 O(n);</h3><h4 id="由于是维护区间所以需要两边都需要能够吐出数字，所以需要用双向队列进行维护"><a href="#由于是维护区间所以需要两边都需要能够吐出数字，所以需要用双向队列进行维护" class="headerlink" title="由于是维护区间所以需要两边都需要能够吐出数字，所以需要用双向队列进行维护"></a>由于是维护区间所以需要两边都需要能够吐出数字，所以需要用双向队列进行维护</h4><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>给定一个长度为n的数组a。  </p><p>有一个大小为k的滑动窗口（窗口中只能看到k个元素），它从数组的最左边，每次向右移动一个位置，直到移动到最右边。  </p><p>你需要回答出滑动窗口在每个位置时，窗口中的最大值和最小值。</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行：两个整数n,k。（51≤k≤n≤2×10^5）  </p><p>第二行：n个整数，代表数组a。（−10^6≤ai​≤10^6，1≤i≤n）</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>第一行：从左到右，滑动窗口在每个位置的最大值。  </p><p>第二行：从左到右，滑动窗口在每个位置的最小值。</p><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> -<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h5 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> -<span class="hljs-number">5</span> -<span class="hljs-number">5</span> -<span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="ANSWER"><a href="#ANSWER" class="headerlink" title="ANSWER"></a>ANSWER</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N];<br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> n, k;<span class="hljs-comment">//k代表的是队列的长度</span><br><br>  cin &gt;&gt; n &gt;&gt; k;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br><br>  deque&lt;<span class="hljs-type">int</span>&gt; dq;<span class="hljs-comment">//存的是坐标</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-comment">//这里求的是最大值,单调队列要求单调性。</span><br>  while (dq.size() &amp;&amp; dq.front() &lt;= i - k) dq.pop_front();<br><span class="hljs-comment">//-|-|-|-|------相当于最前面是前端，最后面是后端,就是现在的i超过了，那么将前面的吐出来。</span><br>  while (dq.size() &amp;&amp; a[dq.back()] &lt;= a[i]) dq.pop_back();<br><span class="hljs-comment">//就是会前进一格的时候就要判断如果前面的比现在的要大，由于求的是最大值，所以要求的从大到小所以大的小的就可以被删掉，因为它已经不会成为答案。</span><br>  dq.push_back(i);<br><span class="hljs-comment">// 将i读入进去</span><br>  <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[dq.front()] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br>  cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>  dq = deque&lt;<span class="hljs-type">int</span>&gt;();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>    while (dq.size() &amp;&amp; dq.front() &lt;= i - k) dq.pop_front();<br><br>    while (dq.size() &amp;&amp; a[dq.back()] &gt;= a[i]) dq.pop_back();<br><br>    dq.push_back(i);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[dq.front()] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>  &#125;<br><br> cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br>  cin.tie(<span class="hljs-number">0</span>);<br><br>  cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br><br>  while (t--) &#123;<br><br>   solve();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N],dq[N];<br><br>void solve() &#123;<br><br><span class="hljs-type">int</span> n, k;<br><br>cin &gt;&gt; n &gt;&gt; k;<br><br><span class="hljs-type">int</span> hh =<span class="hljs-number">1</span>,tt = <span class="hljs-number">0</span> ;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>while (hh&lt;=tt &amp;&amp; dq[hh] &lt;= i - k) hh++;<br><br>while (hh&lt;=tt &amp;&amp; a[dq[tt]]&lt;= a[i]) tt--;<br><br>dq[++ tt] = i;<br><br><span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[dq[hh]] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>hh =<span class="hljs-number">1</span>,tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>while (hh&lt;=tt &amp;&amp; dq[hh]&lt;=i-k) hh++;<br><br>while (hh&lt;=tt &amp;&amp; a[dq[tt]] &gt;= a[i]) tt--;<br><br>dq[++ tt] = i;<br><br><span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[dq[hh]] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br>cin.tie(<span class="hljs-number">0</span>);<br><br>cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br><br>while (t--) &#123;<br><br>solve();<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2023/10/31/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/10/31/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="单调栈就是在先进后出的特性上加了栈内所有元素是单调递增的或者是单调递减的。"><a href="#单调栈就是在先进后出的特性上加了栈内所有元素是单调递增的或者是单调递减的。" class="headerlink" title="单调栈就是在先进后出的特性上加了栈内所有元素是单调递增的或者是单调递减的。"></a>单调栈就是在先进后出的特性上加了栈内所有元素是单调递增的或者是单调递减的。</h3><h3 id="单调递增栈能表示入栈元素左边第一个比它大的元素"><a href="#单调递增栈能表示入栈元素左边第一个比它大的元素" class="headerlink" title="单调递增栈能表示入栈元素左边第一个比它大的元素"></a>单调递增栈能表示入栈元素左边第一个比它大的元素</h3><h3 id="单调递减栈能表示入栈元素左边第一个比它小的元素"><a href="#单调递减栈能表示入栈元素左边第一个比它小的元素" class="headerlink" title="单调递减栈能表示入栈元素左边第一个比它小的元素"></a>单调递减栈能表示入栈元素左边第一个比它小的元素</h3><h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><h5 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h5><blockquote><p>给定一个长度为n的整数数组a，你需要求出每个元素的左边第一个比它小的元素。</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行：一个整数n。（1≤n≤2×10^5）  </p><p>第二行：n个整数，表示整数数组a。（1≤ai​≤10^9）</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>共一行，n个整数，表示每个元素的左边第一个比它小的元素，若不存在则为−1。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> 7 <span class="hljs-string">-1</span> 5 6<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="由于这题给出的东西非常适合单调栈的操作，所以我们用单调栈来做，由于我们要取得是一个单调递增的数列，操作就是如果栈顶元素大于等于当前元素，那么就将栈顶元素删除，如果不是就直接push进去，地址存为栈顶元素。"><a href="#由于这题给出的东西非常适合单调栈的操作，所以我们用单调栈来做，由于我们要取得是一个单调递增的数列，操作就是如果栈顶元素大于等于当前元素，那么就将栈顶元素删除，如果不是就直接push进去，地址存为栈顶元素。" class="headerlink" title="由于这题给出的东西非常适合单调栈的操作，所以我们用单调栈来做，由于我们要取得是一个单调递增的数列，操作就是如果栈顶元素大于等于当前元素，那么就将栈顶元素删除，如果不是就直接push进去，地址存为栈顶元素。"></a>由于这题给出的东西非常适合单调栈的操作，所以我们用单调栈来做，由于我们要取得是一个单调递增的数列，操作就是如果栈顶元素大于等于当前元素，那么就将栈顶元素删除，如果不是就直接push进去，地址存为栈顶元素。</h5><h4 id="ANSWER"><a href="#ANSWER" class="headerlink" title="ANSWER"></a>ANSWER</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N], l[N];<span class="hljs-comment">//l[N]是记录第一个的value</span><br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> n;<br><br>  cin &gt;&gt; n;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];<br><br>  stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>     while (st.size() &amp;&amp; st.top() &gt;= a[i]) st.pop();<span class="hljs-comment">//不是单调性就删除</span><br><br>     <span class="hljs-keyword">if</span> (st.empty())<br><br>        l[i] = <span class="hljs-number">-1</span>;<br><br>     <span class="hljs-keyword">else</span><br><br>        l[i] = st.top();<br><br>     st.push(a[i]);<br><br>&#125;<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cout &lt;&lt; l[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br>  cin.tie(<span class="hljs-number">0</span>);<br><br>  cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br><br>  while (t--) &#123;<br><br>    solve();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署出现错误 Error Spawn failed</title>
    <link href="/2023/10/30/Hexo%E9%83%A8%E7%BD%B2%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF-Error-Spawn-failed/"/>
    <url>/2023/10/30/Hexo%E9%83%A8%E7%BD%B2%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF-Error-Spawn-failed/</url>
    
    <content type="html"><![CDATA[<h4 id="hexo发生error：spawn-failed错误的解决方法-error-spawn-failed-CSDN博客"><a href="#hexo发生error：spawn-failed错误的解决方法-error-spawn-failed-CSDN博客" class="headerlink" title="hexo发生error：spawn failed错误的解决方法_error: spawn failed-CSDN博客"></a><a href="https://blog.csdn.net/HTL2018/article/details/106876940">hexo发生error：spawn failed错误的解决方法_error: spawn failed-CSDN博客</a></h4>]]></content>
    
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>set(STL)</title>
    <link href="/2023/10/30/set-STL/"/>
    <url>/2023/10/30/set-STL/</url>
    
    <content type="html"><![CDATA[<h3 id="set的性质"><a href="#set的性质" class="headerlink" title="set的性质"></a>set的性质</h3><h4 id="Sets-组-are-a-type-of-associative-container-容器-in-which-each-element-元素-has-to-be-unique-独特-because-the-value-of-the-element-元素-identifies-识别-it-The-values-are-stored-in-a-specific-特定-sorted-order-i-e-either-ascending-or-descending-下降-解释set不会有重复的东西，即使插入多个重复的东西，那么仍然只会显示一个-而且是有顺序的。"><a href="#Sets-组-are-a-type-of-associative-container-容器-in-which-each-element-元素-has-to-be-unique-独特-because-the-value-of-the-element-元素-identifies-识别-it-The-values-are-stored-in-a-specific-特定-sorted-order-i-e-either-ascending-or-descending-下降-解释set不会有重复的东西，即使插入多个重复的东西，那么仍然只会显示一个-而且是有顺序的。" class="headerlink" title="Sets(组) are a type of associative container(容器) in which each element(元素) has to be unique(独特) because the value of the element(元素) identifies(识别) it. The values are stored in a specific(特定) sorted order i.e. either ascending or descending(下降).  解释set不会有重复的东西，即使插入多个重复的东西，那么仍然只会显示一个,而且是有顺序的。"></a>Sets(组) are a type of associative container(容器) in which each element(元素) has to be unique(独特) because the value of the element(元素) identifies(识别) it. The values are stored in a specific(特定) sorted order i.e. either ascending or descending(下降).  解释set不会有重复的东西，即使插入多个重复的东西，那么仍然只会显示一个,而且是有顺序的。</h4><h3 id="举一个例子来看STL中的函数"><a href="#举一个例子来看STL中的函数" class="headerlink" title="举一个例子来看STL中的函数"></a>举一个例子来看STL中的函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// C++ program to demonstrate various functions of</span><br><span class="hljs-comment">// STL</span><br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br><span class="hljs-comment">// empty set container</span><br>set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; s1;<span class="hljs-comment">//说明这个是大的在前</span><br><br><span class="hljs-comment">// insert elements in random order</span><br>s1.insert(<span class="hljs-number">40</span>);<span class="hljs-comment">//插入函数</span><br>s1.insert(<span class="hljs-number">30</span>);<br>s1.insert(<span class="hljs-number">60</span>);<br>s1.insert(<span class="hljs-number">20</span>);<br>s1.insert(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">// only one 50 will be added to the set</span><br>s1.insert(<span class="hljs-number">50</span>);<br>s1.insert(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// printing set s1</span><br>set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt;::iterator itr;<span class="hljs-comment">//迭代器</span><br>cout &lt;&lt; <span class="hljs-string">&quot;\nThe set s1 is : \n&quot;</span>;<br><span class="hljs-keyword">for</span> (itr = s1.begin(); itr != s1.end(); itr++) &#123;<br>cout &lt;&lt; *itr &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// assigning the elements from s1 to s2</span><br>set&lt;<span class="hljs-type">int</span>&gt; s2(s1.begin(), s1.end());<span class="hljs-comment">//默认从小到大</span><br><br><span class="hljs-comment">// print all elements of the set s2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;\nThe set s2 after assign from s1 is : \n&quot;</span>;<br><span class="hljs-keyword">for</span> (itr = s2.begin(); itr != s2.end(); itr++) &#123;<br>cout &lt;&lt; *itr &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// remove all elements up to 30 in s2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;\ns2 after removal of elements less than 30 &quot;</span><br><span class="hljs-string">&quot;:\n&quot;</span>;<br>s2.erase(s2.begin(), s2.find(<span class="hljs-number">30</span>));<span class="hljs-comment">//删去小于三十的</span><br><span class="hljs-keyword">for</span> (itr = s2.begin(); itr != s2.end(); itr++) &#123;<br>cout &lt;&lt; *itr &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// remove element with value 50 in s2</span><br><span class="hljs-type">int</span> num;<br>num = s2.erase(<span class="hljs-number">50</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;\ns2.erase(50) : &quot;</span>;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; removed\n&quot;</span>;<br><span class="hljs-keyword">for</span> (itr = s2.begin(); itr != s2.end(); itr++) &#123;<br>cout &lt;&lt; *itr &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// lower bound and upper bound for set s1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;s1.lower_bound(40) : &quot;</span><br>&lt;&lt; *s1.lower_bound(<span class="hljs-number">40</span>) &lt;&lt; endl;<br><span class="hljs-comment">// lower_bound的指的是&lt;=是可以取到</span><br><span class="hljs-comment">//upper_bound指的是&gt;是只能取到你想要的更高的一位</span><br>cout &lt;&lt; <span class="hljs-string">&quot;s1.upper_bound(40) : &quot;</span><br>&lt;&lt; *s1.upper_bound(<span class="hljs-number">40</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// lower bound and upper bound for set s2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;s2.lower_bound(40) : &quot;</span><br>&lt;&lt; *s2.lower_bound(<span class="hljs-number">40</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;s2.upper_bound(40) : &quot;</span><br>&lt;&lt; *s2.upper_bound(<span class="hljs-number">40</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">The set s1 is : <br><span class="hljs-number">60</span> <span class="hljs-number">50</span> <span class="hljs-number">40</span> <span class="hljs-number">30</span> <span class="hljs-number">20</span> <span class="hljs-number">10</span> <br><br>The set s2 after assign from s1 is : <br><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span> <span class="hljs-number">60</span> <br><br>s2 after removal of elements less than <span class="hljs-number">30</span> :<br><span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span> <span class="hljs-number">60</span> <br>s2.erase(<span class="hljs-number">50</span>) : <span class="hljs-number">1</span> removed<br><span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">60</span> <br>s1.lower_bound(<span class="hljs-number">40</span>) : <span class="hljs-number">40</span><br>s1.upper_bound(<span class="hljs-number">40</span>) : <span class="hljs-number">30</span><br>s2.lower_bound(<span class="hljs-number">40</span>) : <span class="hljs-number">40</span><br>s2.upper_bound(<span class="hljs-number">40</span>) : <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><h3 id="例题来熟悉"><a href="#例题来熟悉" class="headerlink" title="例题来熟悉"></a>例题来熟悉</h3><blockquote><p>给定一个大小为n的整型数组a，你需要对其按照升序排序并进行去重</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>第一行：一个整数n。（1≤n≤2×10^5）  </p><p>第二行：n个整数，表示数组a的所有元素。(−10^9≤ai​≤10^9)，(1≤i≤n）</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>共一行，输出升序排序且去重后的数组a。</p><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="ANSWER"><a href="#ANSWER" class="headerlink" title="ANSWER"></a>ANSWER</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;algorithm&gt;<br><br>#include &lt;cmath&gt;<br><br>#include &lt;cstring&gt;<br><br>#include &lt;iostream&gt;<br><br>#include &lt;<span class="hljs-keyword">map</span>&gt;<br><br>#include &lt;queue&gt;<br><br>#include &lt;set&gt;<br><br>#include &lt;stack&gt;<br><br>#include &lt;<span class="hljs-type">string</span>&gt;<br><br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> n;<br><br>  cin &gt;&gt; n;<br><br>  set&lt;<span class="hljs-type">int</span>&gt; st;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><br>    <span class="hljs-type">int</span> x;<br><br>    cin &gt;&gt; x;<br><br>    st.insert(x);<br><br>   &#125;<br><br>  <span class="hljs-keyword">for</span> (auto&amp; v : st) &#123;<br><br>  cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>  &#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br>  cin.tie(<span class="hljs-number">0</span>);<br><br>  cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><br>  while (a--) &#123;<br><br>  solve();<br><br> &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map(STL)</title>
    <link href="/2023/10/28/map-STL/"/>
    <url>/2023/10/28/map-STL/</url>
    
    <content type="html"><![CDATA[<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="Each-element-元素-has-a-key-value-and-a-mapped-value-No-two-mapped-values-can-可以-have-the-same-key-values-借用网站上的话解释的非常清晰。"><a href="#Each-element-元素-has-a-key-value-and-a-mapped-value-No-two-mapped-values-can-可以-have-the-same-key-values-借用网站上的话解释的非常清晰。" class="headerlink" title="Each element(元素) has a key value and a mapped value. No two mapped values can(可以) have the same key values.借用网站上的话解释的非常清晰。"></a>Each element(元素) has a key value and a mapped value. No two mapped values can(可以) have the same key values.借用网站上的话解释的非常清晰。</h4><h3 id="一些常用的函数"><a href="#一些常用的函数" class="headerlink" title="一些常用的函数"></a>一些常用的函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建map</span><br><span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>,<span class="hljs-type">int</span>&gt; mp<br><span class="hljs-comment">//begin函数,返回第一个元素的迭代器,要专门写一个迭代器去接受</span><br>std::<span class="hljs-keyword">map</span>&lt;std::<span class="hljs-type">string</span>, <span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-keyword">map</span>.begin();<br>mp.begin()<br><span class="hljs-comment">//end()</span><br>mp.end()<span class="hljs-comment">//返回最后一个迭代器</span><br><span class="hljs-comment">//find()</span><br>mp.find(key)<span class="hljs-comment">//找到S的对应的迭代器</span><br><span class="hljs-comment">//count(key)</span><br>mp.count(key)<span class="hljs-comment">//找到对应的value的个数0或者1</span><br></code></pre></td></tr></table></figure><h3 id="一道练习题"><a href="#一道练习题" class="headerlink" title="一道练习题"></a>一道练习题</h3><blockquote><p>空中有n个气球，第i个气球有一个颜色coli​（用一个字符串表示）。</p><p>请你求出每种气球的个数，按照气球出现的顺序进行排序输出。</p></blockquote><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote><p>第一行一个整数T表示样例个数。(1≤T≤10)</p><p>对于每个样例，第一行一个整数n表示气球个数。(1≤n le100)</p><p>接下来n行，每行一个字符串表示coli​。(1≤∣coli​∣≤50)</p><p>字符串仅包含小写英文字母。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing">样例输入 <br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-built_in">red</span><br><span class="hljs-built_in">red</span><br><span class="hljs-built_in">blue</span><br><span class="hljs-number">5</span><br>a<br>b<br>e<br>d<br>e<br><br></code></pre></td></tr></table></figure></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">red</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">blue</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">a</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">b</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">e</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">d</span> <span class="hljs-number">1</span><br><span class="hljs-comment">### 样例输出</span><br></code></pre></td></tr></table></figure><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote><p>对于每个样例，输出所有气球的种类和个数。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>void solve() &#123;<br><br>  <span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>, <span class="hljs-type">int</span>&gt; mp;<br><br>  vector&lt;<span class="hljs-type">string</span>&gt; v;<br><br>  <span class="hljs-type">int</span> n;<br><br>  cin &gt;&gt; n;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>   <span class="hljs-type">string</span> s;<br><br>   cin &gt;&gt; s;<br><br>   <span class="hljs-keyword">if</span> (mp.find(s) != mp.end())<br><br>     mp[s]++;<br><br>     <span class="hljs-keyword">else</span><br><br>     v.push_back(s), mp[s] = <span class="hljs-number">1</span>;<br><br>   &#125;<br><br>   <span class="hljs-keyword">for</span> (auto &amp;i : v) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; mp[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br>  cin.tie(<span class="hljs-number">0</span>);<br><br>  cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> m;<br><br>  cin &gt;&gt; m;<br>  <br>  while (m--) &#123;<br><br>  solve();<br><br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于map遍历顺序的问题"><a href="#关于map遍历顺序的问题" class="headerlink" title="关于map遍历顺序的问题"></a>关于map遍历顺序的问题</h3><h4 id="当你为MAP插入一个元素后，MAP会按KEY的顺序重新排列，所以当你遍历MAP的时候，遍历的顺序已经不是你插入元素的顺序。举个具体例子"><a href="#当你为MAP插入一个元素后，MAP会按KEY的顺序重新排列，所以当你遍历MAP的时候，遍历的顺序已经不是你插入元素的顺序。举个具体例子" class="headerlink" title="当你为MAP插入一个元素后，MAP会按KEY的顺序重新排列，所以当你遍历MAP的时候，遍历的顺序已经不是你插入元素的顺序。举个具体例子:"></a>当你为MAP插入一个元素后，MAP会按KEY的顺序重新排列，所以当你遍历MAP的时候，遍历的顺序已经不是你插入元素的顺序。举个具体例子:</h4><h5 id="MAP【‘B’】-1"><a href="#MAP【‘B’】-1" class="headerlink" title="MAP【‘B’】=1"></a>MAP【‘B’】=1</h5><h5 id="MAP【‘C’】-2"><a href="#MAP【‘C’】-2" class="headerlink" title="MAP【‘C’】=2"></a>MAP【‘C’】=2</h5><h5 id="MAP【’A‘】-3"><a href="#MAP【’A‘】-3" class="headerlink" title="MAP【’A‘】=3"></a>MAP【’A‘】=3</h5><h5 id="当你遍历MAP输出的时候，是按’A’-’B’-’C’顺序输出的，而不是’B’-’C’-’A’顺序输出。如果你要遍历的顺序就是插入元素的顺序，你必须用线性容器，比如VECTOR"><a href="#当你遍历MAP输出的时候，是按’A’-’B’-’C’顺序输出的，而不是’B’-’C’-’A’顺序输出。如果你要遍历的顺序就是插入元素的顺序，你必须用线性容器，比如VECTOR" class="headerlink" title="当你遍历MAP输出的时候，是按’A’,’B’,’C’顺序输出的，而不是’B’,’C’,’A’顺序输出。如果你要遍历的顺序就是插入元素的顺序，你必须用线性容器，比如VECTOR"></a>当你遍历MAP输出的时候，是按’A’,’B’,’C’顺序输出的，而不是’B’,’C’,’A’顺序输出。如果你要遍历的顺序就是插入元素的顺序，你必须用线性容器，比如VECTOR</h5>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2023/10/28/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/28/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="优先队列-priority-queue-是堆的排列"><a href="#优先队列-priority-queue-是堆的排列" class="headerlink" title="优先队列(priority_queue)是堆的排列"></a>优先队列(priority_queue)是堆的排列</h3><h3 id="优先队列的一些性质"><a href="#优先队列的一些性质" class="headerlink" title="优先队列的一些性质"></a>优先队列的一些性质</h3><h4 id="首先优先队列是默认是大根堆"><a href="#首先优先队列是默认是大根堆" class="headerlink" title="首先优先队列是默认是大根堆"></a>首先优先队列是默认是大根堆</h4><h3 id="一些操作"><a href="#一些操作" class="headerlink" title="一些操作"></a>一些操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">q.size();<span class="hljs-comment">//返回q里元素个数</span><br>q.empty();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.push(k);<span class="hljs-comment">//在q的末尾插入k </span><br>q.pop();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.top();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure><h4 id="而优先队列的强大功能就是可以自动排序"><a href="#而优先队列的强大功能就是可以自动排序" class="headerlink" title="而优先队列的强大功能就是可以自动排序"></a>而优先队列的强大功能就是可以自动排序</h4><h4 id="https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BC-98-E5-85-88-E9-98-9F-E5-88-97-png-比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。"><a href="#https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BC-98-E5-85-88-E9-98-9F-E5-88-97-png-比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。" class="headerlink" title="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png 比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。"></a><a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png</a> 比如这张图每次插入新的数据都会重新进行排列，如果是大根堆，最上方的节点就是最大值，但是下面的节点并没有确定的顺序。</h4><h3 id="拿一道默认的优先队列"><a href="#拿一道默认的优先队列" class="headerlink" title="拿一道默认的优先队列"></a>拿一道默认的优先队列</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br>你有一个菜篮子。<br><br>接下来Q次操作，每次操作如下：<br><br><span class="hljs-number">1</span>. <span class="hljs-string">&quot;1 x&quot;</span>，将一个重量为<span class="hljs-keyword">x</span>的菜放入到菜篮子中。<br>    <br><span class="hljs-number">2</span>. <span class="hljs-string">&quot;2&quot;</span>，将菜篮子中重量最大的菜丢掉（如果菜篮子为空，则跳过）。<br>    <br><br>问Q次操作后，菜篮子中剩下的菜的总重量。<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br><br>constexpr <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> q;<br><br>  cin &gt;&gt; q;<br><br>  ll sum = <span class="hljs-number">0</span>;<br><br>  priority_queue&lt;ll&gt; pq;<span class="hljs-comment">//默认是大根堆</span><br><br>  while (q--) &#123;<br><br>    <span class="hljs-type">int</span> c;<br><br>    cin &gt;&gt; c;<br>  <br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) &#123;<br><br>      ll x;<br><br>      cin &gt;&gt; x;<br><br>      pq.push(x);<br><br>      sum += x;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pq.size()) &#123;<span class="hljs-comment">//判断被删完的情况就没必要加</span><br><br>      sum -= pq.top();<br><br>      pq.pop();<br><br>    &#125;<br><br>  &#125;<br><br>  cout &lt;&lt; sum &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br> ios::sync_with_stdio(<span class="hljs-number">0</span>);<br><br> cin.tie(<span class="hljs-number">0</span>);<br><br> cout.tie(<span class="hljs-number">0</span>);<br><br> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><br> while (a--) &#123;<br><br>  solve();<br><br> &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="小根堆的实现"><a href="#小根堆的实现" class="headerlink" title="小根堆的实现"></a>小根堆的实现</h3><h4 id="小根堆就是最上面是最小值"><a href="#小根堆就是最上面是最小值" class="headerlink" title="小根堆就是最上面是最小值"></a>小根堆就是最上面是最小值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">struct</span> cmp&#123;<br>   <span class="hljs-type">bool</span> operator()(<span class="hljs-keyword">const</span> ll&amp;u,<span class="hljs-keyword">const</span> ll &amp;v)<span class="hljs-keyword">const</span>&#123;<br>     <span class="hljs-keyword">return</span> u&lt;v;<br>   &#125;<br> &#125;;<br> priority_queue&lt;T,vector&lt;T&gt;,cmp&gt;pq;<br><br><span class="hljs-comment">//或者是这样</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2023/10/27/%E6%A0%88/"/>
    <url>/2023/10/27/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="首先是先进后出的数据结构"><a href="#首先是先进后出的数据结构" class="headerlink" title="首先是先进后出的数据结构"></a>首先是先进后出的数据结构</h3><p><a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/Pasted%20image%2020231018220744.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/Pasted%20image%2020231018220744.png</a></p><h3 id="STL中栈的一些函数"><a href="#STL中栈的一些函数" class="headerlink" title="STL中栈的一些函数"></a>STL中栈的一些函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//元素访问</span><br>st.top()<span class="hljs-comment">//返回栈顶</span><br><br><span class="hljs-comment">//修改</span><br>st.push()<span class="hljs-comment">//传入参数到栈顶</span><br>st.pop()<span class="hljs-comment">//弹出栈顶</span><br><br><span class="hljs-comment">//容量</span><br>st.empty()<span class="hljs-comment">//返回是否为空</span><br>st.size()<span class="hljs-comment">//返回元素数量</span><br></code></pre></td></tr></table></figure><h3 id="来一道模板题"><a href="#来一道模板题" class="headerlink" title="来一道模板题"></a>来一道模板题</h3><blockquote><p>现在有n部火车，每一部火车都有一个1∼n的编号且各不相同（火车编号构成一个<br>排列）。现在他们按照给定的顺序排列在一条轨道上，且可以向两个方向移动，问他们<br>否通过一个车站，且每部火车<strong>至多进站一次</strong>，使得出站口的编号顺序变为升序？<br>车站是一个栈结构，位于输入队列的轨道中间，构成一个T字形，初始时火车都在车站<br>右侧。<br>如果可以输出”Yes”，如果不行输出”No”。（不带引号）</p></blockquote><h4 id="分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈"><a href="#分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈" class="headerlink" title="分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈"></a>分析：就是将最后结果的排序是必须是升序的，就比如是进站的顺序是312，但是出栈的情况是123。在这里就是用栈的情况，将不符合的先存起来然后符合情况后在出栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//输入案例</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3 1 2</span><br><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//Yes</span><br>#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br>  <br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">9</span>;<br><br>  <br><br><span class="hljs-type">int</span> a[N], pos;<br><br>  <br><br>void solve() &#123;<br><br>  <span class="hljs-type">int</span> n;<br><br>  cin &gt;&gt; n;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br><br>  <br><br>  stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br>  pos = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// i表示左边轨道所需的列车编号</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><br><span class="hljs-comment">//如果不是所需的（想要的），就一直找</span><br><br>  while (pos &lt;= n &amp;&amp; (stk.empty() || stk.top() != i)) stk.push(a[pos++]);<br><span class="hljs-comment">//就是在pos还是小于n的情况下，并且还没有进栈，并且栈的顶部是没有与i对应的，那么就进栈</span><br>  <br><br>  <span class="hljs-keyword">if</span> (stk.top() == i)<span class="hljs-comment">//如果对应就移除</span><br><br>    stk.pop();<br><br>  <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//就是整个while循环完了还是没有能出栈的，说明就是没有升序的情况</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>     <span class="hljs-keyword">return</span>;<br><br>    &#125;<br><br>  &#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>  <br><br><span class="hljs-type">int</span> main() &#123;<br><br>  ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br><br>  while (_--) solve();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PropEmit和pinia</title>
    <link href="/2023/10/12/PropEmit%E5%92%8Cpinia/"/>
    <url>/2023/10/12/PropEmit%E5%92%8Cpinia/</url>
    
    <content type="html"><![CDATA[<h3 id="一，PropEmit父子组件传通信"><a href="#一，PropEmit父子组件传通信" class="headerlink" title="一，PropEmit父子组件传通信"></a>一，PropEmit父子组件传通信</h3><h4 id="例子：想在登录框中上方出现用户登录这四个大字"><a href="#例子：想在登录框中上方出现用户登录这四个大字" class="headerlink" title="例子：想在登录框中上方出现用户登录这四个大字"></a>例子：想在登录框中上方出现用户登录这四个大字</h4><h4 id="此时我们就可以用到PropEmit父子组件"><a href="#此时我们就可以用到PropEmit父子组件" class="headerlink" title="此时我们就可以用到PropEmit父子组件"></a>此时我们就可以用到PropEmit父子组件</h4><h4 id="我们在component和pages分别有login和Login的Vue文件（图片如下）"><a href="#我们在component和pages分别有login和Login的Vue文件（图片如下）" class="headerlink" title="我们在component和pages分别有login和Login的Vue文件（图片如下）"></a>我们在component和pages分别有login和Login的Vue文件（图片如下）</h4><h4 id="https-download-tooc-xlj0-com-uploads-179-E5-89-8D-E7-AB-AF-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-10-07-20204957-png"><a href="#https-download-tooc-xlj0-com-uploads-179-E5-89-8D-E7-AB-AF-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-10-07-20204957-png" class="headerlink" title="https://download.tooc.xlj0.com/uploads/179/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-07%20204957.png"></a><a href="https://download.tooc.xlj0.com/uploads/179/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-07%20204957.png">https://download.tooc.xlj0.com/uploads/179/%E5%89%8D%E7%AB%AF/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-07%20204957.png</a></h4><h4 id="首先在login就是子组件"><a href="#首先在login就是子组件" class="headerlink" title="首先在login就是子组件"></a>首先在login就是子组件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//首先写下prop组件</span><br><span class="hljs-keyword">const</span> props = defineProps&lt;&#123;msg:<span class="hljs-type">string</span>&#125;&gt;();<span class="hljs-comment">//类型是String</span><br><span class="hljs-comment">//接着需要解包msg</span><br><span class="hljs-keyword">const</span> &#123;msg=<span class="hljs-string">&quot;default&quot;</span>&#125; = toRefs(props);<span class="hljs-comment">//torefs时用来转换成ref类型用于响应式</span><br><span class="hljs-comment">//接着在&lt;template&gt;&lt;/template&gt;</span><br>在一个标头中写&#123;&#123;msg&#125;&#125;<br><span class="hljs-comment">//&#123;&#123;&#125;&#125;这个是插值表达式</span><br><br><span class="hljs-comment">//接着需要将ref，toRefs导入</span><br><span class="hljs-keyword">import</span> &#123;ref,h,toRefs&#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="接着是Login就是父组件"><a href="#接着是Login就是父组件" class="headerlink" title="接着是Login就是父组件"></a>接着是Login就是父组件</h4><h5 id="已经在login的子组件首先是搭建好"><a href="#已经在login的子组件首先是搭建好" class="headerlink" title="已经在login的子组件首先是搭建好"></a>已经在login的子组件首先是搭建好</h5><h5 id="我们就可以在Login进行操作了"><a href="#我们就可以在Login进行操作了" class="headerlink" title="我们就可以在Login进行操作了"></a>我们就可以在Login进行操作了</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在&lt;login&gt;&lt;/login&gt;标签中</span><br><span class="hljs-comment">//在&lt;login&gt;标签中“</span><br>&lt;login:msg = <span class="hljs-string">&quot;用户登录&quot;</span>&gt; <span class="hljs-comment">//l是小写。然后我们就可以看到在用户界面上方会有用户登陆</span><br></code></pre></td></tr></table></figure><h5 id="但是在我们一般不是想吧一个值给写死，所以我们通过响应式操作来"><a href="#但是在我们一般不是想吧一个值给写死，所以我们通过响应式操作来" class="headerlink" title="但是在我们一般不是想吧一个值给写死，所以我们通过响应式操作来"></a>但是在我们一般不是想吧一个值给写死，所以我们通过响应式操作来</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在&lt;script&gt;的标签中</span><br><span class="hljs-keyword">import</span> &#123;ref&#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">const</span> info = ref(<span class="hljs-string">&quot;用户登录&quot;</span>);<br><span class="hljs-comment">//接着在&lt;login&gt;的标签中</span><br>&lt;login:msg = info&gt;<br></code></pre></td></tr></table></figure><h4 id="我们在登录的页面我们会看到会有一个清空的按钮。"><a href="#我们在登录的页面我们会看到会有一个清空的按钮。" class="headerlink" title="我们在登录的页面我们会看到会有一个清空的按钮。"></a>我们在登录的页面我们会看到会有一个清空的按钮。</h4><h5 id="这是一个事件所以我们需要有时间来描述"><a href="#这是一个事件所以我们需要有时间来描述" class="headerlink" title="这是一个事件所以我们需要有时间来描述"></a>这是一个事件所以我们需要有时间来描述</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在login（l是小写）的vue文件</span><br><span class="hljs-comment">//定义一个emit事件，</span><br><span class="hljs-keyword">const</span> emit = defineEmits([<span class="hljs-string">&quot;clear&quot;</span>]);<br><span class="hljs-comment">//接着我们需要给clear这个事件进行补充</span><br><span class="hljs-keyword">const</span> clear =()=&gt;&#123;<span class="hljs-comment">//将输入框的数字变空</span><br>input.value = <span class="hljs-string">&quot;&quot;</span>;<br>password.value = <span class="hljs-string">&quot;&quot;</span>;<br>emit(<span class="hljs-string">&quot;clear&quot;</span>,<span class="hljs-string">&quot;the string is cleared&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="然后我们可以就需要在父组件进行操作"><a href="#然后我们可以就需要在父组件进行操作" class="headerlink" title="然后我们可以就需要在父组件进行操作"></a>然后我们可以就需要在父组件进行操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在login的标签进行操作</span><br>&lt;login:msg=info @clear=<span class="hljs-string">&quot;sonSetInfo&quot;</span>&gt;<br><span class="hljs-comment">//所以我们需要创建sonSetInfo</span><br><span class="hljs-keyword">const</span> sonSetInfo = (value:<span class="hljs-type">string</span>)=&gt;&#123;<br>sonInfo.value = value;<br>alert(sonInfo.value);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="这样进行当我们点登录窗口的时候点击清空那么就会清空"><a href="#这样进行当我们点登录窗口的时候点击清空那么就会清空" class="headerlink" title="这样进行当我们点登录窗口的时候点击清空那么就会清空"></a>这样进行当我们点登录窗口的时候点击清空那么就会清空</h5><h4 id="总结一下父子组件通信：需要在子组件定义好想要的数据和变量，父组件就是通过这个属性进行传递，然后父组件状态得到渲染，然后给到子组件，状态改变进行渲染。"><a href="#总结一下父子组件通信：需要在子组件定义好想要的数据和变量，父组件就是通过这个属性进行传递，然后父组件状态得到渲染，然后给到子组件，状态改变进行渲染。" class="headerlink" title="总结一下父子组件通信：需要在子组件定义好想要的数据和变量，父组件就是通过这个属性进行传递，然后父组件状态得到渲染，然后给到子组件，状态改变进行渲染。"></a>总结一下父子组件通信：需要在子组件定义好想要的数据和变量，父组件就是通过这个属性进行传递，然后父组件状态得到渲染，然后给到子组件，状态改变进行渲染。</h4><h3 id="二，Pinia变量全局存储"><a href="#二，Pinia变量全局存储" class="headerlink" title="二，Pinia变量全局存储"></a>二，Pinia变量全局存储</h3><h4 id="Pinal的官方文档-https-pinia-vuejs-org-zh"><a href="#Pinal的官方文档-https-pinia-vuejs-org-zh" class="headerlink" title="Pinal的官方文档 https://pinia.vuejs.org/zh/"></a>Pinal的官方文档 <a href="https://pinia.vuejs.org/zh/">https://pinia.vuejs.org/zh/</a></h4><h4 id="首先我们需要安装Pinia的包"><a href="#首先我们需要安装Pinia的包" class="headerlink" title="首先我们需要安装Pinia的包"></a>首先我们需要安装Pinia的包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">npm/cnpm/pnpm install pinia<br></code></pre></td></tr></table></figure><h5 id="然后再main-ts中添加"><a href="#然后再main-ts中添加" class="headerlink" title="然后再main.ts中添加"></a>然后再main.ts中添加</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// main.ts</span><br><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> App from <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createPinia &#125; from <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">const</span> pinia = createPinia();<br><br><br><span class="hljs-keyword">const</span> app = createApp(App);<br>app.use(pinia);<br>app.mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="就是import什么，我们下面就需要用app-use-来进行挂载。"><a href="#就是import什么，我们下面就需要用app-use-来进行挂载。" class="headerlink" title="就是import什么，我们下面就需要用app.use()来进行挂载。"></a>就是import什么，我们下面就需要用app.use()来进行挂载。</h5><h5 id="接着在src目录下新建store文件夹-并且创建index-ts的文件"><a href="#接着在src目录下新建store文件夹-并且创建index-ts的文件" class="headerlink" title="接着在src目录下新建store文件夹,并且创建index.ts的文件"></a>接着在src目录下新建store文件夹,并且创建index.ts的文件</h5><h5 id="需要在store下文件创建后需要有以下操作"><a href="#需要在store下文件创建后需要有以下操作" class="headerlink" title="需要在store下文件创建后需要有以下操作"></a>需要在store下文件创建后需要有以下操作</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//引入仓库插件</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; from <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-comment">//定义仓库名字，比如是Loginstore.ts的文件,就创建和名字相同的仓库名字</span><br><span class="hljs-keyword">const</span> loginStore = defineStore(  <br>    <span class="hljs-string">&quot;login&quot;</span>,  <br>    () =&gt; &#123;  <br>       <span class="hljs-keyword">const</span> loginSession = ref(<span class="hljs-literal">false</span>);  <br>       <span class="hljs-keyword">const</span> setLogin = (loginNewSession: boolean) =&gt; &#123;  <br>          loginSession.value = loginNewSession;  <br>       &#125;;  <br>  <br>       <span class="hljs-keyword">return</span> &#123;  <br>          loginSession,  <br>          setLogin,  <br>       &#125;;  <br>    &#125;,  <br>    &#123;  <br>       persist: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//这个是进行持久化hook</span><br>    &#125;  <br>);<br><span class="hljs-comment">//需要全局使用，</span><br>export <span class="hljs-keyword">default</span> loginStore;<br></code></pre></td></tr></table></figure><h4 id="关于在main-ts中router和pinia的优先问题"><a href="#关于在main-ts中router和pinia的优先问题" class="headerlink" title="关于在main.ts中router和pinia的优先问题"></a>关于在main.ts中router和pinia的优先问题</h4><h5 id="因为在main-ts中，注册router总比pinia先，所以不能使用到store-index-js文件中createPinia方法，只能在router文件中再createPinia一次，才能使用到pinia-所以需要进行手动挂载"><a href="#因为在main-ts中，注册router总比pinia先，所以不能使用到store-index-js文件中createPinia方法，只能在router文件中再createPinia一次，才能使用到pinia-所以需要进行手动挂载" class="headerlink" title="因为在main.ts中，注册router总比pinia先，所以不能使用到store/index.js文件中createPinia方法，只能在router文件中再createPinia一次，才能使用到pinia,所以需要进行手动挂载"></a>因为在main.ts中，注册router总比pinia先，所以不能使用到store/index.js文件中createPinia方法，只能在router文件中再createPinia一次，才能使用到pinia,所以需要进行手动挂载</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在router中</span><br><span class="hljs-keyword">import</span> pinia <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store&quot;</span>;<br><span class="hljs-keyword">import</span> loginstore <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/loginstore.ts&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;storeToRefs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">const</span> loginstore = <span class="hljs-title function_">loginStore</span>(pinia);<br><span class="hljs-keyword">const</span> &#123;loginSession&#125; = <span class="hljs-title function_">storeToRefs</span>(loginstore);<br></code></pre></td></tr></table></figure><h5 id="另外就是关于持久化数据的store，就是说如果你登陆之后退出后需要不重新进入，那么就是用持节化hook"><a href="#另外就是关于持久化数据的store，就是说如果你登陆之后退出后需要不重新进入，那么就是用持节化hook" class="headerlink" title="另外就是关于持久化数据的store，就是说如果你登陆之后退出后需要不重新进入，那么就是用持节化hook"></a>另外就是关于持久化数据的store，就是说如果你登陆之后退出后需要不重新进入，那么就是用持节化hook</h5><h5 id="Home-pinia-plugin-persistedstate-prazdevs-github-io"><a href="#Home-pinia-plugin-persistedstate-prazdevs-github-io" class="headerlink" title="Home | pinia-plugin-persistedstate (prazdevs.github.io)"></a><a href="https://prazdevs.github.io/pinia-plugin-persistedstate/zh/">Home | pinia-plugin-persistedstate (prazdevs.github.io)</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">pnpm i pinia-plugin-persistedstate<span class="hljs-comment">//安装</span><br><span class="hljs-comment">//将插件添加到index.ts</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; from <span class="hljs-string">&#x27;pinia&#x27;</span> <br><span class="hljs-keyword">import</span> piniaPluginPersistedstate from <span class="hljs-string">&#x27;pinia-plugin-persistedstate&#x27;</span> <br><span class="hljs-keyword">const</span> pinia = createPinia() <br>pinia.use(piniaPluginPersistedstate)<br></code></pre></td></tr></table></figure><h5 id="然后加一个presist：true。在上方的案例有写。"><a href="#然后加一个presist：true。在上方的案例有写。" class="headerlink" title="然后加一个presist：true。在上方的案例有写。"></a>然后加一个presist：true。在上方的案例有写。</h5>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/09/26/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/09/26/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一，第一种排序"><a href="#一，第一种排序" class="headerlink" title="一，第一种排序"></a>一，第一种排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><br><span class="hljs-type">int</span> b[N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><br><span class="hljs-type">int</span> x;<br><br>cin &gt;&gt; x;<br><br>a.push_back(x);<br><br>&#125;<br><br>sort(a.begin(), a.end());<span class="hljs-comment">//库里面自带的快排函数</span><br><br>a.erase(unique(a.begin(), a.end()), a.end());<span class="hljs-comment">//去重操作</span><br><span class="hljs-comment">//unique()将重复的数字放在后面，然后返回一个迭代器，在重复的数字那里</span><br><span class="hljs-comment">//erase消除两个迭代器的位置</span><br><span class="hljs-keyword">for</span> (auto&amp; x : a) &#123;<span class="hljs-comment">//遍历</span><br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二，第二种排序"><a href="#二，第二种排序" class="headerlink" title="二，第二种排序"></a>二，第二种排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>;<br><span class="hljs-comment">//结构体排序</span><br><span class="hljs-keyword">struct</span> Book &#123;<br><br><span class="hljs-type">int</span> high, thick, width;<br><br>&#125; b[N];<br><span class="hljs-comment">//cmp即使改变sort排序顺序</span><br><span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">const</span> Book &amp;a, <span class="hljs-keyword">const</span> Book &amp;b) &#123;<br><br><span class="hljs-keyword">if</span> (a.high == b.high &amp;&amp; a.thick == b.thick) <span class="hljs-keyword">return</span> a.width &gt; b.width;<br><br><span class="hljs-keyword">if</span> (a.high == b.high) <span class="hljs-keyword">return</span> a.thick &gt; b.thick;<br><br><span class="hljs-keyword">return</span> a.high &gt; b.high;<br><br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cin &gt;&gt; b[i].high &gt;&gt; b[i].thick &gt;&gt; b[i].width;<br><br>&#125;<br><br>sort(b + <span class="hljs-number">1</span>, b + n + <span class="hljs-number">1</span>, cmp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cout &lt;&lt; b[i].high &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b[i].thick &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b[i].width &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="三，第三种排序"><a href="#三，第三种排序" class="headerlink" title="三，第三种排序"></a>三，第三种排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-comment">//桶排序</span><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-type">int</span> x;<br><br>cin &gt;&gt; x;<br><br>a[x]++;<span class="hljs-comment">//将值对应的数组中++</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">2e5</span>; i++) &#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a[i]; j++) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2023/09/26/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2023/09/26/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="1，双指针的用途就是"><a href="#1，双指针的用途就是" class="headerlink" title="1，双指针的用途就是"></a>1，双指针的用途就是</h3><h4 id="a，有的是快慢指针操作"><a href="#a，有的是快慢指针操作" class="headerlink" title="a，有的是快慢指针操作"></a>a，有的是快慢指针操作</h4><h4 id="b，可以用来维护一段区间"><a href="#b，可以用来维护一段区间" class="headerlink" title="b，可以用来维护一段区间"></a>b，可以用来维护一段区间</h4><h3 id="2，双指针感觉没有模板，比较灵活"><a href="#2，双指针感觉没有模板，比较灵活" class="headerlink" title="2，双指针感觉没有模板，比较灵活"></a>2，双指针感觉没有模板，比较灵活</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//这个题就是找出最小不重复区间</span><br>#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> a[N], tmp[N];<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) &#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>memset(tmp, <span class="hljs-number">0</span>, sizeof(<span class="hljs-type">int</span>) * (n + <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br>cin &gt;&gt; a[i];<br><br>&#125;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//双指针，</span><br><br>while (j &lt; n &amp;&amp; !tmp[a[j + <span class="hljs-number">1</span>]]) &#123; <span class="hljs-comment">//前一个不重复</span><br><br>tmp[a[++j]]++; <span class="hljs-comment">//把前面的加起来</span><br><br>&#125;<br><br>ans = max(ans, j - i + <span class="hljs-number">1</span>ll); <span class="hljs-comment">//说明重复了</span><br><br>tmp[a[i]]--;<br><br>&#125;<br><br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算(最好提前看一下逻辑运算符)</title>
    <link href="/2023/09/24/%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%9C%80%E5%A5%BD%E6%8F%90%E5%89%8D%E7%9C%8B%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/09/24/%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%9C%80%E5%A5%BD%E6%8F%90%E5%89%8D%E7%9C%8B%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><h4 id="a，可以用来考试"><a href="#a，可以用来考试" class="headerlink" title="a，可以用来考试"></a>a，可以用来考试</h4><h4 id="b，线性基（异或）（数论）"><a href="#b，线性基（异或）（数论）" class="headerlink" title="b，线性基（异或）（数论）"></a>b，线性基（异或）（数论）</h4><h4 id="c，0，1串"><a href="#c，0，1串" class="headerlink" title="c，0，1串"></a>c，0，1串</h4><h4 id="d，计数"><a href="#d，计数" class="headerlink" title="d，计数"></a>d，计数</h4><h4 id="e，集，或者状态"><a href="#e，集，或者状态" class="headerlink" title="e，集，或者状态"></a>e，集，或者状态</h4><h3 id="一，与运算（-amp-）"><a href="#一，与运算（-amp-）" class="headerlink" title="一，与运算（&amp;）"></a>一，与运算（&amp;）</h3><h4 id="3-10-011-2"><a href="#3-10-011-2" class="headerlink" title="(3)_{10} =(011)_2"></a><script type="math/tex">(3)_{10} =(011)_2</script></h4><h4 id="6-10-110-2"><a href="#6-10-110-2" class="headerlink" title="(6)_{10}=(110)_2"></a><script type="math/tex">(6)_{10}=(110)_2</script></h4><h4 id="如果二者取与运算-amp-那么就是-010-2"><a href="#如果二者取与运算-amp-那么就是-010-2" class="headerlink" title="如果二者取与运算(&amp;)那么就是(010)_2"></a>如果二者取与运算(&amp;)那么就是<script type="math/tex">(010)_2</script></h4><h4 id="就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0"><a href="#就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0" class="headerlink" title="就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0"></a>就是可以看出来如果两个不一样。那么就是0，两个都是0那么取与运算也是0</h4><h4 id="或运算（-）"><a href="#或运算（-）" class="headerlink" title="或运算（|）"></a>或运算（|）</h4><h4 id="3-10-011-2-1"><a href="#3-10-011-2-1" class="headerlink" title="(3)_{10} =(011)_2"></a><script type="math/tex">(3)_{10} =(011)_2</script></h4><h4 id="6-10-110-2-1"><a href="#6-10-110-2-1" class="headerlink" title="(6)_{10}=(110)_2"></a><script type="math/tex">(6)_{10}=(110)_2</script></h4><h4 id="如果二者取或运算-那么就是-111-2"><a href="#如果二者取或运算-那么就是-111-2" class="headerlink" title="如果二者取或运算(|)那么就是(111)_2"></a>如果二者取或运算(|)那么就是<script type="math/tex">(111)_2</script></h4><h4 id="我们可以看出或运算只要两个不是0，那都是1"><a href="#我们可以看出或运算只要两个不是0，那都是1" class="headerlink" title="我们可以看出或运算只要两个不是0，那都是1"></a>我们可以看出或运算只要两个不是0，那都是1</h4><h3 id="二，异或运算"><a href="#二，异或运算" class="headerlink" title="二，异或运算(^)"></a>二，异或运算(^)</h3><h4 id="3-10-011-2-2"><a href="#3-10-011-2-2" class="headerlink" title="(3)_{10} =(011)_2"></a><script type="math/tex">(3)_{10} =(011)_2</script></h4><h4 id="6-10-110-2-2"><a href="#6-10-110-2-2" class="headerlink" title="(6)_{10}=(110)_2"></a><script type="math/tex">(6)_{10}=(110)_2</script></h4><h4 id="如果二者取异或运算-那么就是-101-2"><a href="#如果二者取异或运算-那么就是-101-2" class="headerlink" title="如果二者取异或运算(^)那么就是(101)_2"></a>如果二者取异或运算(^)那么就是<script type="math/tex">(101)_2</script></h4><h4 id="我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0"><a href="#我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0" class="headerlink" title="我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0"></a>我们可以看出如果两个的值是不一样的那么就是取1，而两个一样就是取0，比较好记的方法是异就是不一样，所以有两个一样的是0，两个不一样的是1。两个0也是0</h4><h3 id="三，取反运算"><a href="#三，取反运算" class="headerlink" title="三，取反运算(~)"></a>三，取反运算(~)</h3><h4 id="3-10-011-2-3"><a href="#3-10-011-2-3" class="headerlink" title="(3)_{10}=(011)_2"></a><script type="math/tex">(3)_{10}=(011)_2</script></h4><h4 id="取反后就是-100-2-4"><a href="#取反后就是-100-2-4" class="headerlink" title="取反后就是(100)_2=4"></a><script type="math/tex">取反后就是(100)_2=4</script></h4><h4 id="取反运算还有一个特殊的值，就是a-1"><a href="#取反运算还有一个特殊的值，就是a-1" class="headerlink" title="取反运算还有一个特殊的值，就是a=-1;"></a>取反运算还有一个特殊的值，就是a=-1;</h4><h4 id="a的二进制数是-11111111-2"><a href="#a的二进制数是-11111111-2" class="headerlink" title="a的二进制数是(11111111...)_2"></a><script type="math/tex">a的二进制数是(11111111...)_2</script></h4><h4 id="如果取反的话就是变成-0000-2"><a href="#如果取反的话就是变成-0000-2" class="headerlink" title="如果取反的话就是变成(0000...)_2"></a><script type="math/tex">如果取反的话就是变成(0000...)_2</script></h4><h3 id="四，移位运算"><a href="#四，移位运算" class="headerlink" title="四，移位运算"></a>四，移位运算</h3><h4 id="1，-lt-lt-左移运算符"><a href="#1，-lt-lt-左移运算符" class="headerlink" title="1，&lt;&lt;(左移运算符)"></a>1，&lt;&lt;(左移运算符)</h4><h4 id="3-0000011-2"><a href="#3-0000011-2" class="headerlink" title="3=(0000011)_2"></a><script type="math/tex">3=(0000011)_2</script></h4><h4 id="lt-lt-1左移一位-0000110-2这是高位溢出用人话讲就是去掉高位"><a href="#lt-lt-1左移一位-0000110-2这是高位溢出用人话讲就是去掉高位" class="headerlink" title="&lt;&lt;1左移一位(0000110)_2这是高位溢出用人话讲就是去掉高位"></a>&lt;&lt;1左移一位<script type="math/tex">(0000110)_2这是高位溢出用人话讲就是去掉高位</script></h4><h4 id="2，右移运算符-gt-gt"><a href="#2，右移运算符-gt-gt" class="headerlink" title="2，右移运算符(&gt;&gt;)"></a>2，右移运算符(&gt;&gt;)</h4><h4 id="1的情况就是-0000001-2"><a href="#1的情况就是-0000001-2" class="headerlink" title=">>1的情况就是(0000001)_2"></a><script type="math/tex">>>1的情况就是(0000001)_2</script></h4><h3 id="五，异或运算的公式"><a href="#五，异或运算的公式" class="headerlink" title="五，异或运算的公式"></a>五，异或运算的公式</h3><h4 id="a-oplus-b-b-oplus-a-交换律"><a href="#a-oplus-b-b-oplus-a-交换律" class="headerlink" title="a \oplus b=b \oplus a(交换律)"></a><script type="math/tex">a \oplus b=b \oplus a(交换律)</script></h4><h4 id="a-oplus-b-oplus-c-a-oplus-b-oplus-c-结合律"><a href="#a-oplus-b-oplus-c-a-oplus-b-oplus-c-结合律" class="headerlink" title="(a\oplus b)\oplus c = a\oplus(b\oplus c)(结合律)"></a><script type="math/tex">(a\oplus b)\oplus c = a\oplus(b\oplus c)(结合律)</script></h4><h4 id="a-oplus0-a"><a href="#a-oplus0-a" class="headerlink" title="a\oplus0 = a"></a><script type="math/tex">a\oplus0 = a</script></h4><h4 id="a-oplus-a-0"><a href="#a-oplus-a-0" class="headerlink" title="a\oplus a = 0"></a><script type="math/tex">a\oplus a = 0</script></h4><h4 id="a-b-2-a-amp-b-a-oplus-b-就有a-b-gt-a-oplus-b"><a href="#a-b-2-a-amp-b-a-oplus-b-就有a-b-gt-a-oplus-b" class="headerlink" title="a+b = 2(a&amp;b)+a$\oplus$b 就有a+b&gt;=a$\oplus$b"></a>a+b = 2(a&amp;b)+a$\oplus$b 就有a+b&gt;=a$\oplus$b</h4><h3 id="例题求二进制中1的个数"><a href="#例题求二进制中1的个数" class="headerlink" title="例题求二进制中1的个数"></a>例题求二进制中1的个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>  <br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>while (n--) &#123;<br><br>ll cnt = <span class="hljs-number">0</span>;<br><br>ll a = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; a;<br><br>while (a) &#123;<span class="hljs-comment">//判断的主体部分</span><br><br><span class="hljs-keyword">if</span> (a &amp; <span class="hljs-number">1</span>) cnt++;<span class="hljs-comment">//看最后一位的是否是1</span><br><br>a &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//判断完就右移去掉</span><br><br>&#125;<br><br>cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我们需要0"><a href="#我们需要0" class="headerlink" title="我们需要0"></a>我们需要0</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">题干：给定一个大小为n的非负整数数组a。  <br>  <br>你可以选定一个非负整数<span class="hljs-keyword">x</span>，并令bi​<span class="hljs-operator">=</span>ai​⊕<span class="hljs-keyword">x</span>，其中<span class="hljs-number">1</span>≤i≤n，请问是否存在<span class="hljs-keyword">x</span>，使得b<span class="hljs-number">1</span>​⊕b<span class="hljs-number">2</span>​⊕⋅⋅⋅⊕bn​<span class="hljs-operator">=</span><span class="hljs-number">0</span>？<br></code></pre></td></tr></table></figure><h4 id="思路分析：要用到两个公式-a-bigoplus-a-0-a-bigoplus-0-a-我们可以将bi写成ai和x的表达式a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-bigoplus-x-bigoplus-x-0"><a href="#思路分析：要用到两个公式-a-bigoplus-a-0-a-bigoplus-0-a-我们可以将bi写成ai和x的表达式a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-bigoplus-x-bigoplus-x-0" class="headerlink" title="思路分析：要用到两个公式$a\bigoplus a=0$      $a\bigoplus 0 =a$我们可以将bi写成ai和x的表达式a_1\bigoplus a_2\bigoplus a_3 \bigoplus x\bigoplus x\bigoplus x = 0"></a>思路分析：要用到两个公式$a\bigoplus a=0$      $a\bigoplus 0 =a$我们可以将bi写成ai和x的表达式<script type="math/tex">a_1\bigoplus a_2\bigoplus a_3 \bigoplus x\bigoplus x\bigoplus x = 0</script></h4><h4 id="x可以删去a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-0"><a href="#x可以删去a-1-bigoplus-a-2-bigoplus-a-3-bigoplus-x-0" class="headerlink" title="x可以删去a_1\bigoplus a_2\bigoplus a_3\bigoplus x = 0"></a>x可以删去<script type="math/tex">a_1\bigoplus a_2\bigoplus a_3\bigoplus x = 0</script></h4><h4 id="然后两边都是处理-bigoplus-x-就会有以下的式子a-1-bigoplus-a-2-bigoplus-a-3-x"><a href="#然后两边都是处理-bigoplus-x-就会有以下的式子a-1-bigoplus-a-2-bigoplus-a-3-x" class="headerlink" title="然后两边都是处理$\bigoplus x$就会有以下的式子a_1\bigoplus a_2\bigoplus a_3 = x"></a>然后两边都是处理$\bigoplus x$就会有以下的式子<script type="math/tex">a_1\bigoplus a_2\bigoplus a_3 = x</script></h4><h4 id="以下就是代码"><a href="#以下就是代码" class="headerlink" title="以下就是代码"></a>以下就是代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-type">int</span> main() &#123;<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) &#123;<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; a;<br><br>ans ^= a;<br><br>&#125;<br><br><span class="hljs-keyword">if</span> (ans)<br><br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-keyword">else</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和和差分</title>
    <link href="/2023/09/18/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/"/>
    <url>/2023/09/18/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-对于格式化输入输出"><a href="#1-对于格式化输入输出" class="headerlink" title="1,对于格式化输入输出"></a>1,对于格式化输入输出</h3><p>1，取消同步流<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>),cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><br>2，不要写<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">cout&lt;&lt;endl<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>写<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">cout</span>&lt;&lt;<span class="hljs-string">'<span class="hljs-char escape_">\n</span>'</span>;<br></code></pre></td></tr></table></figure><br>3，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例</span><br><span class="hljs-type">define</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-comment">//尽量不要用define</span><br><span class="hljs-comment">//替换</span><br><span class="hljs-type">using</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br></code></pre></td></tr></table></figure></p><h3 id="2-一维前缀和"><a href="#2-一维前缀和" class="headerlink" title="2,一维前缀和"></a>2,一维前缀和</h3><h4 id="a，前缀和的好处是将优化了暴力的时间复杂度"><a href="#a，前缀和的好处是将优化了暴力的时间复杂度" class="headerlink" title="a，前缀和的好处是将优化了暴力的时间复杂度"></a>a，前缀和的好处是将优化了暴力的时间复杂度</h4><h4 id="b-这是prefix的公式-p-i-sum-j-1-ia-j-p-i-1-a-i"><a href="#b-这是prefix的公式-p-i-sum-j-1-ia-j-p-i-1-a-i" class="headerlink" title="b,这是prefix的公式$$p_i=\sum_{j=1}^ia_j=p_{i-1}+a_i$$"></a>b,这是prefix的公式<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.014ex;" xmlns="http://www.w3.org/2000/svg" width="22.224ex" height="6.9ex" role="img" focusable="false" viewBox="0 -1717.4 9823.1 3049.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(536,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1107.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="munderover" transform="translate(2163.5,0)"><g data-mml-node="mo"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(124.5,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1190,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mi" transform="translate(600,1150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="msub" transform="translate(3774.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(4955.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(6011.1,0)"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="TeXAtom" transform="translate(536,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(7966.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(8967.1,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></p></h4><h4 id="c，然后一般是需要求区间和，所以有以下公式ans-p-r-p-l-1"><a href="#c，然后一般是需要求区间和，所以有以下公式ans-p-r-p-l-1" class="headerlink" title="c，然后一般是需要求区间和，所以有以下公式ans=p_r-p_{l-1}"></a>c，然后一般是需要求区间和，所以有以下公式<script type="math/tex">ans=p_r-p_{l-1}</script></h4><h4 id="这是比较容易理解的"><a href="#这是比较容易理解的" class="headerlink" title="这是比较容易理解的"></a>这是比较容易理解的</h4><h4 id="d，代码"><a href="#d，代码" class="headerlink" title="d，代码"></a>d，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>using ll = long long;<br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br>ll a[N], prefix[N];<br><span class="hljs-type">int</span> main() {<br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>cin &gt;&gt; a[i];<br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] + a[i];<br>}<br><span class="hljs-type">int</span> q;<br><br>cin &gt;&gt; q;<br><br>while (q--) {<br><span class="hljs-type">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>cout &lt;&lt;prefix[r] - prefix[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">'\n'</span>;<br>}<br>}<br></code></pre></td></tr></table></figure><h3 id="3-一维差分"><a href="#3-一维差分" class="headerlink" title="3,一维差分"></a>3,一维差分</h3><h4 id="a-用途-一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。"><a href="#a-用途-一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。" class="headerlink" title="a,用途:一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。"></a>a,用途:一般地，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。</h4><h4 id="b-差分：可以简单的看成序列中每个元素与其前一个元素的差。"><a href="#b-差分：可以简单的看成序列中每个元素与其前一个元素的差。" class="headerlink" title="b,差分：可以简单的看成序列中每个元素与其前一个元素的差。"></a>b,差分：可以简单的看成序列中每个元素与其前一个元素的差。</h4><h4 id="c-差分的公式-d-i-a-i-a-i-1"><a href="#c-差分的公式-d-i-a-i-a-i-1" class="headerlink" title="c:差分的公式:d_i=a_i-a_{i-1}"></a>c:差分的公式:<script type="math/tex">d_i=a_i-a_{i-1}</script></h4><h4 id="解释为什么是这样-sum-j-1-id-j-d-1-d-2-d-3-a-1-a-0-a-2-a-1-a-i"><a href="#解释为什么是这样-sum-j-1-id-j-d-1-d-2-d-3-a-1-a-0-a-2-a-1-a-i" class="headerlink" title="解释为什么是这样\sum_{j=1}^id_j= d_1+d_2+d_3+...=(a_1-a_0)+(a_2-a_1)+...=a_i"></a>解释为什么是这样<script type="math/tex">\sum_{j=1}^id_j= d_1+d_2+d_3+...=(a_1-a_0)+(a_2-a_1)+...=a_i</script></h4><h4 id="d-解释为什么用差分来修改数字a-1-d-1-a-2-d-1-d-2-a-3-d-1-d-2-d-3"><a href="#d-解释为什么用差分来修改数字a-1-d-1-a-2-d-1-d-2-a-3-d-1-d-2-d-3" class="headerlink" title="d,解释为什么用差分来修改数字a_1=d_1  a_2=d_1+d_2  a_3=d_1+d_2+d_3"></a>d,解释为什么用差分来修改数字<script type="math/tex">a_1=d_1  a_2=d_1+d_2  a_3=d_1+d_2+d_3</script></h4><h4 id="如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。"><a href="#如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。" class="headerlink" title="如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。"></a>如果d2加1那么后面的每一项都是加1的，所以对a2后面的每一个a都是加了1的。</h4><h4 id="e-如何对a的一个区间进行修改在-l-r-的区间增加x-所以在l处d-l-d-l-x-在r-1处d-r-1-d-r-1-x"><a href="#e-如何对a的一个区间进行修改在-l-r-的区间增加x-所以在l处d-l-d-l-x-在r-1处d-r-1-d-r-1-x" class="headerlink" title="e,如何对a的一个区间进行修改在[l,r]的区间增加x\\所以在l处d_l=d_l+x,\\在r+1处d_{r+1}=d_{r+1}-x"></a>e,如何对a的一个区间进行修改<script type="math/tex">在[l,r]的区间增加x\\所以在l处d_l=d_l+x,\\在r+1处d_{r+1}=d_{r+1}-x</script></h4><h4 id="f-重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改"><a href="#f-重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改" class="headerlink" title="f,重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改"></a>f,重新回到a上，此时相当于a是d的前缀和，即可完成数字的修改</h4><h4 id="f，代码"><a href="#f，代码" class="headerlink" title="f，代码"></a>f，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll diff[N], a[N], prefix[N];<br><br><span class="hljs-type">int</span> main() {<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>cin &gt;&gt; a[i];<br><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>diff[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br><br>}<br><br><span class="hljs-type">int</span> q;<br><br>cin &gt;&gt; q;<br><br>while (q--) {<br><br><span class="hljs-type">int</span> l, r, v;<br><br>cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;<br><br>diff[l] += v;<br><br>diff[r + <span class="hljs-number">1</span>] -= v;<br><br>}<br><br><span class="hljs-type">int</span> m;<br><br>cin &gt;&gt; m;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = a[i - <span class="hljs-number">1</span>] + diff[i];<span class="hljs-comment">//</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) prefix[i] = prefix[i - <span class="hljs-number">1</span>] + a[i];<br><br>while (m--) {<br><br><span class="hljs-type">int</span> l, r;<br><br>cin &gt;&gt; l &gt;&gt; r;<br><br>cout &lt;&lt; prefix[r] - prefix[l - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">"\n"</span>;<br><br>}<br><br>}<br></code></pre></td></tr></table></figure><h3 id="4-二维前缀和"><a href="#4-二维前缀和" class="headerlink" title="4,二维前缀和"></a>4,二维前缀和</h3><h4 id="a-https-download-tooc-xlj0-com-uploads-179-Pasted-20image-2020230918095226-png-在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式prefix-ij-p-i-j-1-p-i-1-j-p-i-1-j-1-a-i-j"><a href="#a-https-download-tooc-xlj0-com-uploads-179-Pasted-20image-2020230918095226-png-在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式prefix-ij-p-i-j-1-p-i-1-j-p-i-1-j-1-a-i-j" class="headerlink" title="a, https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png 在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式prefix_{ij}=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+a[i][j]"></a>a, <a href="https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png">https://download.tooc.xlj0.com/uploads/179/Pasted%20image%2020230918095226.png</a> 在图片中我们可以看到我们要两块绿色相加再加上一个小块，所以蓝色部分是加多了一次所以我们要将那个部分删掉，所以我们就可以看到以下公式<script type="math/tex">prefix_{ij}=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+a[i][j]</script></h4><h4 id="b，求区间和：如果求的是区间和那么就是如图片所示-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BA-8C-E7-BB-B4-E5-89-8D-E7-BC-80-E5-92-8C-png"><a href="#b，求区间和：如果求的是区间和那么就是如图片所示-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E4-BA-8C-E7-BB-B4-E5-89-8D-E7-BC-80-E5-92-8C-png" class="headerlink" title="b，求区间和：如果求的是区间和那么就是如图片所示 https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png"></a>b，求区间和：如果求的是区间和那么就是如图片所示 <a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png</a></h4><h4 id="可以看到有三部分，红色的点是被删了两次，所以需要加回去-所以公式如下求x1-y1-x2-y2这个区域的和-ans-prefix-x2-y2-prefix-x2-y1-1-prefix-x1-1-y2-prefix-x1-1-x1-1"><a href="#可以看到有三部分，红色的点是被删了两次，所以需要加回去-所以公式如下求x1-y1-x2-y2这个区域的和-ans-prefix-x2-y2-prefix-x2-y1-1-prefix-x1-1-y2-prefix-x1-1-x1-1" class="headerlink" title="可以看到有三部分，红色的点是被删了两次，所以需要加回去,所以公式如下求x1,y1,x2,y2这个区域的和\\ans=prefix[x2][y2]-prefix[x2][y1-1]-prefix[x1-1][y2]+prefix[x1-1][x1-1]"></a>可以看到有三部分，红色的点是被删了两次，所以需要加回去,所以公式如下<script type="math/tex">求x1,y1,x2,y2这个区域的和\\ans=prefix[x2][y2]-prefix[x2][y1-1]-prefix[x1-1][y2]+prefix[x1-1][x1-1]</script></h4><h3 id="d-代码实现"><a href="#d-代码实现" class="headerlink" title="d,代码实现"></a>d,代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll prefix[N][N], a[N][N];<br><br><span class="hljs-type">int</span> main() {<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n, m, q;<br><br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {<br><br>cin &gt;&gt; a[i][j];<br><br>}<br><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {<br><br>prefix[i][j] =<br><br>prefix[i - <span class="hljs-number">1</span>][j] + prefix[i][j - <span class="hljs-number">1</span>] - prefix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br><br>}<br><br>}<br><br>while (q--) {<br><br><span class="hljs-type">int</span> x1, y1, x2, y2;<br><br>cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br><br>cout &lt;&lt; prefix[x2][y2] - prefix[x1 - <span class="hljs-number">1</span>][y2] - prefix[x2][y1 - <span class="hljs-number">1</span>] +<br><br>prefix[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]<br><br>&lt;&lt; <span class="hljs-string">'\n'</span>;<br><br>}<br><br>}<br></code></pre></td></tr></table></figure><h3 id="5，二维差分"><a href="#5，二维差分" class="headerlink" title="5，二维差分"></a>5，二维差分</h3><h4 id="a-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-09-18-20110945-png-可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以-x1-y1-、-x2-y2-分别表示一个子矩阵的左上角和右下角的坐标，-每个操作将对应的子矩阵的每个元素加上c。diff-x1-y1-c-diff-x2-1-x1-c-diff-x1-y2-1-c-diff-x2-1-y2-1-c"><a href="#a-https-download-tooc-xlj0-com-uploads-179-E7-AE-97-E6-B3-95-E5-B1-8F-E5-B9-95-E6-88-AA-E5-9B-BE-202023-09-18-20110945-png-可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以-x1-y1-、-x2-y2-分别表示一个子矩阵的左上角和右下角的坐标，-每个操作将对应的子矩阵的每个元素加上c。diff-x1-y1-c-diff-x2-1-x1-c-diff-x1-y2-1-c-diff-x2-1-y2-1-c" class="headerlink" title="a, https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png 可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以(x1,y1)、(x2,y2)分别表示一个子矩阵的左上角和右下角的坐标，\\每个操作将对应的子矩阵的每个元素加上c。diff[x1][y1]+=c\diff[x2+1][x1]-=c\diff[x1][y2+1]-=c\diff[x2+1][y2+1]+=c$$"></a>a, <a href="https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png">https://download.tooc.xlj0.com/uploads/179/%E7%AE%97%E6%B3%95/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20110945.png</a> 可以看到差分的操作就是将减多的部分不回来，其他部分减一份就可以<script type="math/tex">(x1,y1)、(x2,y2)分别表示一个子矩阵的左上角和右下角的坐标，\\每个操作将对应的子矩阵的每个元素加上c。</script>diff[x1][y1]+=c\diff[x2+1][x1]-=c\diff[x1][y2+1]-=c\diff[x2+1][y2+1]+=c$$</h4><h4 id="b-先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1-x2-y1-y2换成i和j。"><a href="#b-先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1-x2-y1-y2换成i和j。" class="headerlink" title="b,先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1,x2,y1,y2换成i和j。"></a>b,先将a数组做差分得到一个差分的数组，对于求差分数组我们可以将左上角和右上角的坐标都看成i和j那么就是将上面的公式的x1,x2,y1,y2换成i和j。</h4><h4 id="c，然后处理后在返回去就行，接着就是前缀和的处理"><a href="#c，然后处理后在返回去就行，接着就是前缀和的处理" class="headerlink" title="c，然后处理后在返回去就行，接着就是前缀和的处理"></a>c，然后处理后在返回去就行，接着就是前缀和的处理</h4><h4 id="d，代码-1"><a href="#d，代码-1" class="headerlink" title="d，代码"></a>d，代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll a[N][N], d[N][N], p[N][N];<br><br><span class="hljs-type">int</span> main() {<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> n, m, q;<br><br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {<br><br>cin &gt;&gt; a[i][j];<br><br>}<br><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {<br><br>d[i][j] += a[i][j];<br><br>d[i + <span class="hljs-number">1</span>][j] -= a[i][j];<br><br>d[i][j + <span class="hljs-number">1</span>] -= a[i][j];<br><br>d[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] += a[i][j];<br><br>}<br><br>}<br><br>while (q--) {<br><br><span class="hljs-type">int</span> x1, y1, x2, y2, v;<br><br>cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; v;<br><br>d[x1][y1] += v;<br><br>d[x2 + <span class="hljs-number">1</span>][y1] -= v;<br><br>d[x1][y2 + <span class="hljs-number">1</span>] -= v;<br><br>d[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += v;<br><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {<br><br>a[i][j] = a[i - <span class="hljs-number">1</span>][j] + a[i][j - <span class="hljs-number">1</span>] - a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + d[i][j];<br><br>cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">' '</span>;<br><br>}<br><br>cout &lt;&lt; <span class="hljs-string">'\n'</span>;<br><br>}<br><br>}<br></code></pre></td></tr></table></figure><h3 id="6，前缀和例题鼠鼠我鸭"><a href="#6，前缀和例题鼠鼠我鸭" class="headerlink" title="6，前缀和例题鼠鼠我鸭"></a>6，前缀和例题鼠鼠我鸭</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">在一个叫做酱西功爷枝叶鸡树学院的地方有<span class="hljs-built_in">n</span>只小动物，要么是鼠鼠，要么是鸭鸭，从<span class="hljs-number">1</span>到<span class="hljs-built_in">n</span>编号，每只小动物有个体重ai​。<br><br>在这个学校里，存在一种神奇的魔法，可以将编号位于某个区间[l,r]内的所有鼠鼠都变为鸭鸭，鸭鸭都变为鼠鼠（魔法并不会改变体重）。<br><br>现在你可以施放这个魔法至多<span class="hljs-number">1</span>次。（也可以不施放）<br><br>问最终鸭鸭的总重量最多是多少？<br><br>//输入格式<br><br>第一行一个整数<span class="hljs-built_in">T</span>表示样例个数。(<span class="hljs-number">1</span>≤<span class="hljs-built_in">T</span>≤<span class="hljs-number">10</span>)<br><br>对于每个样例：<br><br>第一行一个整数<span class="hljs-built_in">n</span>表示小动物的个数。(<span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">1</span>e5)<br><br>第二行<span class="hljs-built_in">n</span>个整数，表示第i个小动物的类型。<span class="hljs-number">0</span>表示鼠鼠，<span class="hljs-number">1</span>表示鸭鸭。<br><br>第三行<span class="hljs-built_in">n</span>个整数，表示第i个小动物的体重ai​。(<span class="hljs-number">1</span>≤ai​≤<span class="hljs-number">1</span>e9)<br>### 样例输入<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br>### 样例输出<span class="hljs-number">1</span><br><span class="hljs-number">6</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h4 id="a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，-prefix-r-prefix-l-1-所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下"><a href="#a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，-prefix-r-prefix-l-1-所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下" class="headerlink" title="a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，$prefix[r]-prefix[l-1]$所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下"></a>a，由于我们要用的是前缀和，所以思路是前缀和方面的，首先我们可以先把全部里面的鸭对应的加上，然后我们对应的是一个区间的话，那么我们可以用前缀和区间求和的方式，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="23.936ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 10579.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(503,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(954,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1420,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(1970,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2315,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(2887,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(3165,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3616,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g><g data-mml-node="mo" transform="translate(4116.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(5116.4,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(5619.4,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6070.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(6536.4,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(7086.4,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7431.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(8003.4,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(8281.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(8801.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(9801.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(10301.9,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>所以我们现在要让这个尽量大，那我们就应该后面的尽量小，同时让prefix尽量大，所以代码如下</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go">#include &lt;bits/stdc++.h&gt;<br><br>using namespace std;<br><br>using ll = long long;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll a[N], prefix[N], v[N];<br><br><span class="hljs-type">int</span> main() {<br><br>ios::sync_with_stdio(<span class="hljs-number">0</span>), cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br><br><span class="hljs-type">int</span> t;<br><br>cin &gt;&gt; t;<br><br>while (t--) {<br><br><span class="hljs-type">int</span> n;<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">//存贮小鸭和鼠</span><br><br>cin &gt;&gt; a[i];<br><br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>cin &gt;&gt; v[i];<br><br>}<br><br>ll ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ans += v[i] * a[i];<span class="hljs-comment">//把鸭全部加上</span><br><br>ll mi = <span class="hljs-number">0</span>, fix = <span class="hljs-number">0</span>;<span class="hljs-comment">//fix代标校准</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br><span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>)<span class="hljs-comment">//说明是鼠可以用魔法变成鸭</span><br><br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] + v[i];<br><br><span class="hljs-keyword">else</span><br><br>prefix[i] = prefix[i - <span class="hljs-number">1</span>] - v[i];<br><br>fix = max(fix, prefix[i] - mi);<span class="hljs-comment">//prefix[r]-prefix[l-1]</span><br><br>mi = min(mi, prefix[i]);<span class="hljs-comment">//找到最小的prefix[l-1];</span><br><br>}<br><br>cout &lt;&lt; ans + fix &lt;&lt; <span class="hljs-string">'\n'</span>;<span class="hljs-comment">//将偏差值加起来就行</span><br><br>}<br><br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day2:component组件模块化思维，Vue-Router切换页面路由</title>
    <link href="/2023/09/14/day2-component%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E7%BB%B4%EF%BC%8CVue-Router%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1/"/>
    <url>/2023/09/14/day2-component%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E6%80%9D%E7%BB%B4%EF%BC%8CVue-Router%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h4 id="tips：当要上传github时gitigore会将依赖模块给屏蔽"><a href="#tips：当要上传github时gitigore会将依赖模块给屏蔽" class="headerlink" title="tips：当要上传github时gitigore会将依赖模块给屏蔽"></a>tips：当要上传github时gitigore会将依赖模块给屏蔽</h4><h4 id="重新打开页面："><a href="#重新打开页面：" class="headerlink" title="重新打开页面："></a>重新打开页面：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pnpm install <span class="hljs-comment">//重新安装依赖</span><br>pnpm run dev <span class="hljs-comment">//就可以运行</span><br></code></pre></td></tr></table></figure><h4 id="Vite的目录结构"><a href="#Vite的目录结构" class="headerlink" title="Vite的目录结构"></a>Vite的目录结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── README<span class="hljs-selector-class">.md</span> <span class="hljs-comment">// 说明</span><br>├── index<span class="hljs-selector-class">.html</span> <span class="hljs-comment">// html文件</span><br>├── package<span class="hljs-selector-class">.json</span> <span class="hljs-comment">// 项目基本信息</span><br>├── public <span class="hljs-comment">// 公共模块</span><br>│   └── vite<span class="hljs-selector-class">.svg</span><br>├── <span class="hljs-attribute">src</span>  // 源码目录<br>│   ├── App<span class="hljs-selector-class">.vue</span> <span class="hljs-comment">// 入口文件</span><br>│   ├── assets <span class="hljs-comment">// 公共资源</span><br>│   │   └── vue<span class="hljs-selector-class">.svg</span><br>│   ├── components<br>│   │   └── HelloWorld<span class="hljs-selector-class">.vue</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.ts</span> <span class="hljs-comment">// 入口文件，加载公共组件</span><br>│   ├── style<span class="hljs-selector-class">.css</span><br>│   └── vite-env<span class="hljs-selector-class">.d</span><span class="hljs-selector-class">.ts</span><br>├── tsconfig<span class="hljs-selector-class">.json</span> <span class="hljs-comment">// ts配置</span><br>├── tsconfig<span class="hljs-selector-class">.node</span><span class="hljs-selector-class">.json</span><br>└── vite<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.ts</span>   <span class="hljs-comment">// 项目基本信息</span><br></code></pre></td></tr></table></figure><h5 id="component组件模块化思维"><a href="#component组件模块化思维" class="headerlink" title="component组件模块化思维"></a>component组件模块化思维</h5><h6 id="简而言之就是说将一个页面划分成不同的部分，分别完成最后像搭积木一样搭起来。而积木的实现就是写一个个组件"><a href="#简而言之就是说将一个页面划分成不同的部分，分别完成最后像搭积木一样搭起来。而积木的实现就是写一个个组件" class="headerlink" title="简而言之就是说将一个页面划分成不同的部分，分别完成最后像搭积木一样搭起来。而积木的实现就是写一个个组件"></a>简而言之就是说将一个页面划分成不同的部分，分别完成最后像搭积木一样搭起来。而积木的实现就是写一个个组件</h6><h4 id="创建vite-Ts"><a href="#创建vite-Ts" class="headerlink" title="创建vite+Ts"></a>创建vite+Ts</h4><h5 id="建议在Webstrom中进行创建"><a href="#建议在Webstrom中进行创建" class="headerlink" title="建议在Webstrom中进行创建"></a>建议在Webstrom中进行创建</h5><h6 id="a，点开“新建”然后找到vite，将目录设置为自己提前创建好的空文件夹，然后把下面的Typescript勾上。"><a href="#a，点开“新建”然后找到vite，将目录设置为自己提前创建好的空文件夹，然后把下面的Typescript勾上。" class="headerlink" title="a，点开“新建”然后找到vite，将目录设置为自己提前创建好的空文件夹，然后把下面的Typescript勾上。"></a>a，点开“新建”然后找到vite，将目录设置为自己提前创建好的空文件夹，然后把下面的Typescript勾上。</h6><h4 id="Vue-Router的安装，用途和使用"><a href="#Vue-Router的安装，用途和使用" class="headerlink" title="Vue-Router的安装，用途和使用"></a>Vue-Router的安装，用途和使用</h4><h6 id="首先是Vue-Router的安装"><a href="#首先是Vue-Router的安装" class="headerlink" title="首先是Vue-Router的安装"></a>首先是Vue-Router的安装</h6><p>npm install vue-router@4<br>//建议将npm换成cnpm，应为有时候梯子会不稳定，最后换成淘宝源</p><h6 id="安装了后看一下package-json中有没有Vue-Router"><a href="#安装了后看一下package-json中有没有Vue-Router" class="headerlink" title="安装了后看一下package.json中有没有Vue-Router"></a>安装了后看一下package.json中有没有Vue-Router</h6><h6 id="接着是Vue-Router的用途"><a href="#接着是Vue-Router的用途" class="headerlink" title="接着是Vue-Router的用途"></a>接着是Vue-Router的用途</h6><h6 id="就是通过单页面来模拟多页面。"><a href="#就是通过单页面来模拟多页面。" class="headerlink" title="就是通过单页面来模拟多页面。"></a>就是通过单页面来模拟多页面。</h6><h6 id="然后是Vue-Router的使用"><a href="#然后是Vue-Router的使用" class="headerlink" title="然后是Vue-Router的使用"></a>然后是Vue-Router的使用</h6><h6 id="a，首先在src中创建pages和routers两个目录"><a href="#a，首先在src中创建pages和routers两个目录" class="headerlink" title="a，首先在src中创建pages和routers两个目录"></a>a，首先在src中创建pages和routers两个目录</h6><h6 id="b，routers中创建index-ts"><a href="#b，routers中创建index-ts" class="headerlink" title="b，routers中创建index.ts"></a>b，routers中创建index.ts</h6><h6 id="c，我们这里使用的是router-view，没有用router-link。"><a href="#c，我们这里使用的是router-view，没有用router-link。" class="headerlink" title="c，我们这里使用的是router-view，没有用router-link。"></a>c，我们这里使用的是router-view，没有用router-link。</h6><h6 id="d，在components中创建vue1-vue-vue2-vue，便于用来展示vue-router的作用"><a href="#d，在components中创建vue1-vue-vue2-vue，便于用来展示vue-router的作用" class="headerlink" title="d，在components中创建vue1.vue,vue2.vue，便于用来展示vue-router的作用"></a>d，在components中创建vue1.vue,vue2.vue，便于用来展示vue-router的作用</h6><h6 id="在index-ts的操作"><a href="#在index-ts的操作" class="headerlink" title="在index.ts的操作"></a>在index.ts的操作</h6><h6 id="a，导入Helloworld，vue1，vue2的包"><a href="#a，导入Helloworld，vue1，vue2的包" class="headerlink" title="a，导入Helloworld，vue1，vue2的包"></a>a，导入Helloworld，vue1，vue2的包</h6><h6 id="b，接着是定义一些路由，那些在routes里面的就是一些路由"><a href="#b，接着是定义一些路由，那些在routes里面的就是一些路由" class="headerlink" title="b，接着是定义一些路由，那些在routes里面的就是一些路由"></a>b，接着是定义一些路由，那些在routes里面的就是一些路由</h6><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts">const <span class="hljs-attr">routes</span> <span class="hljs-operator">=</span> [  <br>    <span class="hljs-punctuation">&#123;</span>  <br><span class="hljs-symbol">        path:</span><span class="hljs-string">&quot;/&quot;</span>,  <br><span class="hljs-symbol">        name:</span><span class="hljs-string">&quot;Home&quot;</span>,  <br><span class="hljs-symbol">        component:</span>HelloWorld  <br>    <span class="hljs-punctuation">&#125;</span>,  <br>    <span class="hljs-punctuation">&#123;</span>  <br><span class="hljs-symbol">        path:</span><span class="hljs-string">&quot;/vue1&quot;</span>,  <br><span class="hljs-symbol">        name:</span><span class="hljs-string">&quot;Vue1&quot;</span>,  <br><span class="hljs-symbol">        component:</span>vue1  <br>    <span class="hljs-punctuation">&#125;</span>,  <br>    <span class="hljs-punctuation">&#123;</span>  <br><span class="hljs-symbol">        path:</span><span class="hljs-string">&quot;/vue2&quot;</span>,  <br><span class="hljs-symbol">        name:</span><span class="hljs-string">&quot;Vue2&quot;</span>,  <br><span class="hljs-symbol">        component:</span>vue2  <br>    <span class="hljs-punctuation">&#125;</span>  <br>  <br>]<br></code></pre></td></tr></table></figure><h6 id="c，创建路由并传递”routes”配置"><a href="#c，创建路由并传递”routes”配置" class="headerlink" title="c，创建路由并传递”routes”配置"></a>c，创建路由并传递”routes”配置</h6><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lisp">const router = createRouter(  <br>    &#123;  <br>    history<span class="hljs-symbol">:createWebHistory</span>(),  <br>    routes<span class="hljs-symbol">:routes</span>  <br>    &#125;  <br>)<br></code></pre></td></tr></table></figure><h6 id="d，变成全局变量"><a href="#d，变成全局变量" class="headerlink" title="d，变成全局变量"></a>d，变成全局变量</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span><span class="hljs-built_in"> default </span>router;<br></code></pre></td></tr></table></figure><h6 id="e，-创建并且挂载根实例-在main-ts"><a href="#e，-创建并且挂载根实例-在main-ts" class="headerlink" title="e， 创建并且挂载根实例(在main.ts)"></a>e， 创建并且挂载根实例(在main.ts)</h6><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = createApp(<span class="hljs-keyword">App</span>);  <br>  <br><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(router);  <br>  <br><span class="hljs-keyword">app</span>.mount(&#x27;#<span class="hljs-keyword">app</span>&#x27;);<br></code></pre></td></tr></table></figure><h5 id="在App-vue的操作-😊"><a href="#在App-vue的操作-😊" class="headerlink" title="在App.vue的操作 😊"></a>在App.vue的操作 😊</h5><h6 id="a，加入router"><a href="#a，加入router" class="headerlink" title="a，加入router"></a>a，加入router</h6><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123; RouterView &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br></code></pre></td></tr></table></figure><h6 id="b，在template"><a href="#b，在template" class="headerlink" title="b，在template"></a>b，在template</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;router-view /&gt;</span><br></code></pre></td></tr></table></figure><h5 id="在vue1和vue2的操作"><a href="#在vue1和vue2的操作" class="headerlink" title="在vue1和vue2的操作"></a>在vue1和vue2的操作</h5><h6 id="在template中写点字说明好表现出结果"><a href="#在template中写点字说明好表现出结果" class="headerlink" title="在template中写点字说明好表现出结果"></a>在template中写点字说明好表现出结果</h6><h5 id="捋一下vue-router的逻辑"><a href="#捋一下vue-router的逻辑" class="headerlink" title="捋一下vue-router的逻辑"></a>捋一下vue-router的逻辑</h5><p>1，首先是创建路由，就是在index.ts中创建<br>2，在main.ts进行挂载<br>3，在App.vue进行展示,即是导入router-viewer</p><h5 id="实现好后那么跳转页面就在网址后面加个-vue1即可跳转"><a href="#实现好后那么跳转页面就在网址后面加个-vue1即可跳转" class="headerlink" title="实现好后那么跳转页面就在网址后面加个/vue1即可跳转"></a>实现好后那么跳转页面就在网址后面加个/vue1即可跳转</h5><h5 id="在学习的时候遇到的遇难杂症"><a href="#在学习的时候遇到的遇难杂症" class="headerlink" title="在学习的时候遇到的遇难杂症"></a>在学习的时候遇到的遇难杂症</h5><h6 id="首先是在Webstrom中有对TS语法有比较严格的要求，所以有时候在写的过程中会报错也不要过于在意。"><a href="#首先是在Webstrom中有对TS语法有比较严格的要求，所以有时候在写的过程中会报错也不要过于在意。" class="headerlink" title="首先是在Webstrom中有对TS语法有比较严格的要求，所以有时候在写的过程中会报错也不要过于在意。"></a>首先是在Webstrom中有对TS语法有比较严格的要求，所以有时候在写的过程中会报错也不要过于在意。</h6><h6 id="切记，最好用Webstrom进行vite框架的安装，如果不行那么进行手动更改的话，有可能当在别的文件调用对应Vue的包，有可能会无法被找到"><a href="#切记，最好用Webstrom进行vite框架的安装，如果不行那么进行手动更改的话，有可能当在别的文件调用对应Vue的包，有可能会无法被找到" class="headerlink" title="切记，最好用Webstrom进行vite框架的安装，如果不行那么进行手动更改的话，有可能当在别的文件调用对应Vue的包，有可能会无法被找到"></a>切记，最好用Webstrom进行vite框架的安装，如果不行那么进行手动更改的话，有可能当在别的文件调用对应Vue的包，有可能会无法被找到</h6><p><a href="https://zhuanlan.zhihu.com/p/406510652">vue3 报错解决：找不到模块或其相应的类型声明。（Vue 3 can not find module） - 知乎 (zhihu.com)</a><br>这个就是解决方案，但是最好就是在Webstorm中创建。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建和踩过的坑</title>
    <link href="/2023/09/13/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <url>/2023/09/13/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1，hexo的平台搭建"><a href="#1，hexo的平台搭建" class="headerlink" title="1，hexo的平台搭建"></a>1，hexo的平台搭建</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h5><p>1， 弄个github账号<br>2，安装Nodejs<br>3，安装git </p><h5 id="Git-详细安装教程（详解-Git-安装过程的每一个步骤）-git安装-CSDN博客"><a href="#Git-详细安装教程（详解-Git-安装过程的每一个步骤）-git安装-CSDN博客" class="headerlink" title="Git 详细安装教程（详解 Git 安装过程的每一个步骤）_git安装-CSDN博客"></a><a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）_git安装-CSDN博客</a></h5><h5 id="node-js安装及环境配置超详细教程【Windows系统安装包方式】-知乎-zhihu-com"><a href="#node-js安装及环境配置超详细教程【Windows系统安装包方式】-知乎-zhihu-com" class="headerlink" title="node.js安装及环境配置超详细教程【Windows系统安装包方式】 - 知乎 (zhihu.com)"></a><a href="https://zhuanlan.zhihu.com/p/442215189">node.js安装及环境配置超详细教程【Windows系统安装包方式】 - 知乎 (zhihu.com)</a></h5><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><h6 id="使用-Hexo-GitHub-搭建个人免费博客教程（小白向）-知乎-zhihu-com"><a href="#使用-Hexo-GitHub-搭建个人免费博客教程（小白向）-知乎-zhihu-com" class="headerlink" title="使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)"></a><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></h6><h6 id="用这个文章差不多能搞定"><a href="#用这个文章差不多能搞定" class="headerlink" title="用这个文章差不多能搞定"></a>用这个文章差不多能搞定</h6><h6 id="会碰到的坑："><a href="#会碰到的坑：" class="headerlink" title="会碰到的坑："></a>会碰到的坑：</h6><p>1，git经常命令无法执行，有可能是管理员权限未开，需要开启。<br>    开启步骤:右键Git bash点属性然后点到兼容性，找到以管理员身份运行。<br>2，<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><br>会碰到npm不能用到的情况这时候就需要换成cnpm</p><h6 id="npmmirror-镜像站-里面就有换源，然后将npm换成cnpm就行"><a href="#npmmirror-镜像站-里面就有换源，然后将npm换成cnpm就行" class="headerlink" title="npmmirror 镜像站 里面就有换源，然后将npm换成cnpm就行"></a><a href="https://npmmirror.com/">npmmirror 镜像站</a> 里面就有换源，然后将npm换成cnpm就行</h6><p>3,还有就是将<a href="https://YourName.github.io作为域名的操作">https://YourName.github.io作为域名的操作</a></p><h4 id="2，hexo的常用指令"><a href="#2，hexo的常用指令" class="headerlink" title="2，hexo的常用指令"></a>2，hexo的常用指令</h4><h5 id="a，初始化和安装所需组件"><a href="#a，初始化和安装所需组件" class="headerlink" title="a，初始化和安装所需组件"></a>a，初始化和安装所需组件</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">hexo init ##初始化<br>npm install ##安装组件，建议先将下载路径换成淘宝镜像，上面就有镜像站链接<br></code></pre></td></tr></table></figure><h5 id="b-一些搭配使用"><a href="#b-一些搭配使用" class="headerlink" title="b,一些搭配使用"></a>b,一些搭配使用</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">hexo clean ##清除缓存，有时候有用<br>hexo g ##生成<br>hexo d ##文件生成后立即部署网站<br><span class="hljs-comment">//这三个经常一起使用</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo n <span class="hljs-string">&quot;你自己取&quot;</span> <span class="hljs-comment">//创建一个新的博客会在source文件夹的post_(好像是)用markdown语法就行</span><br>hexo g <br>hexo d<br><span class="hljs-comment">//就可以将你写的博客部署到静态网站</span><br></code></pre></td></tr></table></figure><h4 id="3-一些好看的主题"><a href="#3-一些好看的主题" class="headerlink" title="3,一些好看的主题"></a>3,一些好看的主题</h4><h6 id="首先可以在github上搜，上面会有配置文档叫你如何配置"><a href="#首先可以在github上搜，上面会有配置文档叫你如何配置" class="headerlink" title="首先可以在github上搜，上面会有配置文档叫你如何配置"></a>首先可以在github上搜，上面会有配置文档叫你如何配置</h6><h6 id="九个好看实用的Hexo主题推荐-掘金-juejin-cn"><a href="#九个好看实用的Hexo主题推荐-掘金-juejin-cn" class="headerlink" title="九个好看实用的Hexo主题推荐 - 掘金 (juejin.cn)"></a><a href="https://juejin.cn/post/7053744641383874574">九个好看实用的Hexo主题推荐 - 掘金 (juejin.cn)</a></h6><h6 id="【教程】下载Hexo主题，并做相应的配置和优化-知乎-zhihu-com"><a href="#【教程】下载Hexo主题，并做相应的配置和优化-知乎-zhihu-com" class="headerlink" title="【教程】下载Hexo主题，并做相应的配置和优化 - 知乎 (zhihu.com)"></a><a href="https://zhuanlan.zhihu.com/p/137616422">【教程】下载Hexo主题，并做相应的配置和优化 - 知乎 (zhihu.com)</a></h6><p>主题和在配置中遇到的一些问题都能得到解决</p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端环境搭建和Eslint搭配</title>
    <link href="/2023/09/12/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8CEslint%E6%90%AD%E9%85%8D/"/>
    <url>/2023/09/12/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8CEslint%E6%90%AD%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h4 id="ide是Webstorm"><a href="#ide是Webstorm" class="headerlink" title="ide是Webstorm"></a>ide是Webstorm</h4><h3 id="1-Vue的安装"><a href="#1-Vue的安装" class="headerlink" title="1, Vue的安装"></a>1, Vue的安装</h3><h5 id="a-Nodejs的安装"><a href="#a-Nodejs的安装" class="headerlink" title="a, Nodejs的安装"></a>a, Nodejs的安装</h5><h6 id="node-js安装及环境配置超详细教程【Windows系统安装包方式】-知乎-zhihu-com"><a href="#node-js安装及环境配置超详细教程【Windows系统安装包方式】-知乎-zhihu-com" class="headerlink" title="node.js安装及环境配置超详细教程【Windows系统安装包方式】 - 知乎 (zhihu.com)"></a><a href="https://zhuanlan.zhihu.com/p/442215189">node.js安装及环境配置超详细教程【Windows系统安装包方式】 - 知乎 (zhihu.com)</a></h6><h5 id="b-安装pnpm和淘宝镜像源"><a href="#b-安装pnpm和淘宝镜像源" class="headerlink" title="b,安装pnpm和淘宝镜像源"></a>b,安装pnpm和淘宝镜像源</h5><h6 id="npmmirror-镜像站"><a href="#npmmirror-镜像站" class="headerlink" title="npmmirror 镜像站"></a><a href="https://npmmirror.com/">npmmirror 镜像站</a></h6><h6 id="pnpm安装"><a href="#pnpm安装" class="headerlink" title="pnpm安装"></a>pnpm安装</h6><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pnpm<br></code></pre></td></tr></table></figure><h5 id="c-Vue框架"><a href="#c-Vue框架" class="headerlink" title="c,Vue框架"></a>c,Vue框架</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//安装Vue框架</span><br>pnpm create vite my-vue-app --<span class="hljs-keyword">template</span> vue<br><span class="hljs-comment">//然后安装依赖</span><br>pnpm install<br><span class="hljs-comment">//运行</span><br>pnpm run dev<br></code></pre></td></tr></table></figure><h3 id="2-EsLint代码规范"><a href="#2-EsLint代码规范" class="headerlink" title="2, EsLint代码规范"></a>2, EsLint代码规范</h3><h5 id="a-WebStorm快速配置EsLint-TiancyのBlog-tianci-blog-top-看这一篇就可以"><a href="#a-WebStorm快速配置EsLint-TiancyのBlog-tianci-blog-top-看这一篇就可以" class="headerlink" title="a,WebStorm快速配置EsLint | TiancyのBlog (tianci-blog.top)看这一篇就可以"></a>a,<a href="http://www.tianci-blog.top/2023/09/03/fix-eslint-in-webstorm/">WebStorm快速配置EsLint | TiancyのBlog (tianci-blog.top)</a>看这一篇就可以</h5>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
