<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="iolzyy">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="https://download.tooc.xlj0.com/uploads/179/leimu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">iolzyy</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=id=https://music.163.com/song?id=1944058085&userid=1954034794&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Atcoder/" style="font-size: 10px;">Atcoder</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 17.5px;">前端</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">前端学习</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" style="font-size: 10px;">博客搭建</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" style="font-size: 20px;">基础算法</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 12.5px;">深度学习</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 12.5px;">算法基础</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 15px;">蓝桥杯</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.tiancy.top/">tiancy</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://blog.cnpatrickstar.com/">派大星</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://salt114514.github.io/">salt</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="/blog.bluebird.icu">青鸟</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://houbb.github.io/">echo</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://download.tooc.xlj0.com/uploads/179/leimu.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-GNN" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/04/16/GNN/" class="article-date">
  	<time datetime="2024-04-16T07:02:54.000Z" itemprop="datePublished">2024-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/04/16/GNN/">
        GNN
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub"><a href="#参考：A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub" class="headerlink" title="参考：A Gentle Introduction to Graph Neural Networks (distill.pub)"></a>参考：<a target="_blank" rel="noopener" href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a></h4><h4 id="零基础多图详解图神经网络（GNN-GCN）-youtube-com"><a href="#零基础多图详解图神经网络（GNN-GCN）-youtube-com" class="headerlink" title="零基础多图详解图神经网络（GNN&#x2F;GCN） (youtube.com)"></a><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=sejA2PtCITw&t=770s">零基础多图详解图神经网络（GNN&#x2F;GCN） (youtube.com)</a></h4><h4 id="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"><a href="#总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。" class="headerlink" title="总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。"></a>总结：首先是一个图的三要素是：点v，边e，整体U。然后边是有无向边和有向边，然后每个点和边和整体都能存储信息。</h4><h4 id="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"><a href="#对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。" class="headerlink" title="对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。"></a>对于图片的存储可以将像素点和周围的像素点进行相连就是一个图，对于文本来说就是一个句子，然后连起来，这也是一个图。而且对于其他很多东西都可以看成图，比如一个化学分子，里面的一个分子旁边联系其他的分子，这也是图，在生活中，在歌剧中，不同人物同时出现也可以进行连接，也是一张图，有很多东西都可以抽象成图。</h4><h3 id="图的预测问题"><a href="#图的预测问题" class="headerlink" title="图的预测问题"></a>图的预测问题</h3><h4 id="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"><a href="#图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性-，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。" class="headerlink" title="图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。"></a>图的预测问题需要的是三个问题：图，边，点。低于图就是要预测图的单一属性 ，对于节点级任务，我们要预测图中每个节点的某些属性。在边缘级任务中，我们要预测图中边缘的属性或存在。</h4><h4 id="图的任务："><a href="#图的任务：" class="headerlink" title="图的任务："></a>图的任务：</h4><h5 id="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"><a href="#举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。" class="headerlink" title="举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。"></a>举个例子就是说我在图这个级别，就比如我想要查找到有两个环的分子，我就要在图这个层面的来判断这个属性。我们希望将标签与整幅图像关联起来。对于文本，类似的问题是情感分析，我们希望一次性识别整个句子的情绪或情感。</h5><h4 id="节点的任务："><a href="#节点的任务：" class="headerlink" title="节点的任务："></a>节点的任务：</h4><h5 id="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"><a href="#节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi-先生（教练）和-John-H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于-Hi-先生还是忠于-John-H-进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。" class="headerlink" title="节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。"></a>节点级预测问题的一个经典例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠于两个空手道俱乐部之一的个人组成。故事讲述的是，Hi 先生（教练）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表空手道练习者个人，边代表这些成员之间在空手道之外的互动。预测问题是对某个成员在不和之后是忠于 Hi 先生还是忠于 John H 进行分类。在这种情况下，节点与教练或管理员之间的距离与这一标签高度相关。根据图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的角色。对于文本，类似的任务是预测句子中每个单词的语音部分（如名词、动词、副词等）。</h5><h4 id="边的任务："><a href="#边的任务：" class="headerlink" title="边的任务："></a>边的任务：</h4><h5 id="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"><a href="#边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。" class="headerlink" title="边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。"></a>边缘级推理的一个例子是图像场景理解。除了识别图像中的物体，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中物体的节点，我们希望预测这些节点中哪些共享一条边缘，或者这条边缘的值是多少。如果我们希望发现实体之间的联系，我们可以考虑完全连接的图，并根据预测值修剪边，从而得到一个稀疏的图。</h5><h3 id="在机器学习中使用图的挑战"><a href="#在机器学习中使用图的挑战" class="headerlink" title="在机器学习中使用图的挑战"></a>在机器学习中使用图的挑战</h3><h4 id="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"><a href="#首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。" class="headerlink" title="首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。"></a>首先是图的连通性，因为数据量很大，所以我们用的邻接矩阵，由于数据比较稀疏，而且稀疏矩阵在深度学习中不好处理。</h4><h4 id="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"><a href="#比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。" class="headerlink" title="比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。"></a>比如一个四个节点组成的邻接矩阵就已经有相当多的，就有24个，所以当节点很多，那么数据量很大。</h4><h4 id="我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。"><a href="#我们可以用邻接表来解决问题，图中每个节点-边-全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为-nnodes-的节点张量，而不是-nnodes-的节点张量。我们将处理大小为-nnodes-nodedim-的节点张量。" class="headerlink" title="我们可以用邻接表来解决问题，图中每个节点&#x2F;边&#x2F;全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。"></a>我们可以用邻接表来解决问题，图中每个节点&#x2F;边&#x2F;全局使用的是标量值，但大多数实用的张量表示法都是每个图形属性使用向量。我们将处理的是大小为 [nnodes] 的节点张量，而不是 [nnodes] 的节点张量。我们将处理大小为 [nnodes,nodedim] 的节点张量。</h4><h3 id="什么是GNN"><a href="#什么是GNN" class="headerlink" title="什么是GNN"></a>什么是GNN</h3><h4 id="GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"><a href="#GNN-是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。" class="headerlink" title="GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。"></a>GNN 是对图的所有属性（节点、边、全局上下文）进行的可优化变换，它保留了图的对称性（包络不变性）。这个就是GNN的假设，保证了图的不变性，就是说，无论GNN怎么样，图都是不会变的。</h4><h4 id="最简单的GNN"><a href="#最简单的GNN" class="headerlink" title="最简单的GNN"></a>最简单的GNN</h4><h5 id="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"><a href="#为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种-GNN-在图的每个分量上使用一个单独的多层感知器-MLP-（或你最喜欢的可微分模型）；我们称其为-GNN-层。对于每个节点向量，我们应用-MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。" class="headerlink" title="为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。"></a>为简单起见，前面的图使用标量来表示图属性；实际上，特征向量或嵌入要有用得多。这种 GNN 在图的每个分量上使用一个单独的多层感知器 (MLP)（或你最喜欢的可微分模型）；我们称其为 GNN 层。对于每个节点向量，我们应用 MLP，并得到一个学习到的节点向量。我们对每条边进行同样的处理，学习每条边的嵌入，同时也对全局上下文向量进行处理，学习整个图的单一嵌入。</h5><h5 id="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"><a href="#就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。" class="headerlink" title="就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。"></a>就是说我把u，e，v扔到一层mlp层就会输出新的u，e，v，但是这个最简单的就是三个数据都是独立的，就是不会对另外两个属性造成影响。</h5><h4 id="通过Pooling信息进行-GNN-预测"><a href="#通过Pooling信息进行-GNN-预测" class="headerlink" title="通过Pooling信息进行 GNN 预测"></a>通过Pooling信息进行 GNN 预测</h4><h5 id="我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"><a href="#我们已经构建了一个简单的-GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。" class="headerlink" title="我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。"></a>我们已经构建了一个简单的 GNN，但如何对上述任务进行预测呢？我们将考虑二元分类的情况，但这一框架很容易扩展到多类或回归情况。如果任务是对节点进行二元预测，而图中已经包含了节点信息，那么方法就很简单了–对每个节点嵌入应用一个线性分类器。就这个可以缩写成c。</h5><h5 id="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"><a href="#图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总" class="headerlink" title="图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总"></a>图中的信息可能存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来收集边上的信息，就是把每一个点连接的边，并将其提供给节点进行预测。我们可以通过汇集来实现这一目的。汇集分两步进行：对于要汇集的每个项目，收集它们的每个嵌入信息，并将它们连接成一个矩阵。然后，通常通过求和操作对收集到的嵌入式数据进行汇总</h5><h5 id="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"><a href="#因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。" class="headerlink" title="因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。"></a>因此，如果我们只有边缘级特征，并试图预测二进制节点信息，我们可以使用池化技术将信息路由（或传递）到需要的地方。模型看起来是这样的，此时我们只有边的特征就是通过池化层，然后在进行分类器分类就可以得到预测的v。同理其他请况也是这样。</h5><h5 id="在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"><a href="#在我们的例子中，分类模型-c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。" class="headerlink" title="在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。"></a>在我们的例子中，分类模型 c可以很容易地被任何可微分模型所替代，或者使用广义线性模型来适应多类分类。</h5><h5 id="现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"><a href="#现在我们已经证明，我们可以建立一个简单的-GNN-模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂-GNN-模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的-GNN-模型中，我们在-GNN-层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。" class="headerlink" title="现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。"></a>现在我们已经证明，我们可以建立一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二进制预测。这种汇集技术将成为构建更复杂 GNN 模型的基石。如果我们有了新的图属性，我们只需定义如何将信息从一个属性传递到另一个属性。请注意，在这个最简单的 GNN 模型中，我们在 GNN 层内完全没有使用图的连接性。每个节点、每条边以及全局上下文都是独立处理的。我们只在汇集信息进行预测时使用连接性。</h5><h4 id="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"><a href="#这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。" class="headerlink" title="这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。"></a>这个流程是读入图，然后经过GNN层mlp，让后的得到新的图，然后进入分类器，最后预测。</h4><h3 id="在图的不同部分之间传递信息"><a href="#在图的不同部分之间传递信息" class="headerlink" title="在图的不同部分之间传递信息"></a>在图的不同部分之间传递信息</h3><h4 id="三个步骤："><a href="#三个步骤：" class="headerlink" title="三个步骤："></a>三个步骤：</h4><blockquote>
<p>首先对于图中的每个节点，收集所有相邻节点的嵌入（或信息）。<br>通过聚合函数（如 sum）汇总所有信息。<br>所有汇集的信息将通过一个更新函数（通常是一个学习的神经网络）进行传递。<br>中间的transgorm information可以看出一个f</p>
</blockquote>
<h4 id="这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"><a href="#这一系列操作只需应用一次，就是最简单的信息传递-GNN-层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递-GNN-层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。" class="headerlink" title="这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。"></a>这一系列操作只需应用一次，就是最简单的信息传递 GNN 层。这不禁让人联想到标准卷积：从本质上讲，信息传递和卷积都是汇总和处理元素邻域信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，而图像则不同，每个像素都有固定数量的相邻元素。通过将消息传递 GNN 层层堆叠在一起，一个节点最终可以包含来自整个图的信息：经过三层之后，一个节点就可以获得距离它三步远的节点的信息。我们可以更新架构图，将这一新的节点信息源纳入其中。</h4><h4 id="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"><a href="#但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。" class="headerlink" title="但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。"></a>但是卷积的3×3的方块，每次都是不一样的，但是图确实一样的。</h4><h3 id="学习边缘表征"><a href="#学习边缘表征" class="headerlink" title="学习边缘表征"></a>学习边缘表征</h3><h4 id="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"><a href="#我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。" class="headerlink" title="我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。"></a>我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边缘信息时，我们在上文展示了如何使用池化技术将信息从边缘传递到节点，但只在模型的最后预测步骤中使用。</h4><h4 id="我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"><a href="#我们可以在-GNN-层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。" class="headerlink" title="我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。"></a>我们可以在 GNN 层内使用消息传递在节点和边缘之间共享信息。我们可以采用与之前使用邻近节点信息相同的方式，将邻近边缘的信息纳入其中，方法是首先汇集边缘信息，使用更新函数对其进行转换，然后将其存储起来。然而，图中存储的节点信息和边信息的大小和形状不一定相同，因此如何将它们结合起来并不明确。一种方法是学习从边缘空间到节点空间的线性映射，反之亦然。另一种方法是在更新函数之前将它们串联起来。</h4><h4 id="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"><a href="#就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。" class="headerlink" title="就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。"></a>就是说比如我们知道的是边的特征，然后想给点的特征进行更新，就将边组成的信息给到点，然后回到边的信息。</h4><h4 id="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"><a href="#还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。" class="headerlink" title="还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。"></a>还有好几种情况：节点到节点（线性）、边缘到边缘（线性）、节点到边缘（边缘层）、边缘到节点（节点层）。</h4><h4 id="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"><a href="#就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。" class="headerlink" title="就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。"></a>就拿节点然后到边缘举例，就是先将数据给点然后再给到边，和节点数据给到边然后再给回节点是有区别的。</h4><h3 id="添加全局表示"><a href="#添加全局表示" class="headerlink" title="添加全局表示"></a>添加全局表示</h3><h4 id="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。"><a href="#迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有-k-层，信息最多只能传播-k-步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为-“虚拟边-“的方法已被用于分子等小型图）。" class="headerlink" title="迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。"></a>迄今为止，我们所描述的网络存在一个缺陷：图中相距较远的节点可能永远无法有效地相互传递信息，即使我们多次应用消息传递也是如此。对于一个节点，如果我们有 k 层，信息最多只能传播 k 步。如果预测任务依赖于相距甚远的节点或节点组，这就会成为一个问题。一种解决方案是让所有节点都能相互传递信息。遗憾的是，对于大型图而言，这种方法的计算成本很快就会变得很高（尽管这种被称为 “虚拟边 “的方法已被用于分子等小型图）。</h4><h4 id="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"><a href="#解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点-或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。" class="headerlink" title="解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。"></a>解决这一问题的方法之一是使用图的全局表示法（U），有时也称为主节点  或上下文向量。这个全局上下文向量与网络中的所有其他节点和边相连，可以作为它们之间传递信息的桥梁，为整个图建立一个表征。这就为图形创建了比学习到的更丰富、更复杂的表示。</h4><h4 id="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"><a href="#在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。" class="headerlink" title="在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。"></a>在这种观点中，所有图属性都有学习到的表征，因此我们可以在池化过程中，通过将我们感兴趣的属性的信息与其他属性的信息进行比对来利用这些表征。例如，对于一个节点，我们可以考虑来自邻近节点、连接边和全局信息的信息。为了将所有这些可能的信息源作为新节点嵌入的条件，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层这可以被视为一种按特征划分的关注机制。</h4><h4 id="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"><a href="#就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。" class="headerlink" title="就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。"></a>就是说我想要对边的特征更加细致，那我可以用全局的特征和点的特征拿去处理，同理对其他的属性也是如此。</h4><h4 id="A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"><a href="#A-Gentle-Introduction-to-Graph-Neural-Networks-distill-pub-在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好" class="headerlink" title="A Gentle Introduction to Graph Neural Networks (distill.pub)在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好"></a><a target="_blank" rel="noopener" href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks (distill.pub)</a>在gnn-intro一文中的playground我们可以看到有几个超属性，有深度，pooling池的聚合方式，点的数据集大小，边的数据集的大小，全局的数据集的大小。然后AUC就可以看出这个模型拟合程度，越高越好</h4><h4 id="GNN-中的采样图和批处理"><a href="#GNN-中的采样图和批处理" class="headerlink" title="GNN 中的采样图和批处理"></a>GNN 中的采样图和批处理</h4><h5 id="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。"><a href="#训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为-k-的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN-可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离-k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或-Metropolis-算法）来构建恒定大小的邻域。" class="headerlink" title="训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。"></a>训练神经网络的常用方法是通过随机恒定大小（批次大小）的训练数据子集（迷你批次）计算梯度来更新网络参数。由于相邻节点和边的数量存在变化，这意味着我们无法设定恒定的批次大小，因此这种做法对图形来说是一个挑战。对图形进行批处理的主要思路是创建子图，以保留较大图形的基本属性。这种图采样操作高度依赖于上下文，涉及从图中子选择节点和边。在某些情况下（引文网络），这些操作可能是合理的，而在其他情况下，这些操作可能过于强势（分子，一个子图仅仅代表一个新的、更小的分子）。如何对图进行采样是一个尚未解决的研究问题。如果我们关心的是在邻域级别保留结构，那么一种方法就是随机抽取一定数量的节点，即我们的节点集。然后添加与节点集相邻的距离为 k 的相邻节点，包括它们的边。每个邻域可视为一个单独的图，GNN 可在这些子图的批次上进行训练。由于所有相邻节点都有不完整的邻域，因此可以掩盖损失，只考虑节点集。更有效的策略可能是先随机抽样一个节点，将其邻域扩大到距离 k，然后在扩大的集合中挑选其他节点。一旦构建了一定数量的节点、边或子图，就可以终止这些操作。如果情况允许，我们可以通过选取一个初始节点集，然后对一定数量的节点进行子采样（例如随机采样，或通过随机漫步或 Metropolis 算法）来构建恒定大小的邻域。</h5><h5 id="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"><a href="#就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。" class="headerlink" title="就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。"></a>就比如说我想采样一张图，我可以随机步长采取一定的图的属性，或者完全随机采样都可以。</h5><h3 id="归纳偏差"><a href="#归纳偏差" class="headerlink" title="归纳偏差"></a>归纳偏差</h3><h4 id="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"><a href="#当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。" class="headerlink" title="当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。"></a>当建立一个模型来解决特定类型数据上的问题时，我们希望对模型进行专门化，以充分利用该数据的特性。如果能成功做到这一点，我们往往能看到更好的预测性能、更少的训练时间、更少的参数和更好的泛化效果。</h4><h4 id="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"><a href="#例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如-“不是-“一词）会影响句子其余部分的意思，因此我们需要能够-“关注-“文本其他部分的组件，而-BERT-和-GPT-3-等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。" class="headerlink" title="例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。"></a>例如，在对图像进行标注时，我们希望利用这样一个事实：无论狗是在图像的左上角还是右下角，它仍然是一只狗。因此，大多数图像模型都使用卷积，而卷积具有平移不变性。对于文本而言，标记的顺序非常重要，因此递归神经网络会按顺序处理数据。此外，一个标记的出现（如 “不是 “一词）会影响句子其余部分的意思，因此我们需要能够 “关注 “文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型就能做到这一点。这些都是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些特性的建模组件。</h4><h4 id="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"><a href="#就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。" class="headerlink" title="就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。"></a>就图而言，我们关心每个图组件（边、节点、全局）之间的关系，因此我们寻求具有关系归纳偏向的模型。</h4><h4 id="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"><a href="#模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。" class="headerlink" title="模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。"></a>模型应保留实体间的明确关系（邻接矩阵）并保留图的对称性（排列不变性）。我们希望实体间的互动非常重要的问题能从图结构中受益。具体来说，这意味着在集合上设计转换：节点或边的操作顺序不重要，操作应适用于可变数量的输入。</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-CNN" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/30/CNN/" class="article-date">
  	<time datetime="2024-03-30T09:04:42.000Z" itemprop="datePublished">2024-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/30/CNN/">
        CNN
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、常用的方向：人脸识别（主要是特征值的提取），检测任务，分类和检索，超分辨率重构（用于图片），医学任务，一些识别，无人驾驶。</p>
<h3 id="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"><a href="#二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络-知乎-zhihu-com-卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28-28-1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。" class="headerlink" title="二、与传统神经网络的区别：【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28*28*1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。"></a>二、与传统神经网络的区别：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/242853150">【科普贴】从神经网络到卷积神经网络 - 知乎 (zhihu.com)</a>卷积神经网络是会比传统的神经网络有更高的维度，神经网络是nn，卷积是cnn，就比如说传统的神经网络是784个像素点，而卷积神经是分成28<code>*</code>28<code>*</code>1就是变成个三维，也许可以减小数据量，或者是为了卷积层更好的提取特征。</h3><h3 id="三、整体架构：分为输入层，卷积层，池化层，全连接层。"><a href="#三、整体架构：分为输入层，卷积层，池化层，全连接层。" class="headerlink" title="三、整体架构：分为输入层，卷积层，池化层，全连接层。"></a>三、整体架构：分为输入层，卷积层，池化层，全连接层。</h3><h4 id="输入层：输入数据；"><a href="#输入层：输入数据；" class="headerlink" title="输入层：输入数据；"></a>输入层：输入数据；</h4><h4 id="卷积层：使用卷积核进行特征提取和特征映射。"><a href="#卷积层：使用卷积核进行特征提取和特征映射。" class="headerlink" title="卷积层：使用卷积核进行特征提取和特征映射。"></a>卷积层：使用卷积核进行特征提取和特征映射。</h4><h4 id="池化层：进行采样降维。"><a href="#池化层：进行采样降维。" class="headerlink" title="池化层：进行采样降维。"></a>池化层：进行采样降维。</h4><h4 id="全连接层：在尾部进行拟合，减少特征信息的损失。"><a href="#全连接层：在尾部进行拟合，减少特征信息的损失。" class="headerlink" title="全连接层：在尾部进行拟合，减少特征信息的损失。"></a>全连接层：在尾部进行拟合，减少特征信息的损失。</h4><h3 id="四，卷积做了什么；"><a href="#四，卷积做了什么；" class="headerlink" title="四，卷积做了什么；"></a>四，卷积做了什么；</h3><p>![[Pasted image 20240325203433.png]]</p>
<h4 id="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"><a href="#从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。" class="headerlink" title="从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。"></a>从就是kernel就是一个卷积核，通过卷积核，然后放入的案例划分的图形划分的小区域也应该是和卷积核一样。最后计算出来特征图。</h4><h4 id="五、卷积特征值的计算方法"><a href="#五、卷积特征值的计算方法" class="headerlink" title="五、卷积特征值的计算方法"></a>五、卷积特征值的计算方法</h4><h4 id="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png"><a href="#首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。-Pasted-image-20240325205403-png" class="headerlink" title="首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]"></a>首先是颜色通道是分为RGB，然后一个特征值的计算是需要RGB三个通道和卷积核计算得到。![[Pasted image 20240325205403.png]]</h4><h4 id="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"><a href="#我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是-直接×，就比如第一个就是0，因为1-1加1×1-0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。" class="headerlink" title="我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1&#x3D;0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。"></a>我们可以把左边蓝色的三个分别视为RGB三个颜色通道，然后他们的卷积核各不同因为像素点是不同的，还有就是蓝色部分是773，然后w是333，第三个数值两个需要对应上，就是都必须是一样的。然后计算方法就是 直接×，就比如第一个就是0，因为1*-1加1×1&#x3D;0，其他都是0。然后三个计算出来是2，我们可以看到最下面是有个bias偏移值是1，所以我们加上偏移值就是3。</h4><h3 id="六，得到特征图表示"><a href="#六，得到特征图表示" class="headerlink" title="六，得到特征图表示"></a>六，得到特征图表示</h3><h4 id="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"><a href="#其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。" class="headerlink" title="其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。"></a>其实我们看上图，是有两种卷积核，w0和w1，所以我们可以看到可以得到两张特征图，所以如果卷积核的种类不同的话，那么就是特征图就会越来越多，那么特征会越来越丰富。</h4><h3 id="七，步长与卷积核大小对结果的影响。"><a href="#七，步长与卷积核大小对结果的影响。" class="headerlink" title="七，步长与卷积核大小对结果的影响。"></a>七，步长与卷积核大小对结果的影响。</h3><h4 id="对特征图基础上行多次卷积。"><a href="#对特征图基础上行多次卷积。" class="headerlink" title="对特征图基础上行多次卷积。"></a>对特征图基础上行多次卷积。</h4><p>![[Pasted image 20240325233943.png]]<br>![[Pasted image 20240325234007.png]]</p>
<h5 id="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"><a href="#我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。" class="headerlink" title="我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。"></a>我们可以看到第一个红色的c是3，三代表有多少个特征图。就是接下来的卷积核的c就是前面对应的，如果就是然后就会有蓝色，就是六个特征图。eg10表示用十个不同的filter来执行卷积。</h5><h4 id="滑动窗口步长"><a href="#滑动窗口步长" class="headerlink" title="滑动窗口步长"></a>滑动窗口步长</h4><p>![[Pasted image 20240325235101.png]]</p>
<h5 id="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"><a href="#对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。" class="headerlink" title="对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。"></a>对于步长为1就是特征值会更加丰富，步长为2他的特征值会比较粗糙，但是速度会快点，步长不不一样会用到特定的场景。</h5><h4 id="卷积核的尺寸"><a href="#卷积核的尺寸" class="headerlink" title="卷积核的尺寸"></a>卷积核的尺寸</h4><h5 id="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"><a href="#取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。" class="headerlink" title="取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。"></a>取决于进行对于目标图像的划分，就比如上图是3×3，所以它的卷积核尺寸是3×3。</h5><h4 id="边缘填充方法"><a href="#边缘填充方法" class="headerlink" title="边缘填充方法"></a>边缘填充方法</h4><p>![[Pasted image 20240326104300.png]]</p>
<h5 id="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。"><a href="#我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad-1。" class="headerlink" title="我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad &#x3D; 1。"></a>我们可以看到左边的三张图，就是紫色的区域才是真正的样本值，然后我们在计算的时候会发现如果没有边界填充，一些数字会对特征图的结果有比较大的影响，而且边界值和中心值的重要程度就会出现区别，而边界填充的目的是能更公平的对待边界值和中心值。为什么图中只是加了一圈，因为上方有个pad &#x3D; 1。</h5><h4 id="卷积核个数"><a href="#卷积核个数" class="headerlink" title="卷积核个数"></a>卷积核个数</h4><h5 id="就是多少个特征图，就要多少个卷积核。"><a href="#就是多少个特征图，就要多少个卷积核。" class="headerlink" title="就是多少个特征图，就要多少个卷积核。"></a>就是多少个特征图，就要多少个卷积核。</h5><h3 id="八，特征图尺寸计算和参数共享"><a href="#八，特征图尺寸计算和参数共享" class="headerlink" title="八，特征图尺寸计算和参数共享"></a>八，特征图尺寸计算和参数共享</h3><h4 id="卷积结果计算公式"><a href="#卷积结果计算公式" class="headerlink" title="卷积结果计算公式"></a>卷积结果计算公式</h4><p>![[Pasted image 20240326163117.png]]</p>
<h4 id="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"><a href="#为什么是加2p因为一圈，左右两边都会加，所以是加2p。" class="headerlink" title="为什么是加2p因为一圈，左右两边都会加，所以是加2p。"></a>为什么是加2p因为一圈，左右两边都会加，所以是加2p。</h4><p>![[Pasted image 20240326163842.png]]</p>
<h4 id="通过这张图可以看出怎么计算。"><a href="#通过这张图可以看出怎么计算。" class="headerlink" title="通过这张图可以看出怎么计算。"></a>通过这张图可以看出怎么计算。</h4><h4 id="卷积参数共享"><a href="#卷积参数共享" class="headerlink" title="卷积参数共享"></a>卷积参数共享</h4><p>![[Pasted image 20240326165236.png]]</p>
<h5 id="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"><a href="#就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。" class="headerlink" title="就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。"></a>就是一个filter可以出一张特征图，然后计算参数就是把一个卷积核按照hwc给算出来，然后加上对应的偏执参数就算出来一个卷积核的权重参数。</h5><h3 id="九，池化层的作用"><a href="#九，池化层的作用" class="headerlink" title="九，池化层的作用"></a>九，池化层的作用</h3><p>![[Pasted image 20240327204655.png]]</p>
<h4 id="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"><a href="#可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。" class="headerlink" title="可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。"></a>可以看到和卷积层的划分是类似的，化成一块一块的，然后找到里面最大，就是特征值最大的，然后拼成一块，这种操作是最大池化。池化层的作用也可以看出来，就是减小规模。</h4><p>![[Pasted image 20240327205050.png]]</p>
<h3 id="十、整体网络结构"><a href="#十、整体网络结构" class="headerlink" title="十、整体网络结构"></a>十、整体网络结构</h3><p>![[Pasted image 20240327233452.png]]</p>
<h4 id="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"><a href="#我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。" class="headerlink" title="我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。"></a>我们从这张图中可以看出这是几层的神经网络，就是会有权重和参数的层数总和。</h4><h4 id="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5"><a href="#RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的-10240-5" class="headerlink" title="RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的[10240,5]"></a>RELU层只是保留特征大于0的值，conv是一个，最后的FC，就是划分也是一层，那么图中就是七层。然后再FC前面还有一步就是将一个立体的几×几×几的把他变成转化成一个就像图中的写的<code>[10240,5]</code></h4><p>![[Pasted image 20240327235319.png]]</p>
<h4 id="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"><a href="#特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。" class="headerlink" title="特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。"></a>特征图变化没什么好说的。转换就是将一个立体转化成一个向量，可以被读进去。</h4><h3 id="十一，VGN网络架构"><a href="#十一，VGN网络架构" class="headerlink" title="十一，VGN网络架构"></a>十一，VGN网络架构</h3><h4 id="Alexnet这个比较早就没什么好说的。"><a href="#Alexnet这个比较早就没什么好说的。" class="headerlink" title="Alexnet这个比较早就没什么好说的。"></a>Alexnet这个比较早就没什么好说的。</h4><h4 id="Vgg经典网络"><a href="#Vgg经典网络" class="headerlink" title="Vgg经典网络"></a>Vgg经典网络</h4><p>![[Pasted image 20240330143149.png]]</p>
<h5 id="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"><a href="#从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。" class="headerlink" title="从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。"></a>从这个d来讲这是十六层的神经网络，然后这是十六层的，然后他的划分都是三×三，然后我们发现再经过池化层，本来应该会减少那些没有太大用处的特征值，应该会减少，但是却翻了两倍，说明再池化层之后给了一些数值，弥补一部分损失。</h5><h4 id="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"><a href="#然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。" class="headerlink" title="然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。"></a>然后关于如果神经层数太多，有可能会导致loss值过高，或者对应的卷积层做的不是很好，反而会取得适得其反的效果。</h4><h3 id="十二、残差网络Resnet"><a href="#十二、残差网络Resnet" class="headerlink" title="十二、残差网络Resnet"></a>十二、残差网络Resnet</h3><h4 id="深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。"><a href="#深层神经网络所遇到的问题：就是train-error值会更高，所以就是需要降低。" class="headerlink" title="深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。"></a>深层神经网络所遇到的问题：就是train error值会更高，所以就是需要降低。</h4><h4 id="解决方案：加了Resnet"><a href="#解决方案：加了Resnet" class="headerlink" title="解决方案：加了Resnet"></a>解决方案：加了Resnet</h4><p>![[Pasted image 20240330145212.png]]</p>
<h5 id="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"><a href="#这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。" class="headerlink" title="这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。"></a>这张图的意思是，x相当于input，然后如果有值怎么拟合都拟合不好，那么就会将他的赋值成0，然后会有一个补偿机制，就是加上原来的值，这样的操作使得深层的神经网络的error降低。中间的两层的为卷积层。</h5><p>![[Pasted image 20240330145724.png]]</p>
<h4 id="深层的神经网络就会变成这样。"><a href="#深层的神经网络就会变成这样。" class="headerlink" title="深层的神经网络就会变成这样。"></a>深层的神经网络就会变成这样。</h4><h3 id="十三、感受野"><a href="#十三、感受野" class="headerlink" title="十三、感受野"></a>十三、感受野</h3><h4 id="一开始看感觉要一会，但是理解了。"><a href="#一开始看感觉要一会，但是理解了。" class="headerlink" title="一开始看感觉要一会，但是理解了。"></a>一开始看感觉要一会，但是理解了。</h4><h4 id="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次"><a href="#神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次" class="headerlink" title="神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次."></a>神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此<strong>感受野的值可以用来大致判断每一层的抽象层次</strong>.</h4><h4 id="如何算感受野"><a href="#如何算感受野" class="headerlink" title="如何算感受野"></a>如何算感受野</h4><h5 id="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"><a href="#例子：求三个3×3的卷积层，保持步长为一，求它的感受野。" class="headerlink" title="例子：求三个3×3的卷积层，保持步长为一，求它的感受野。"></a>例子：求三个3×3的卷积层，保持步长为一，求它的感受野。</h5><h4 id="公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小"><a href="#公式：前一层卷积核感受野-（后一层卷积核感受野-1）x-前一层卷积核步长-前一层卷积核的大小" class="headerlink" title="公式：前一层卷积核感受野 &#x3D; （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小"></a>公式：<strong>前一层卷积核感受野 &#x3D; （后一层卷积核感受野 - 1）x 前一层卷积核步长 + 前一层卷积核的大小</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先是最后一层是一个，(1-1)*1+3 = 3</span><br><span class="line">接着计算：(3-1)*1+3 = 5</span><br><span class="line">然后计算:(5-1)*1+3 = 7</span><br><span class="line">所以感受野即为7</span><br></pre></td></tr></table></figure>
<h4 id="问题：为什么要堆叠三个小卷积："><a href="#问题：为什么要堆叠三个小卷积：" class="headerlink" title="问题：为什么要堆叠三个小卷积："></a>问题：为什么要堆叠三个小卷积：</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-二分题单" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/" class="article-date">
  	<time datetime="2024-03-01T16:00:30.000Z" itemprop="datePublished">2024-03-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/03/02/%E4%BA%8C%E5%88%86%E9%A2%98%E5%8D%95/">
        二分题单
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="关于二分区间的操作"><a href="#关于二分区间的操作" class="headerlink" title="关于二分区间的操作"></a>关于二分区间的操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">	mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">	mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;<span class="comment">//if(nums[mid]&lt;target)</span></span><br><span class="line">	<span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l;</span><br><span class="line"><span class="comment">//注意check()的判断true应该是小于而不是小于等于</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左开右闭</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">	mid = (l+<span class="number">1</span>+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid <span class="number">-1</span>;<span class="comment">//if(nums[mid]&gt;target)</span></span><br><span class="line">	<span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;L;</span><br><span class="line"><span class="comment">//注意对于check()的判断true应该是大于而不是大于等于</span></span><br></pre></td></tr></table></figure>


<h4 id="P1102-A-B数对"><a href="#P1102-A-B数对" class="headerlink" title="P1102 A-B数对"></a>P1102 A-B数对</h4><h4 id="题目要求就是找出符合A-B-C的情况。"><a href="#题目要求就是找出符合A-B-C的情况。" class="headerlink" title="题目要求就是找出符合A - B &#x3D; C的情况。"></a>题目要求就是找出符合A - B &#x3D; C的情况。</h4><h4 id="题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。"><a href="#题解，我们可以知道C是已知的，所以我们可以写成A-B-C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B-C的值。有的话就找到对应的值的长度。" class="headerlink" title="题解，我们可以知道C是已知的，所以我们可以写成A &#x3D; B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。"></a>题解，我们可以知道C是已知的，所以我们可以写成A &#x3D; B + C，这样让其中的b作为数组的元素之一，然后查找数组中有没有符合B+C的值。有的话就找到对应的值的长度。</h4><h4 id="STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。"><a href="#STL中的upper-bound-begin-end-val-是找到对应数字的最后一个的下一个的地址-lower-bound-begin-end-val-返回的是第一个地址。" class="headerlink" title="STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。"></a>STL中的upper_bound(begin,end,val)是找到对应数字的最后一个的下一个的地址,lower_bound(begin,end,val)返回的是第一个地址。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll n,c;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		sum += <span class="built_in">upper_bound</span>(a,a+n,a[i]+c)-<span class="built_in">lower_bound</span>(a,a+n,a[i]+c);</span><br><span class="line">		<span class="comment">//a[i]+c就是b，在元素找出符合a的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1873-砍树"><a href="#P1873-砍树" class="headerlink" title="P1873 砍树"></a>P1873 砍树</h4><h4 id="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"><a href="#题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。" class="headerlink" title="题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。"></a>题目大概意思就是说有一排数，然后我们需要找到最大的整数高度H，使他的切下来的木材至少为M米，也就是说我们需要找到最大值H，就是说我们需要二分的就是找到的右区间的值，就是左开右闭的二分区间。所以他的标准值就是m。所以我们二分的值就是木材的长度。</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,m,l,r,trees[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;trees[i];</span><br><span class="line">		r = <span class="built_in">max</span>(r,trees[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//查找的右区间</span></span><br><span class="line">		ll mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ll s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(trees[i]&gt;mid)&#123;</span><br><span class="line">				s += trees[i] - mid;<span class="comment">//将多的部分切下来</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s&gt;=m)&#123;<span class="comment">//如果切的过多就是还要更高</span></span><br><span class="line">			l = mid;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P1678-烦恼的高考志愿"><a href="#P1678-烦恼的高考志愿" class="headerlink" title="P1678 烦恼的高考志愿"></a>P1678 烦恼的高考志愿</h4><h4 id="题目的意思"><a href="#题目的意思" class="headerlink" title="题目的意思"></a>题目的意思</h4><blockquote>
<p>现有 m 所学校，每所学校预计分数线是 ai​。有 n 位学生，估分分别为 bi​。根据 n 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p>
</blockquote>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行读入两个整数 m,n。m 表示学校数，n 表示学生数。</p>
<p>第二行共有 m 个数，表示 m 个学校的预计录取分数。第三行有 n 个数，表示 n 个学生的估分成绩</p>
<h4 id="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"><a href="#题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。" class="headerlink" title="题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。"></a>题解：就是说我们会有一组数组是学校的录取分数，还有一组就是学生的估分成绩，我们需要给学生推荐学校然后将两者的差的成绩算出来然后加给sum，找到就是不满意度和的最小值，所以就是查找二分的左区间就是用左区间的模板。由于不需要二分答案只需要二分查找，所以这里可以用二分的STL。</h4><h4 id="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"><a href="#对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是-1-2-4-5-那么lower-bound-3-upper-bound-3-都返回的是下标2就是值是4-如果是upper-bound-2-返回的是下标2-lower-bound-2-返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower-bound-就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。" class="headerlink" title="对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是[1,2,4,5]那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。"></a>对于STL中如果值不是在数组里会返回什么样的东西。举个例子：在升序数组中，比如是<code>[1,2,4,5]</code>那么lower_bound(3),upper_bound(3)都返回的是下标2就是值是4,如果是upper_bound(2)返回的是下标2,lower_bound(2)返回的就是下标1。所以我们可以看出当找到的数不是数组中，那么lower_bound()就会返回第一个比要查询的值的大的值，如果比所有的数字大的话那么就是返回的end的地址。</h4><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[N],s[N]; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> m,n;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">lower_bound</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+m,s[i])-x;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="number">1</span>)&#123;<span class="comment">//在开头</span></span><br><span class="line">			sum+=<span class="built_in">abs</span>(x[a]-s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==m+<span class="number">1</span>)&#123;<span class="comment">//在末尾</span></span><br><span class="line">			sum += <span class="built_in">abs</span>(x[m]-s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//中间的数</span></span><br><span class="line">			sum += <span class="built_in">min</span>(<span class="built_in">abs</span>(x[a<span class="number">-1</span>]-s[i]),<span class="built_in">abs</span>(x[a]-s[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="P2440-木材加工"><a href="#P2440-木材加工" class="headerlink" title="P2440 木材加工"></a>P2440 木材加工</h4><h4 id="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"><a href="#题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板" class="headerlink" title="题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板"></a>题目的大概意思就是将一群木头切割成k段长度均为l的小段木头，并且找出的是l的最大值，要求的都是整数，所以我们需要查找的右区间，所以用的是左开右闭的区间的二分模板</h4><h4 id="题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"><a href="#题解：就是我们的mid函数应该是木头的长度，然后check-函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。" class="headerlink" title="题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。"></a>题解：就是我们的mid函数应该是木头的长度，然后check()函数就是判断能不能割成就是将木材的长度除以mid的个数，判断和要求的木材段数的关系。</h4><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,k,a[N];</span><br><span class="line">ll l,r = <span class="number">1e8</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans += a[i]/x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		ll mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(mid))&#123;</span><br><span class="line">			l = mid;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r = mid <span class="number">-1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h4><h4 id="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、"><a href="#题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N-块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走-M-块岩石（不能移走起点和终点的岩石）。、" class="headerlink" title="题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、"></a>题目：一年一度的“跳石头”比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。、</h4><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><h5 id="第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0"><a href="#第一行包含三个整数L-N-M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证-L≥1-且-N≥M≥0。接下来-N-行，每行一个整数，第i-行的整数Di​-0" class="headerlink" title="第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置"></a>第一行包含三个整数L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L≥1 且 N≥M≥0。接下来 N 行，每行一个整数，第i 行的整数Di​(0&lt;Di​&lt;L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置</h5><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">25 5 2 </span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">14</span><br><span class="line">17 </span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以"><a href="#题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n-1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check-函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以" class="headerlink" title="题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;&#x3D;至多移走的岩石数。"></a>题解这里有个坑点就是最后一个岩石是终点，所以岩石的最终的总数是n+1，这个很坑，一开始没想到，然后一直wa，最后看题解才知道。然后我们找到的是最大值所以就是查找右边界的二分模板。然后check()函数里面应该判断的是当前假设的最短的跳跃距离所取走的石头数是不是可以&lt;&#x3D;至多移走的岩石数。</h4><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
const int N = 5e5+10;
typedef long long ll;
using namespace std;
int a[N];
int d,n,m;
bool check(int x)&#123;
    int cnt = 0;//当前最短跳跃需要移走的个数
    int now = 0;
    int i = 0;
    while(i&lt;n+1)&#123;
        i++;
        if(a[i]-a[now]&lt;x)&#123;//如果跳跃距离小于当前的就需要移
            cnt++;
        &#125;
        else&#123;
            now = i;//如果不需要那就跳到当前的石头
        &#125;
    &#125;
    if(cnt&gt;m) return false;//大于就说明小的更多还不够小



    else return true;
&#125;
void solve()&#123;
    cin&gt;&gt;d&gt;&gt;n&gt;&gt;m;
    for(int i = 1;i&lt;=n;i++) cin&gt;&gt;a[i];
    a[n+1] = d;//相当于总数是n+1
    int l = 0,r = d;
    while(l&lt;r)&#123;
        int mid = (l+r+1)&gt;&gt;1;
        if(check(mid))&#123;
            l = mid;
        &#125;
        else&#123;
            r = mid-1;
        &#125;
    &#125;
    cout&lt;&lt;l;
&#125;
int main()&#123;
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    solve();
&#125;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Atcoder341-d" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/21/Atcoder341-d/" class="article-date">
  	<time datetime="2024-02-21T12:24:34.000Z" itemprop="datePublished">2024-02-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/21/Atcoder341-d/">
        Atcoder341 d
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"><a href="#前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。" class="headerlink" title="前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。"></a>前面的三道题的都做出来虽然花的时间比较久，但是第四题就不会了，看了许多题解终于弄懂了。</h4><h4 id="问题陈述"><a href="#问题陈述" class="headerlink" title="#### 问题陈述"></a>#### 问题陈述</h4><h4 id="给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。"><a href="#给你三个正整数-N、M-和-K。这里，N和M是不同的。-请列出能被N和M中的一个整数整除的K个最小正整数。" class="headerlink" title="给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。"></a>给你三个正整数 N、M 和 K。这里，N和M是不同的。  请列出能被N和M中的一个整数整除的K个最小正整数。</h4><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 5</span><br></pre></td></tr></table></figure>
<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<h4 id="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"><a href="#题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。" class="headerlink" title="题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。"></a>题解：首先对于这道题，可以用暴力，但是数据量感人所以大部分会t。所以就是说需要有优化的方法。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于这道题，我们可以将k作为一个基准值，可以用二分法找到想要的数字，所以对于这里我们可用二分进行二分答案的操作，因为是一个整除所以说明两个的公因数是不行的，就比如6，被2和3整除。这个就要被去掉，所以我们需要找到两个数的最大公因数，所以就是找到最小公倍数。然后我们举个例子：如果我们想要知道15以内的合法序列的数，我们可以求20以内2的个数:20/2,对于3的个数就是:20/3，然后我们需要去掉两者的最小倍数，但是在2的时候算了一次，又在3的时候算了一次，所以我们需要减掉两倍的20/两者的最大公因数。所以我们可以抽象成数学，二分的就是mid,所以我们判断x是k，我们可以写成[mid/n]+[mid/m]-2*[mid/lcm(n,m)]然后来判断大小</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">if</span>(y%x==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(y%x,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> n,m,x,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	x=(n*m)/<span class="built_in">gcd</span>(n,m);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> l=<span class="number">0</span>,r=(<span class="type">long</span> <span class="type">long</span>)<span class="number">2e+18</span>,mid,y;</span><br><span class="line">	<span class="keyword">while</span>((l+<span class="number">1</span>)&lt;r)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		y=(mid/n)+(mid/m)<span class="number">-2</span>*(mid/x);</span><br><span class="line">		<span class="keyword">if</span>(y&lt;k)l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Atcoder/" rel="tag">Atcoder</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-背包问题练习2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/" class="article-date">
  	<time datetime="2024-02-20T07:00:03.000Z" itemprop="datePublished">2024-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/20/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A02/">
        背包问题练习2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"><a href="#【算法详解】背包问题的问法变化-背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。" class="headerlink" title="【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客背包求方案数的一系列模板可以得到思路。"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ronaldo7_zyb/article/details/81069906">【算法详解】背包问题的问法变化_背包问题问法的变化-CSDN博客</a>背包求方案数的一系列模板可以得到思路。</h4><h4 id="P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P5365-英雄联盟P5365-SNOI2017-英雄联盟-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P5365 英雄联盟P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P5365 英雄联盟<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5365">P5365 [SNOI2017] 英雄联盟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"><a href="#题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f-j-max-f-j-f-j-x-c-i-x-然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。" class="headerlink" title="题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，f[j] = max(f[j],f[j-x*c[i]]*x)然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。"></a>题解：首先这里的要求是方案数至少大于某个数，并且花费是最少的。所以我们这里需要的一个操作就是背包问题求方案数，但是我们如何知道金额的大小，就是通过一维背包的数组下标就可以看到。如果方案数大于等于要求的方案数，那么就可以输出dp数组的下标就是最终答案。由于我们可以看到题解中方案数是根据皮肤选取的个数来进行乘法运算。所以说明方案数是乘法有关系并且要和皮肤数量挂钩，所以再二层循环下面再套一层循环用来枚举每一个英雄用了多少个皮肤，再进行相乘这就是状态转移方程，<code>f[j] = max(f[j],f[j-x*c[i]]*x)</code>然后就是需要看背包的第二层循环的数量就是多少钱，我们可以看到对于这个来说就把全部皮肤的钱都加上就是总数。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k[N],c[N],dp[N],qm;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;c[i];</span><br><span class="line">		qm+=k[i]*c[i];<span class="comment">//钱的总数</span></span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = qm;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//只能选一次01背包</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>;x&lt;=k[i];x++)&#123;<span class="comment">//皮肤个数</span></span><br><span class="line">				<span class="keyword">if</span>(j&gt;=x*c[i])&#123;</span><br><span class="line">					dp[j] = <span class="built_in">max</span>(dp[j],dp[j-c[i]*x]*x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=qm;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]&gt;=m)&#123;<span class="comment">//找到大于等于的方案数</span></span><br><span class="line">			cout&lt;&lt;i;<span class="comment">//输出下标。</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1077-摆花P1077-NOIP2012-普及组-摆花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1077 摆花P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1077 摆花<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1077">P1077 [NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。"><a href="#思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp-0-1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min-a-i-j-就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3-…-min-ai-j-盆。所以这些都是可能的情况，所以我们可以得到fij-fi-1j-fi-1j-1-fi-1-j-min-ai-j-。这个可以看一下顶上的文章求可行方案数。" class="headerlink" title="思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将dp[0] = 1，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是min(a[i],j)就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))。这个可以看一下顶上的文章求可行方案数。"></a>思路：首先这个是有m个花，然后求的是一共多少种摆花方案，所以这也是求方案数，求的是可行方案数，所以dp数组求的是方案数，所以需要将<code>dp[0] = 1</code>，然后花有两种，并且每个花只能选一次，一开始把这个看成了一个多重背包的问题，但是由于水平比较低只会求01背包的方案数问题，所以就是说我可以把每一个花看成一个数，就是再01背包的情况下再套一层循环，但是这一层循环的是边界是<code>min(a[i],j)</code>就是不能超过当前的花盆数，并且不能超过这种花的花盆数，所以两者取最小就可以。然后由于这是可行方案数。我们可以看对于对于第i种花有了j盆，所以第i种花的摆放就是可能摆了0，1，2，3,….min(ai,j)盆。所以这些都是可能的情况，所以我们可以得到<code>fij = (fi-1j+fi-1j-1+...fi-1,j-min(ai,j))</code>。这个可以看一下顶上的文章求可行方案数。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	dp[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=<span class="built_in">min</span>(a[i],j);k++)&#123;</span><br><span class="line">				dp[j]= dp[j-k]+dp[j];</span><br><span class="line">				dp[j] %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2347P2347-NOIP1996-提高组-砝码称重-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2347P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2347<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2347">P2347 [NOIP1996 提高组] 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"><a href="#很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。" class="headerlink" title="很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。"></a>很老的题目，首先范围给死，六个砝码重量，然后会有输入的案例是每个砝码的重量，那么就是说这是个多重背包的问题，所以可以拆成多个01背包，因为数据量不大就用朴素的多重背包的解发，因为要求输出的是不同重量的个数，然后总重量就是每一个砝码重量加起来，所以求01背包求可行方案数，所以只要那个重量有方案数就可以。求可行方案数就是用顶上的文章的方法即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> dp[N],a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		sum+=a[i]*num[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = sum;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=a[i];k++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=num[i<span class="number">-1</span>]*k)&#123;</span><br><span class="line">					dp[j]+=dp[j-num[i<span class="number">-1</span>]*k];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=sum;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i]) ans++;</span><br><span class="line"> 	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Total=&quot;</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-背包问题练习1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/" class="article-date">
  	<time datetime="2024-02-18T12:17:30.000Z" itemprop="datePublished">2024-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A01/">
        背包问题练习1
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1833-樱花P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1833 樱花P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1833 樱花<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"><a href="#题解-这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。" class="headerlink" title="题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。"></a>题解 这是一个混和背包问题，就是多个背包问题混杂到一起，建议将01背包和多重背包的二进制优化写在一起，这样子背包问题就可以简化到多重背包和完全背包。</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">10100</span>;</span><br><span class="line"><span class="type">int</span> c[N],dp[N],t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> th1,ts1,th2,ts2,n;</span><br><span class="line">	<span class="type">char</span> cc;</span><br><span class="line">	cin&gt;&gt;th1&gt;&gt;cc&gt;&gt;ts1&gt;&gt;th2&gt;&gt;cc&gt;&gt;ts2&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> tz = <span class="number">60</span>*(th2-th1)+ts2-ts1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> t0,c0,s;</span><br><span class="line">		cin&gt;&gt;t0&gt;&gt;c0&gt;&gt;s;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="number">0</span>)&#123;<span class="comment">//完全背包</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=tz;j++) <span class="keyword">if</span>(j&gt;=t0) dp[j] = <span class="built_in">max</span>(dp[j],dp[j-t0]+c0);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//多重背包加上01背包写一起</span></span><br><span class="line">			<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(k&lt;=s)&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				t[cnt] = k*t0;</span><br><span class="line">				c[cnt] = k*c0;</span><br><span class="line">				s-=k;</span><br><span class="line">				k*=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s)&#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				t[cnt] = s*t0;</span><br><span class="line">				c[cnt] = s*c0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>;m&lt;=cnt;m++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = tz;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">					<span class="keyword">if</span>(j&gt;=t[m]) dp[j] = <span class="built_in">max</span>(dp[j],dp[j-t[m]]+c[m]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[tz];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"><a href="#当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、" class="headerlink" title="当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、"></a>当完全背包和多重背包写一起建议完全背包不要先读入到数组，等到多重背包进行二进制优化，在读入数组好操作。、</h4><h4 id="P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1049-装箱问题-01背包-P1049-NOIP2001-普及组-装箱问题-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1049 装箱问题(01背包)P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1049 装箱问题(01背包)<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1049">P1049 [NOIP2001 普及组] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="代码-简单就不写题解"><a href="#代码-简单就不写题解" class="headerlink" title="代码(简单就不写题解)"></a>代码(简单就不写题解)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">20010</span>],v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> v1,n;</span><br><span class="line">	cin&gt;&gt;v1&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = v1;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i])dp[j] = <span class="built_in">max</span>(dp[j],dp[j-v[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;v1-dp[v1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="01背包求方案数"><a href="#01背包求方案数" class="headerlink" title="01背包求方案数"></a>01背包求方案数</h4><h4 id="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。"><a href="#就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max-f-j-f-j-v-w-，如果maxn-f-j-就是说是前一个更好，所以f-j-maxn然后就是将方案数变成g-j-a-，如果相等的话，就是相当于有两条路，g-j-g-j-g-j-a-就是说这两条路的方案数都要。" class="headerlink" title="就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到max(f[j],f[j-v]+w)，如果maxn==f[j]就是说是前一个更好，所以f[j] = maxn然后就是将方案数变成g[j-a]，如果相等的话，就是相当于有两条路，g[j] = (g[j]+g[j-a])就是说这两条路的方案数都要。"></a>就是需要记录到达每一个的时候就要将当前方案数记录下来，其实就是求达到的路线，就是在01背包的基础上加上一个需要记忆路线的数组。首先即得到<code>max(f[j],f[j-v]+w)</code>，如果<code>maxn==f[j]</code>就是说是前一个更好，所以<code>f[j] = maxn</code>然后就是将方案数变成<code>g[j-a]</code>，如果相等的话，就是相当于有两条路，<code>g[j] = (g[j]+g[j-a])</code>就是说这两条路的方案数都要。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//板子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,v,a,b,f[<span class="number">1005</span>],g[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=v;i++)</span><br><span class="line">        g[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;<span class="comment">//输入废话</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a;j--)&#123;</span><br><span class="line">            <span class="type">int</span> z=f[j-a]+b;<span class="comment">//先用一个数存起来f[j-a]+b</span></span><br><span class="line">            <span class="keyword">if</span>(f[j]&lt;z)&#123;如果f[j]小于它</span><br><span class="line">                f[j]=z;<span class="comment">//更新f[j]</span></span><br><span class="line">                g[j]=g[j-a];<span class="comment">//方案数变为g[j-a]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[j]==z)<span class="comment">//否则如果它们相等</span></span><br><span class="line">                g[j]=(g[j]+g[j-a])%<span class="number">1000000007</span>;<span class="comment">//方案数更新为现在的方案数加上g[j-a]的方案数取模1e9+7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;g[v];<span class="comment">//最后输出最优选法方案数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1164-小A点菜P1164-小A点菜-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1164 小A点菜P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1164 小A点菜<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。"><a href="#这个就是求方案数-由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp-数组即可。" class="headerlink" title="这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp[]数组即可。"></a>这个就是求方案数,由于只有价值没有体积什么的，所以不要额外再弄一个记录方案的数组，用dp<code>[]</code>数组即可。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">105</span>],f[<span class="number">105</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) </span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == j)</span><br><span class="line">			&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;j) </span><br><span class="line">			&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125; </span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1060-开心的金明-01背包-P1060-NOIP2006-普及组-开心的金明-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1060 开心的金明(01背包)P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1060 开心的金明(01背包)<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1060">P1060 [NOIP2006 普及组] 开心的金明 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"><a href="#题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可" class="headerlink" title="题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可"></a>题解：就是说价格和重要度相乘，拿到全部的最大值，所以可以一个数组是两个乘机，另外两个就读入，价格就像当于板子里面的体积，然后用01背包即可</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">30050</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> p[M],v[M],dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> m,n;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;p[i];</span><br><span class="line">		p[i] = v[i]*p[i];<span class="comment">//相当于乘机</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i])&#123;</span><br><span class="line">				dp[j] = <span class="built_in">max</span>(dp[j],dp[j-v[i]]+p[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P2722P2722-USACO3-1-总分-Score-Inflation-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P2722P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P2722<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2722">P2722 [USACO3.1] 总分 Score Inflation - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="一个板子题，看到可以重复选择就说明是完全背包。"><a href="#一个板子题，看到可以重复选择就说明是完全背包。" class="headerlink" title="一个板子题，看到可以重复选择就说明是完全背包。"></a>一个板子题，看到可以重复选择就说明是完全背包。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> t[N],p[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> m,n;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;p[i]&gt;&gt;t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=t[i])&#123;</span><br><span class="line">				dp[j] = <span class="built_in">max</span>(dp[j],dp[j-t[i]]+p[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1853-投资的最大效益P1853-投资的最大效益-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1853 投资的最大效益P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>P1853 投资的最大效益<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1853">P1853 投资的最大效益 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"><a href="#题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子" class="headerlink" title="题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子"></a>题解：这个稍微会有变形，首先是每一年会总数会加也就是代表着他的最后一套的dp循环会进行的上限会增加，而且还要注意的点是每一年的的时候dp数组需要重新清0，因为都是一年之后重新更新，并且每一年资金总额需要重新更新。接着就是完全背包的板子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> a[M],b[M];<span class="comment">//投资额,年利息</span></span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum,year,n;</span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;year&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">		a[i]/=<span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=year;k++)&#123;</span><br><span class="line">		<span class="type">int</span> t = sum/<span class="number">1000</span>;<span class="comment">//总额更新</span></span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//dp数组清0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=t;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=a[i]) dp[j] = <span class="built_in">max</span>(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum+=dp[t];<span class="comment">//每年的最大值加到总额里面。</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-DP-分组背包问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/17/DP-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="article-date">
  	<time datetime="2024-02-17T07:39:16.000Z" itemprop="datePublished">2024-02-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/17/DP-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">
        DP(分组背包问题)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。"><a href="#分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。" class="headerlink" title="分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。"></a>分组背包问题就是在01背包上加上了分组的条件就是，取得是每一组的最大值。</h4><h4 id="f-N-N-就是前i组物品中选，当前体积小于等于j的最大值，v-体积，w-价值，s-代表第i组的物品个数。"><a href="#f-N-N-就是前i组物品中选，当前体积小于等于j的最大值，v-体积，w-价值，s-代表第i组的物品个数。" class="headerlink" title="f[N][N]就是前i组物品中选，当前体积小于等于j的最大值，v[][]体积，w[][]价值，s[]代表第i组的物品个数。"></a><code>f[N][N]</code>就是前i组物品中选，当前体积小于等于j的最大值，<code>v[][]</code>体积，<code>w[][]</code>价值，<code>s[]</code>代表第i组的物品个数。</h4><h4 id="如果不选就是f-i-j-f-i-1-j-，如果选的话就是f-i-j-max-f-i-j-f-i-1-j-v-i-k-w-i-k-；这就是状态转移方程。"><a href="#如果不选就是f-i-j-f-i-1-j-，如果选的话就是f-i-j-max-f-i-j-f-i-1-j-v-i-k-w-i-k-；这就是状态转移方程。" class="headerlink" title="如果不选就是f[i][j] = f[i-1][j]，如果选的话就是f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k])；这就是状态转移方程。"></a>如果不选就是<code>f[i][j] = f[i-1][j]</code>，如果选的话就是<code>f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k])</code>；这就是状态转移方程。</h4><h4 id="如果是一维的就是根据0-1背包一样逆序操作，f-j-max-f-j-f-j-v-i-k-w-i-k"><a href="#如果是一维的就是根据0-1背包一样逆序操作，f-j-max-f-j-f-j-v-i-k-w-i-k" class="headerlink" title="如果是一维的就是根据0-1背包一样逆序操作，f[j] = max(f[j],f[j-v[i][k]]+w[i][k])"></a>如果是一维的就是根据0-1背包一样逆序操作，<code>f[j] = max(f[j],f[j-v[i][k]]+w[i][k])</code></h4><h4 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a>P1757 通天之分组背包</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1757">P1757 通天之分组背包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> w[N][N],p[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> weight,n;</span><br><span class="line">	cin&gt;&gt;weight&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmpw,tmpp,k;</span><br><span class="line">		cin&gt;&gt;tmpw&gt;&gt;tmpp&gt;&gt;k;</span><br><span class="line">		s[k]++;</span><br><span class="line">		w[k][s[k]] = tmpw;</span><br><span class="line">		p[k][s[k]] = tmpp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=weight;j++)&#123;</span><br><span class="line">			f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>;m&lt;=s[i];m++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=w[i][m])&#123;</span><br><span class="line">					f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-w[i][m]]+p[i][m]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[n][weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> w[N][N],p[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> weight,n;</span><br><span class="line">	cin&gt;&gt;weight&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmpw,tmpp,k;</span><br><span class="line">		cin&gt;&gt;tmpw&gt;&gt;tmpp&gt;&gt;k;</span><br><span class="line">		s[k]++;</span><br><span class="line">		w[k][s[k]] = tmpw;</span><br><span class="line">		p[k][s[k]] = tmpp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = weight;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">			f[j] = f[j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>;m&lt;=s[i];m++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=w[i][m])&#123;</span><br><span class="line">					f[j] = <span class="built_in">max</span>(f[j],f[j-w[i][m]]+p[i][m]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[weight];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-寒假前端学习Day4-Vue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/17/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day4-Vue/" class="article-date">
  	<time datetime="2024-02-17T05:47:02.000Z" itemprop="datePublished">2024-02-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/17/%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0Day4-Vue/">
        寒假前端学习Day4(Vue)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件的引入就是需要在中引入子组件的模块，然后在模板中使用组件。"><a href="#组件的引入就是需要在中引入子组件的模块，然后在模板中使用组件。" class="headerlink" title="组件的引入就是需要在&lt;setup&gt;中引入子组件的模块，然后在模板中使用组件。"></a>组件的引入就是需要在<code>&lt;setup&gt;</code>中引入子组件的模块，然后在模板中使用组件。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!------App.vue-------&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ChildComp.vue----&gt;</span><br><span class="line">template&gt;</span><br><span class="line">  &lt;h2&gt;A Child Component!&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><h4 id="这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。"><a href="#这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。" class="headerlink" title="这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。"></a>这是用于父子组件之间通信，父组件将数据传输给子组件然后就可以。</h4><h4 id="在子组件中定义props"><a href="#在子组件中定义props" class="headerlink" title="在子组件中定义props"></a>在子组件中定义props</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!------ChildComp.vue-----&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  msg: String</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; msg || &#x27;No props passed yet&#x27; &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="可以看到在子组件中定义了prop然后再子组件的模板中挂上msg"><a href="#可以看到在子组件中定义了prop然后再子组件的模板中挂上msg" class="headerlink" title="可以看到在子组件中定义了prop然后再子组件的模板中挂上msg"></a>可以看到在子组件中定义了prop然后再子组件的模板中挂上msg</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--App.vue---&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">const greeting = ref(&#x27;&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComp :msg=&quot;greeting&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h4 id="所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。"><a href="#所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。" class="headerlink" title="所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。"></a>所以父组件可以通过greeting传输数据给子组件然后子组件改变msg。</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-dp-01背包和完全背包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/16/dp-01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" class="article-date">
  	<time datetime="2024-02-16T04:19:21.000Z" itemprop="datePublished">2024-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/16/dp-01%E8%83%8C%E5%8C%85%E5%92%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/">
        dp(01背包和完全背包)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="对于01背包，来说就是每个物品只能使用一次。"><a href="#对于01背包，来说就是每个物品只能使用一次。" class="headerlink" title="对于01背包，来说就是每个物品只能使用一次。"></a>对于01背包，来说就是每个物品只能使用一次。</h4><h4 id="对于01背包的思考，就是要找到能背包能够容纳的最大。"><a href="#对于01背包的思考，就是要找到能背包能够容纳的最大。" class="headerlink" title="对于01背包的思考，就是要找到能背包能够容纳的最大。"></a>对于01背包的思考，就是要找到能背包能够容纳的最大。</h4><h4 id="首先是二维的01背包，这是最原始的背包也是最好理解的，f-i-j-定义就是前i个物品，背包容量为j的最优解，加入背包容量不够-j"><a href="#首先是二维的01背包，这是最原始的背包也是最好理解的，f-i-j-定义就是前i个物品，背包容量为j的最优解，加入背包容量不够-j" class="headerlink" title="首先是二维的01背包，这是最原始的背包也是最好理解的，f[i][j]定义就是前i个物品，背包容量为j的最优解，加入背包容量不够(j&lt;v[i])，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是:f[i][j] = f[i-1][j]，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是f[i][j = f[i-1][j]。如果选的就是f[i][j] = f[i-1][j-v[i]]+w[i]所以取到最大价值取max()即可。但是二维的01背包可以进行一维的优化。"></a>首先是二维的01背包，这是最原始的背包也是最好理解的，<code>f[i][j]</code>定义就是前i个物品，背包容量为j的最优解，加入背包容量不够(<code>j&lt;v[i]</code>)，所有前i个物品的最优值就是前i-1个物品的价值最大值，对应的代码是:<code>f[i][j] = f[i-1][j]</code>，如果背包容量够，就需要选，选第i个物品与不选第i个物品。如果不选就是<code>f[i][j = f[i-1][j]</code>。如果选的就是<code>f[i][j] = f[i-1][j-v[i]]+w[i]</code>所以取到最大价值取max()即可。但是二维的01背包可以进行一维的优化。</h4><h4 id="所以状态转移方程可以写成f-i-j-max-f-i-1-j-f-i-1-j-w-i"><a href="#所以状态转移方程可以写成f-i-j-max-f-i-1-j-f-i-1-j-w-i" class="headerlink" title="所以状态转移方程可以写成f[i][j] = max(f[i-1][j],f[i-1][j]+w[i])"></a>所以状态转移方程可以写成<code>f[i][j] = max(f[i-1][j],f[i-1][j]+w[i])</code></h4><h4 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h4><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">P1048 [NOIP2005 普及组] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h4 id="这就是典型的01背包问题，药只能用一次。"><a href="#这就是典型的01背包问题，药只能用一次。" class="headerlink" title="这就是典型的01背包问题，药只能用一次。"></a>这就是典型的01背包问题，药只能用一次。</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;          </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f-j-max-f-j-f-j-v-i-w-i-并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！-知乎-zhihu-com"><a href="#对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f-j-max-f-j-f-j-v-i-w-i-并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！-知乎-zhihu-com" class="headerlink" title="对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程f[j] = max(f[j],f[j-v[i]]+w[i]) 并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章咱就把0-1背包问题讲个通透！ - 知乎 (zhihu.com)"></a>对于二维就比较好理解，对于一维来说就比较难理解了，一维的状态转移方程<code>f[j] = max(f[j],f[j-v[i]]+w[i])</code> 并且他的遍历是逆序的。为什么是逆序的呢，可以看这篇文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/345364527">咱就把0-1背包问题讲个通透！ - 知乎 (zhihu.com)</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维的01背包</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="type">int</span> ti[<span class="number">1005</span>] , pri[<span class="number">1005</span>] ;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>] ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t , m ;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++i)</span><br><span class="line">        cin &gt;&gt; ti[i] &gt;&gt; pri[i] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = t ; j &gt;= <span class="number">1</span> ; --j)<span class="comment">//逆序</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= ti[i])</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j] , f[j - ti[i]] + pri[i]) ;</span><br><span class="line">    cout &lt;&lt; f[t] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f-i-j-max-f-i-j-f-i-1-j-k-v-i-k-w-i-所以说还需要一层对k的循环，判断是k-v-i"><a href="#就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f-i-j-max-f-i-j-f-i-1-j-k-v-i-k-w-i-所以说还需要一层对k的循环，判断是k-v-i" class="headerlink" title="就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])所以说还需要一层对k的循环，判断是k*v[i]&lt;j 这就会需要三层循环。但是我们会发现f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2w...)"></a>就是每一个物品可以多次使用，所以他的二维的状态转移方程就可以<code>f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i])</code>所以说还需要一层对k的循环，判断是<code>k*v[i]&lt;j</code> 这就会需要三层循环。但是我们会发现<code>f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2w...)</code></h4><h4 id="f-i-j-v-max-f-i-1-j-v-f-i-1-j-2-v-w-f-i-1-j-3-v-2w"><a href="#f-i-j-v-max-f-i-1-j-v-f-i-1-j-2-v-w-f-i-1-j-3-v-2w" class="headerlink" title="f[i,j-v] = max(      f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-3*v]+2w...)"></a><code>f[i,j-v] = max(      f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-3*v]+2w...)</code></h4><h4 id="所以可以写成f-i-j-max-f-i-j-v-w-f-i-1-j"><a href="#所以可以写成f-i-j-max-f-i-j-v-w-f-i-1-j" class="headerlink" title="所以可以写成f[i][j] = max(f[i,j-v]+w,f[i-1][j])"></a>所以可以写成<code>f[i][j] = max(f[i,j-v]+w,f[i-1][j])</code></h4><h4 id="可以先将f-i-j-f-i-1-j-所以状态转移方程就可以写成f-i-j-max-f-i-j-f-i-j-v-i-w-i"><a href="#可以先将f-i-j-f-i-1-j-所以状态转移方程就可以写成f-i-j-max-f-i-j-f-i-j-v-i-w-i" class="headerlink" title="可以先将f[i][j] = f[i-1][j]所以状态转移方程就可以写成f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i])"></a>可以先将<code>f[i][j] = f[i-1][j]</code>所以状态转移方程就可以写成<code>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i])</code></h4><h4 id="对于完全背包的一维优化，我们可以看到就是都是关于f-i-的东西，所以跟01背包的f-i-1-是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。"><a href="#对于完全背包的一维优化，我们可以看到就是都是关于f-i-的东西，所以跟01背包的f-i-1-是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。" class="headerlink" title="对于完全背包的一维优化，我们可以看到就是都是关于f[i][]的东西，所以跟01背包的f[i-1][]是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。"></a>对于完全背包的一维优化，我们可以看到就是都是关于<code>f[i][]</code>的东西，所以跟01背包的<code>f[i-1][]</code>是逆序因为不能用到已经用过的，所以完全背是都可以因此顺序操作即可。然后对于完全背包的二维一般都有tle的可能性，所以需要优化到一维。</h4><h4 id="题目P1616-疯狂的采药"><a href="#题目P1616-疯狂的采药" class="headerlink" title="题目P1616 疯狂的采药"></a>题目P1616 疯狂的采药</h4><h4 id="P1616-疯狂的采药-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1616-疯狂的采药-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> times[N],prices[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> t,m;</span><br><span class="line">	cin&gt;&gt;t&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;times[i]&gt;&gt;prices[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = <span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">			f[j] = f[j];</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=times[i])&#123;</span><br><span class="line">				f[j] = <span class="built_in">max</span>(f[j],f[j-times[i]]+prices[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-二分法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/02/14/%E4%BA%8C%E5%88%86%E6%B3%95/" class="article-date">
  	<time datetime="2024-02-14T11:58:13.000Z" itemprop="datePublished">2024-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/02/14/%E4%BA%8C%E5%88%86%E6%B3%95/">
        二分法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="STL中的二分法"><a href="#STL中的二分法" class="headerlink" title="STL中的二分法"></a>STL中的二分法</h4><h5 id="数组是-1-2-4-4-5-6"><a href="#数组是-1-2-4-4-5-6" class="headerlink" title="数组是{1,2,4,4,5,6}"></a>数组是{1,2,4,4,5,6}</h5><h5 id="在STL中lower-bound-是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower-bound-v-begin-v-end-target-这样就会指的是第三个元素"><a href="#在STL中lower-bound-是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower-bound-v-begin-v-end-target-这样就会指的是第三个元素" class="headerlink" title="在STL中lower_bound()是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower_bound(v.begin(),v.end(),target);这样就会指的是第三个元素"></a>在STL中lower_bound()是返回第一个非递减序列中的第一个大于等于val的位置，写法是lower_bound(v.begin(),v.end(),target);这样就会指的是第三个元素</h5><h5 id="在STL中upper-bound-是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。"><a href="#在STL中upper-bound-是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。" class="headerlink" title="在STL中upper_bound()是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。"></a>在STL中upper_bound()是返回第一个大于val的位置，所有对于这个函数返回的是值为5的元素。</h5><h4 id="用STL写二分查找"><a href="#用STL写二分查找" class="headerlink" title="用STL写二分查找"></a>用STL写二分查找</h4><h5 id="输入-n-个不超过-10-9-的单调不减的（就是后面的数字不小于前面的数字）非负整数-1-2-…-a1​-a2​-…-an​，然后进行-m-次询问。对于每次询问，给出一个整数-q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出-−1-。"><a href="#输入-n-个不超过-10-9-的单调不减的（就是后面的数字不小于前面的数字）非负整数-1-2-…-a1​-a2​-…-an​，然后进行-m-次询问。对于每次询问，给出一个整数-q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出-−1-。" class="headerlink" title="输入 n 个不超过 10^9 的单调不减的（就是后面的数字不小于前面的数字）非负整数 1,2,…,a1​,a2​,…,an​，然后进行 m 次询问。对于每次询问，给出一个整数 q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 −1 。"></a>输入 n 个不超过 10^9 的单调不减的（就是后面的数字不小于前面的数字）非负整数 1,2,…,a1​,a2​,…,an​，然后进行 m 次询问。对于每次询问，给出一个整数 q，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 −1 。</h5><h5 id="题解：这里就是用函数lower-bound-来返回第一个大于等于，然后想返回序列号就用distance-，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。"><a href="#题解：这里就是用函数lower-bound-来返回第一个大于等于，然后想返回序列号就用distance-，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。" class="headerlink" title="题解：这里就是用函数lower_bound()来返回第一个大于等于，然后想返回序列号就用distance()，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。"></a>题解：这里就是用函数lower_bound()来返回第一个大于等于，然后想返回序列号就用distance()，然后数组第一个的位置是1，所有需要在原有基础上加1，然后对于判断就是it不能等于end，把并且it的值要和对应的target相同，而it的值就是星号it。</h5><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		a.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> target;</span><br><span class="line">		cin&gt;&gt;target;</span><br><span class="line">		<span class="keyword">auto</span> it =<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),target);</span><br><span class="line">		<span class="keyword">if</span>(it!=a.<span class="built_in">end</span>()&amp;&amp;*it==target)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">distance</span>(a.<span class="built_in">begin</span>(),it)+<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实数范围的二分（带小数）"><a href="#实数范围的二分（带小数）" class="headerlink" title="实数范围的二分（带小数）"></a>实数范围的二分（带小数）</h4><h5 id="对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。"><a href="#对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。" class="headerlink" title="对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。"></a>对于实数二分来说，是有许多解决方法，比如说求单调函数的零点或者极值。另外就是满足某种条件的最优解；或者是解决一些复杂度较高的问题。</h5><h5 id="用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。"><a href="#用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。" class="headerlink" title="用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。"></a>用二分法求解函数零点的例子，首先要定义一个函数是对应的表达式。然后小数二分的一个技巧是right-left要大于某个exp值，才会继续往下循环，然后就是最常规的二分操作。</h5><h5 id="举个例子，对于f-x-x-2-2，精度为1e-6，要通过二分法求零点的话。"><a href="#举个例子，对于f-x-x-2-2，精度为1e-6，要通过二分法求零点的话。" class="headerlink" title="举个例子，对于f(x) &#x3D; x^2-2，精度为1e-6，要通过二分法求零点的话。"></a>举个例子，对于f(x) &#x3D; x^2-2，精度为1e-6，要通过二分法求零点的话。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> left = <span class="number">0</span>,right = <span class="number">2</span>,eps = <span class="number">1e-6</span>;</span><br><span class="line">	<span class="keyword">while</span>(right-left&gt;eps)&#123;</span><br><span class="line">		<span class="type">double</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(mid)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;零点是:&quot;</span>&lt;&lt;left&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h4><h5 id="题目有形如：ax-3-bx-2-cx-d-0-这样的一个一元三次方程。给出该方程中各项的系数（a-b-c-d-均为实数），并约定该方程存在三个不同实根（根的范围在-−100至-100-之间），且根与根之差的绝对值-≥1。要求由小到大依次在同一行输出这三个实根-根与根之间留有空格-，并精确到小数点后-2-位。"><a href="#题目有形如：ax-3-bx-2-cx-d-0-这样的一个一元三次方程。给出该方程中各项的系数（a-b-c-d-均为实数），并约定该方程存在三个不同实根（根的范围在-−100至-100-之间），且根与根之差的绝对值-≥1。要求由小到大依次在同一行输出这三个实根-根与根之间留有空格-，并精确到小数点后-2-位。" class="headerlink" title="题目有形如：ax^3+bx^2+cx+d&#x3D;0 这样的一个一元三次方程。给出该方程中各项的系数（a,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 −100至 100 之间），且根与根之差的绝对值 ≥1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 2 位。"></a>题目有形如：ax^3+bx^2+cx+d&#x3D;0 这样的一个一元三次方程。给出该方程中各项的系数（a,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 −100至 100 之间），且根与根之差的绝对值 ≥1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 2 位。</h5><h5 id="提示：记方程-f-x-0，若存在-2-个数-x1​-和-x2​，且-x1​"><a href="#提示：记方程-f-x-0，若存在-2-个数-x1​-和-x2​，且-x1​" class="headerlink" title="提示：记方程 f(x)&#x3D;0，若存在 2 个数 x1​ 和 x2​，且 x1​&lt;x2​，f(x1​)×f(x2​)&lt;0，则在 (x1​,x2​) 之间一定有一个根。"></a>提示：记方程 f(x)&#x3D;0，若存在 2 个数 x1​ 和 x2​，且 x1​&lt;x2​，f(x1​)×f(x2​)&lt;0，则在 (x1​,x2​) 之间一定有一个根。</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="输入和输出案例"><a href="#输入和输出案例" class="headerlink" title="输入和输出案例"></a>输入和输出案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -5 -4 20</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2.00 2.00 5.00</span><br></pre></td></tr></table></figure>

<h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><h5 id="这就是典型的函数零点求解。"><a href="#这就是典型的函数零点求解。" class="headerlink" title="这就是典型的函数零点求解。"></a>这就是典型的函数零点求解。</h5><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> a,b,c,d;<span class="comment">//定义全局变量，在函数和主程序里面都有用 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a*x*x*x+b*x*x+c*x+d);<span class="comment">//万能函数，求出在未知数为x时的方程解 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1,x2,xx;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<span class="comment">//输入 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">-100</span>;x&lt;=<span class="number">100</span>;x+=<span class="number">1</span>)<span class="comment">//枚举每一个可能的根 </span></span><br><span class="line">    &#123;</span><br><span class="line">        x1=x;x2=x+<span class="number">1</span>;<span class="comment">//确定根可能所在的区间 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(x1)==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>,x1);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">f</span>(x1)*<span class="built_in">f</span>(x2)&lt;<span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">while</span>(x2-x1&gt;=<span class="number">0.001</span>)<span class="comment">//二分法确定根的值 </span></span><br><span class="line">                 &#123;</span><br><span class="line">                      xx=(x1+x2)/<span class="number">2</span>;</span><br><span class="line">                      <span class="keyword">if</span>((<span class="built_in">f</span>(x1)*<span class="built_in">f</span>(xx))&lt;=<span class="number">0</span>)x2=xx;</span><br><span class="line">                      <span class="keyword">else</span> x1=xx;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>,x1);<span class="comment">//输出根 </span></span><br><span class="line">             &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于二分法区间的操作"><a href="#对于二分法区间的操作" class="headerlink" title="对于二分法区间的操作"></a>对于二分法区间的操作</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/533408649">二分法总结 | 万字长文带你看透二分查找 - 知乎 (zhihu.com)</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag">基础算法</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2024 iolzyy
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>